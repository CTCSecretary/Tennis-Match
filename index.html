<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Social Tennis Match Maker</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="Member Master List.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f4f4f4; }

/* Logo Section Styles */
.logo-section {
  text-align: center;
  margin-bottom: 20px;
  padding: 15px;
  background: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
/* Step Header Styles */
.step-header {
  background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
  color: white;
  font-size: 24px;
  font-weight: bold;
  padding: 20px 30px;
  margin: -15px -15px 20px -15px;
  border-radius: 8px 8px 0 0;
  text-align: left;
  box-shadow: 0 2px 8px rgba(30, 64, 175, 0.3);
}
.logo {
  max-height: 80px;
  max-width: 100%;
  height: auto;
  border-radius: 8px;
  transition: all 0.3s ease;
}
.logo:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

h1 { text-align: center; color: #333; }
    .section { background: white; margin: 15px 0; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .error { color: red; font-weight: bold; }
    .success { color: green; font-weight: bold; }
    .warning { color: orange; font-weight: bold; }
    button { padding: 10px 20px; margin: 10px 5px; border: none; border-radius: 5px; cursor: pointer; }
    .primary { background: #007acc; color: white; }
    .secondary { background: #6c757d; color: white; }
    .danger { background: #dc3545; color: white; }
    
    /* Court Selection Styles */
    .court-pool {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 8px;
      margin: 15px 0;
      padding: 15px;
      border: 2px dashed #ddd;
      border-radius: 8px;
      background: #fafafa;
      min-height: 120px;
    }
    .court-item {
      background: #007acc;
      color: white;
      padding: 10px;
      text-align: center;
      border-radius: 5px;
      cursor: move;
      user-select: none;
      font-weight: bold;
      transition: all 0.2s;
    }

/* Court type specific colors */
.court-item.grass-court {
  background: #28a745 !important; /* Green for grass courts */
}

.court-item.grass-court:hover {
  background: #1e7e34 !important; /* Darker green on hover */
}

.court-item.hard-court {
  background: #007acc !important; /* Blue for hard courts */
}

.court-item.hard-court:hover {
  background: #005a99 !important; /* Darker blue on hover */
}

/* Also apply to available courts area */
.available-courts .court-item.grass-court {
  background: #28a745 !important;
}

.available-courts .court-item.grass-court:hover {
  background: #1e7e34 !important;
}

.available-courts .court-item.hard-court {
  background: #007acc !important;
}

.available-courts .court-item.hard-court:hover {
  background: #005a99 !important;
}

.court-item:hover { background: #005a99; transform: scale(1.05); }

    .court-item:hover { background: #005a99; transform: scale(1.05); }
    .court-item.dragging { opacity: 0.5; }
    
    .available-courts {
      min-height: 80px;
      padding: 15px;
      border: 2px dashed #28a745;
      border-radius: 8px;
      background: #f8fff8;
      margin: 15px 0;
    }
    .available-courts.drag-over { border-color: #007acc; background: #e3f2fd; }
    .available-courts .court-item { 
      background: #28a745; 
      margin: 5px;
      display: inline-block;
    }
    .available-courts .court-item:hover { background: #1e7e34; }
    
    /* Player Table Styles */
    .player-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
    .player-table th, .player-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    .player-table th {
      background: #f8f9fa;
      font-weight: bold;
    }
    .player-table tr:nth-child(even) {
      background: #f9f9f9;
    }
    .player-table tr:hover {
      background: #e8f4fd;
    }
    
    .name-input {
  width: 100%;
  padding: 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 16px;
}
    .name-input:focus {
      border-color: #007acc;
      outline: none;
    }
    
    .autocomplete-suggestions {
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-top: none;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      width: 100%;
    }
    .autocomplete-suggestion {
  padding: 8px;
  cursor: pointer;
  border-bottom: 1px solid #eee;
  font-size: 16px;
}
    .autocomplete-suggestion:hover {
      background: #e8f4fd;
    }
    .autocomplete-suggestion.selected {
      background: #007acc;
      color: white;
    }
    
    .checkbox-cell {
      text-align: center;
      width: 60px;
    }
    .status-checkbox {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
.grade-select, .gender-select {
      width: 100%;
      padding: 4px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-size: 14px;
      background: white;
    }
    .grade-select:focus, .gender-select:focus {
      border-color: #007acc;
      outline: none;
    }

    /* Format and Set Number Button Styles */
    .format-buttons, .set-buttons {
      display: flex;
      gap: 8px;
      margin: 15px 0;
    }
    
    .format-btn, .set-btn {
      flex: 1;
      padding: 12px 20px;
      border: 2px solid #ddd;
      background: white;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.3s ease;
      color: #666;
    }
    
    .format-btn:hover, .set-btn:hover {
      border-color: #007acc;
      background: #f8f9fa;
    }
    
    .format-btn.active {
      background: #007acc;
      border-color: #005a99;
      color: white;
      font-weight: bold;
    }
    
    .set-btn.active {
      background: #007acc;
      border-color: #005a99;
      color: white;
      font-weight: bold;
    }
    
    .format-section, .set-section {
      margin-bottom: 20px;
    }
    
    .format-label, .set-label {
      display: flex;
      align-items: center;
      font-weight: bold;
      margin-bottom: 10px;
      font-size: 16px;
      color: #666;
    }
    
       
    .sit-off-calculator {
      background: #fff3cd;
      border: 1px solid #ffc107;
      padding: 15px;
      border-radius: 5px;
      margin: 15px 0;
      text-align: center;
      font-size: 18px;
      font-weight: bold;
    }
    .sit-off-good { background: #d4edda; border-color: #28a745; color: #155724; }
    .sit-off-bad { background: #f8d7da; border-color: #dc3545; color: #721c24; }
    
    /* Manual Match Setup Styles */
    .manual-match-setup {
      border: 2px solid #ffc107;
      background: #fff8dc;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .manual-match-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .manual-match-title {
      font-size: 18px;
      font-weight: bold;
      color: #856404;
    }
    .manual-matches-list {
      margin: 15px 0;
    }
    .manual-match-item {
      background: white;
      border: 1px solid #ffc107;
      border-radius: 5px;
      padding: 12px;
      margin: 8px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .manual-match-details {
      flex: 1;
    }
    .manual-match-court {
      font-weight: bold;
      color: #007acc;
      margin-bottom: 5px;
    }
    .manual-match-teams {
      font-size: 14px;
      color: #333;
    }
    
    /* Player Selection for Manual Matches */
    .manual-player-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin: 15px 0;
    }
    .manual-player-item {
      background: white;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }
    .manual-player-item:hover {
      border-color: #007acc;
      background: #f8f9fa;
    }
    .manual-player-item.selected {
      background: #007acc;
      color: white;
      border-color: #0056b3;
    }
    .manual-player-item.excluded {
      background: #f8f9f9;
      color: #6c757d;
      border-color: #dee2e6;
      cursor: not-allowed;
    }
    
    /* Team Formation Area */
    .team-formation {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 20px;
      margin: 20px 0;
      align-items: center;
    }
    .team-slot {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 15px;
      min-height: 100px;
      background: #fafafa;
    }
    .team-slot.has-players {
      border-color: #007acc;
      background: #e3f2fd;
    }
    .team-slot-title {
      font-weight: bold;
      margin-bottom: 10px;
      text-align: center;
    }
    .team-player {
      background: white;
      border: 1px solid #007acc;
      border-radius: 4px;
      padding: 5px 8px;
      margin: 3px 0;
      font-size: 14px;
    }
    .vs-divider {
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      color: #666;
    }
    
    /* Court Selection for Manual Matches */
    .court-selector {
      margin: 15px 0;
    }
    .court-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
      margin: 10px 0;
    }
    .court-option {
      background: white;
      border: 2px solid #ddd;
      border-radius: 5px;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .court-option:hover {
      border-color: #007acc;
    }
    .court-option.selected {
      background: #007acc;
      color: white;
      border-color: #0056b3;
    }
    .court-option.excluded {
      background: #f8f9f9;
      color: #6c757d;
      border-color: #dee2e6;
      cursor: not-allowed;
    }
    
    /* Match Display Styles */
    .match-container {
      background: #f9f9f9; border: 1px solid #ddd; padding: 15px; margin: 8px 0;
      border-radius: 6px; border-left: 4px solid #007acc;
    }
    .match-container.manual-match {
      border-left: 4px solid #ffc107;
      background: #fff8dc;
    }
    .court-box {
      display: inline-block; background: #007acc; color: white; padding: 8px 12px;
      border-radius: 5px; margin-bottom: 10px; font-weight: bold; cursor: move;
      user-select: none;
    }
    .court-box.manual {
      background: #ffc107;
      color: #856404;
    }
    .court-box:hover { background: #005a99; }
    .court-box.manual:hover { background: #e0a800; }
    .court-box.dragging { opacity: 0.5; }
    .court-box.drag-over { background: #28a745; }
    
    .teams-row { display: flex; gap: 20px; align-items: flex-start; }
    .team-column { flex: 1; min-height: 80px; }
    .team-header {
      font-weight: bold; margin-bottom: 8px; text-align: center;
      padding: 5px; background: #e9e9e9; border-radius: 3px;
    }
    .player-box {
      background: white; border: 2px solid #ddd; padding: 8px; margin: 4px 0;
      border-radius: 5px; cursor: move; user-select: none; text-align: center;
      transition: all 0.2s ease;
    }
    .player-box:hover { border-color: #007acc; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    .player-box.dragging { opacity: 0.5; transform: rotate(2deg); }
    .player-box.nhc { background-color: #ffeb3b; font-weight: bold; }

/* NEW: Add NXD styling */
.player-box.nxd { 
  background-color: #ffffe0;    /* Light yellow */
  font-weight: bold; 
}

/* NEW: Combination of NHC and NXD - gradient background */
.player-box.nhc.nxd {
  background: linear-gradient(90deg, #add8e6 0%, #ffffe0 100%) !important;
  font-weight: bold;
}

    .player-box.repeat-partner { background-color: #ff9800; border: 2px solid #f57c00; font-weight: bold; }
.player-box.repeat-opponent {
  border: 3px dashed #dc3545 !important;
  box-shadow: 0 0 5px rgba(220, 53, 69, 0.5);
}

.playing-down-arrow {
  color: #cc0000;
  font-weight: bold;
  margin-right: 2px;
}

    .player-box.manual-match { background-color: #fff8dc; border: 2px solid #ffc107; }
    .player-box.drag-over { border-color: #28a745; border-width: 3px; background-color: #e8f5e8; }
    .format { font-style: italic; color: #666; margin-top: 8px; font-size: 0.9em; }
    
    .info-box { background: #cff4fc; border: 1px solid #0dcaf0; padding: 15px; border-radius: 5px; margin: 15px 0; }
    .warning-box { background: #fff3cd; border: 1px solid #ffc107; padding: 15px; border-radius: 5px; margin: 15px 0; }
.info-box { background: #cff4fc; border: 1px solid #0dcaf0; padding: 15px; border-radius: 5px; margin: 15px 0; }
.warning-box { background: #fff3cd; border: 1px solid #ffc107; padding: 15px; border-radius: 5px; margin: 15px 0; }

/* Player Selection Styles */
.selection-grid { 
  display: grid; 
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
  gap: 10px; 
  margin: 15px 0; 
}
.player-checkbox { 
  display: flex; 
  align-items: center; 
  padding: 8px; 
  border: 1px solid #ddd; 
  border-radius: 5px; 
  background: white; 
  cursor: pointer; 
  transition: all 0.2s;
}
.player-checkbox:hover { 
  border-color: #007acc; 
  background: #f8f9fa; 
}
.player-checkbox.pso { 
  background-color: #fff3cd; 
  border-color: #ffc107; 
}
.player-checkbox.selected { 
  background-color: #d4edda; 
  border-color: #28a745; 
}
.player-checkbox input { 
  margin-right: 10px; 
}

/* Auto-save indicator */
.save-status {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #28a745;
  color: white;
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 14px;
  z-index: 10000;
  transition: opacity 0.3s;
  opacity: 0;
}

.save-status.show {
  opacity: 1;
}


  </style>
</head>
<body>
  <!-- Logo Section -->
<div class="logo-section" style="position: relative;">
  <div style="display: flex; align-items: center; justify-content: center; gap: 20px;">
    <img src="CTClogo.jpg" alt="Tennis Club Logo" class="logo">
    <h1 style="margin: 0; color: #333;">Social Tennis Match Maker</h1>
  </div>
  <div style="position: absolute; bottom: 10px; right: 15px; font-size: 11px; color: #999;">
    © 2025 Problems?: Paul Oen 0438 374 643
  </div>
</div>

<div id="memberLoadStatus" style="margin: 15px 0;"></div>
  
<div style="text-align: center; margin: 15px 0; padding: 10px; background: #e3f2fd; border-radius: 5px;">
 <button id="importExcelBtn" class="secondary" style="background: #007acc;">📋 Import Excel File</button>
  <button onclick="clearSavedData()" class="danger" style="margin-left: 10px;">Clear Saved Data</button>
  <input type="file" id="excelFileInput" accept=".xlsx,.xls" style="display: none;">
  <div style="font-size: 12px; color: #666; margin-top: 5px;">Import players and courts from Excel file</div>
</div> 

 <!-- Court Selection Section -->
<div class="section">
  <div class="step-header">Step 1: Select available courts</div>
  
  
     
    <h4>Selected Courts</h4>
    <div id="availableCourts" class="available-courts">
      <em style="color: #666;">Click or Drag courts here in the order they will be used</em>
    </div>
    
    <h4>Unselected Courts:</h4>
    <div id="courtPool" class="court-pool"></div>
    
    <button id="clearCourts" class="secondary">Clear All Courts</button>
  </div>

 <!-- Set Configuration -->
  <div class="section">
    <div class="step-header">Step 2: Choose match format and set number</div>
    
    <div class="format-section">
      <div class="format-label">Set Format Preference</div>
      <div class="format-buttons">
        <button type="button" class="format-btn active" data-format="Same-Sex">Same-Sex Doubles</button>
        <button type="button" class="format-btn" data-format="Mixed">Mixed Doubles</button>
      </div>
    </div>
    
    <div class="set-section">
      <div class="set-label">Set Number</div>
      <div class="set-buttons">
        <button type="button" class="set-btn active" data-set="1">Set 1</button>
        <button type="button" class="set-btn" data-set="2">Set 2</button>
        <button type="button" class="set-btn" data-set="3">Set 3</button>
        <button type="button" class="set-btn" data-set="4">Set 4</button>
        <button type="button" class="set-btn" data-set="5">Set 5</button>
        <button type="button" class="set-btn" data-set="6">Set 6</button>
      </div>
    </div>
    
    <!-- Hidden selects for compatibility -->
    <select id="formatSelector" style="display: none;">
      <option value="Same-Sex" selected>Same-Sex Doubles</option>
      <option value="Mixed">Mixed Doubles</option>
    </select>
    <select id="setNumberSelector" style="display: none;">
      <option value="1" selected>Set 1</option>
      <option value="2">Set 2</option>
      <option value="3">Set 3</option>
      <option value="4">Set 4</option>
      <option value="5">Set 5</option>
      <option value="6">Set 6</option>
    </select>
  </div>

  <!-- Player Selection Section -->
  <div id="playerSelectionSection" class="section" style="display:none;">
    <div class="step-header">Step 3: Player Selection</div>
    
   <div id="sitOffCalculator" class="sit-off-calculator">
  <span id="sitOffCount">Players to sit off: -</span>
</div>
    
    <table class="player-table">
      <thead>
        <tr>
  <th style="width: 200px;">Name</th>
  <th style="width: 80px;">Grade</th>
  <th style="width: 80px;">Gender</th>
  <th style="width: 60px;">NHC</th>
 <th style="width: 60px;">NXD</th>
  <th style="width: 80px;">Resting</th>
  <th style="width: 60px;">PSO</th>
  <th style="width: 60px;">SO</th>
</tr>
      </thead>
      <tbody id="playerTableBody">
      </tbody>
    </table>
    
   <div style="text-align: center; margin: 15px 0;">
  <button id="addMoreRows" class="secondary">Add 10 More Rows</button>
  <button id="updateMasterList" class="secondary" style="background: #28a745;">Update Master List</button>
  <button id="proceedToMatches" class="primary" disabled>Proceed to Match Setup</button>
</div>
  </div>

  <!-- Manual Match Setup Section -->
<div id="manualMatchSection" class="section" style="display:none;">
  <div class="step-header">Step 4: Manual Match Setup (optional)</div>
  <div class="manual-match-setup">
    <div class="manual-match-header">
    
      <button id="toggleManualSetup" class="secondary">Setup Manual Match</button>
    </div>
      
      <div id="manualSetupPanel" style="display:none;">
        <div class="info-box">
          <h4>Create Manual Matches</h4>
          <p>Set up special requests or exhibition games. These players will be excluded from automatic match generation.</p>
        </div>
        
        <div id="manualPlayerSelection">
          <h4>Available Players:</h4>
          <div id="manualPlayerGrid" class="manual-player-grid"></div>
        </div>
        
        <div class="team-formation">
          <div id="team1Slot" class="team-slot">
            <div class="team-slot-title">Team 1</div>
            <div id="team1Players"></div>
          </div>
          <div class="vs-divider">VS</div>
          <div id="team2Slot" class="team-slot">
            <div class="team-slot-title">Team 2</div>
            <div id="team2Players"></div>
          </div>
        </div>
        
        <div class="court-selector">
          <h4>Select Court:</h4>
          <div id="courtGrid" class="court-grid"></div>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
          <button id="addManualMatch" class="primary" disabled>Add Manual Match</button>
          <button id="clearManualSetup" class="secondary">Clear Setup</button>
        </div>
      </div>
      
      <div id="manualMatchesList" class="manual-matches-list"></div>
    </div>
    
    <div style="text-align: center; margin: 20px 0;">
      <button id="generateMatches" class="primary">Generate Remaining Matches</button>
    </div>
  </div>

  <!-- Results Section -->
<div id="matches" class="section" style="display:none;">
  <div class="step-header">Step 5: Generated Matches</div>
  <div style="margin-bottom: 15px;">
      <button id="downloadBtn" class="primary" style="background: #28a745;">📥 Download Results as Excel</button>
      <button id="printBtn" class="primary" style="background: #007acc; margin-left: 10px;">🖨️ Print Match Sheet</button>
    </div>
    <div id="matchResults"></div>
  </div>

<script>
// Global variables
let hasPlayerChanges = false;
let masterListData = [];
let availableCourts = [];
let playerRows = [];
let debugLog = [];
let currentData = null;
let currentMatches = null;
let allSetsData = {};
let currentSetNumber = 1;

// ===== A/B SMART MIXING HELPERS (paste once) =====

// Cut an array into [A,B] halves (A gets the extra if odd)
function splitAB(arr) {
  const mid = Math.ceil(arr.length / 2);
  return [arr.slice(0, mid), arr.slice(mid)];
}

// Simple cyclic rotation (positive = right; negative = left)
function rotateRight(arr, k) {
  const n = arr.length;
  if (n === 0) return arr.slice();
  const r = ((k % n) + n) % n;
  if (r === 0) return arr.slice();
  return arr.slice(n - r).concat(arr.slice(0, n - r));
}

// Interleave two arrays A and B like A0,B0,A1,B1,...
function interleaveAB(A, B) {
  const out = [];
  const n = Math.max(A.length, B.length);
  for (let i = 0; i < n; i++) {
    if (i < A.length) out.push(A[i]);
    if (i < B.length) out.push(B[i]);
  }
  return out;
}

// A/B Smart Mixing for one gender list (already grade-sorted high→low)
// setNum = 1,2,3,...  (Set 1 = no rotation)
function mixABSmart(oneGenderSorted, setNum) {
  const n = oneGenderSorted.length;
  if (n <= 1) return oneGenderSorted.slice();

  // Split into A (top half) and B (bottom half)
  let [A, B] = splitAB(oneGenderSorted);

  // Drift each half by different amounts to avoid sticky tails.
  // Using small, different steps spreads matchups well.
  const shiftA = (setNum - 1);       // 0,1,2,3,...
  const shiftB = 2 * (setNum - 1);   // 0,2,4,6,...

  A = rotateRight(A, shiftA);
  B = rotateRight(B, shiftB);

  // Interleave to produce the mixed order
  return interleaveAB(A, B);
}


// Toggle which mixing mode to use by commenting/uncommenting one line:
// const MIXING_MODE = "torus";    // old Torus drift rotation
const MIXING_MODE = "ab-smart";   // new A/B Smart Mixing (default)


// Manual match variables
let manualMatches = [];


// Perfect 16 detection and management

function getPerfect16Schedule(setNumber) {
  // Each array represents one match: [player1, player2, player3, player4]
  // Players 1&2 are partners vs players 3&4 as partners
  // Players numbered 0-15
  
 const schedules = {
  1: [
    [0, 1, 2, 3],
    [4, 5, 6, 7],
    [8, 9, 10, 11],
    [12, 13, 14, 15]
  ],
  2: [
    [0, 4, 8, 12],
    [1, 5, 9, 13],
    [2, 6, 10, 14],
    [3, 7, 11, 15]
  ],
  3: [
    [0, 5, 10, 15],
    [1, 4, 11, 14],
    [2, 7, 8, 13],
    [3, 6, 9, 12]
  ],
  4: [
    [0, 6, 11, 13],
    [1, 7, 10, 12],
    [2, 4, 9, 15],
    [3, 5, 8, 14]
  ],
  5: [
    [0, 7, 9, 14],
    [1, 6, 8, 15],
    [2, 5, 11, 12],
    [3, 4, 10, 13]
  ]
};

  
  return schedules[setNumber] || null;
}

function generatePerfect16Matches(setNumber) {
  log("Generating Perfect 16 matches for Set " + setNumber);
  
  // Get the 16 players in order of entry
  const players = playerRows.filter(p => 
    p.name && p.name.trim() !== '' && 
    p.grade !== '' && 
    p.gender !== '' && 
    !p.resting && 
    !p.so
  );
  
  if (players.length !== 16) {
    log("ERROR: Expected 16 players, found " + players.length);
    return null;
  }
  
  // Number players 0-15 for the algorithm
  const numberedPlayers = players.map((player, index) => ({
    ...player,
    id: index
  }));
  
  // Get the predetermined schedule for this set
  const schedule = getPerfect16Schedule(setNumber);
  if (!schedule) {
    log("ERROR: No schedule found for Set " + setNumber);
    return null;
  }
  
  // Convert schedule to actual matches
  const matches = [];
  let courtIndex = 0;
  
  schedule.forEach(round => {
    if (courtIndex >= currentData.courts.length) {
      log("ERROR: Not enough courts for Perfect 16");
      return null;
    }
    
    const court = currentData.courts[courtIndex].court;
    const team1 = [numberedPlayers[round[0]], numberedPlayers[round[1]]];
    const team2 = [numberedPlayers[round[2]], numberedPlayers[round[3]]];
    
    // Determine format
    const format = players[0].gender === 'M' ? "Same-Sex Doubles (Men)" : "Same-Sex Doubles (Women)";
    
    matches.push({
      court: court,
      team1: team1,
      team2: team2,
      format: format,
      note: "Perfect 16 Set " + setNumber
    });
    
    courtIndex++;
  });
  
  log("Perfect 16: Generated " + matches.length + " matches for Set " + setNumber);
  return matches;
}

function detectPerfect16Scenario() {


  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  
  // Only applies to sets 1-5
  if (currentSetNum < 1 || currentSetNum > 5) {
    return false;
  }
  
  // Check if any manual matches exist for any set 1-5
  for (let setNum = 1; setNum <= 5; setNum++) {
    if (allSetsData[setNum] && allSetsData[setNum].matches) {
      const hasManualMatches = allSetsData[setNum].matches.some(match => match.isManual);
      if (hasManualMatches) {
        log("Perfect 16 disabled: Manual matches detected in Set " + setNum);
        return false;
      }
    }
  }
  
  // Check current manual matches
  if (manualMatches && manualMatches.length > 0) {
    log("Perfect 16 disabled: Manual matches selected for current set");
    return false;
  }
  
  // Check if we have exactly 16 players
  const activePlayers = playerRows.filter(p => 
    p.name && p.name.trim() !== '' && 
    p.grade !== '' && 
    p.gender !== '' && 
    !p.resting && 
    !p.so
  );
  
  if (activePlayers.length !== 16) {
    return false;
  }
  
  // Check if all players are same gender
  const genders = [...new Set(activePlayers.map(p => p.gender))];
  if (genders.length !== 1) {
    return false;
  }
  
  // Check if all players are same grade
  const grades = [...new Set(activePlayers.map(p => p.grade))];
  if (grades.length !== 1) {
    return false;
  }
  
  log("=== PERFECT 16 DETECTED ===");
  log("16 players, all " + genders[0] + ", all grade " + translateGrade(grades[0]));
  return true;
}

let selectedManualPlayers = [];
let selectedCourt = null;
let manualTeam1 = [];
let manualTeam2 = [];

// Auto-save functionality
function saveDataToStorage() {
  try {
    const dataToSave = {
      version: '1.0',
      timestamp: new Date().toISOString(),
      availableCourts: availableCourts,
      playerRows: playerRows,
      currentSetNumber: parseInt(document.getElementById('setNumberSelector').value),
      allSetsData: allSetsData,
      manualMatches: manualMatches,
      currentData: currentData,
      currentMatches: currentMatches,
      setFormatPreference: document.getElementById('formatSelector').value
    };
    
    localStorage.setItem('tennisMatchMaker_autoSave', JSON.stringify(dataToSave));
    localStorage.setItem('tennisMatchMaker_lastSave', new Date().toISOString());
    
    // Show brief save indicator
    showSaveIndicator();
    
  } catch (error) {
    console.warn('Failed to auto-save data:', error);
  }
}

function loadDataFromStorage() {
  try {
    const savedData = localStorage.getItem('tennisMatchMaker_autoSave');
    const lastSave = localStorage.getItem('tennisMatchMaker_lastSave');
    
    if (!savedData) return false;
    
    const data = JSON.parse(savedData);
    const saveDate = new Date(lastSave);
    const hoursSinceSave = (new Date() - saveDate) / (1000 * 60 * 60);
    
    // Don't auto-restore if more than 24 hours old
    if (hoursSinceSave > 24) {
      localStorage.removeItem('tennisMatchMaker_autoSave');
      localStorage.removeItem('tennisMatchMaker_lastSave');
      return false;
    }
    
    // Show restore prompt
    const restoreMsg = `Found saved data from ${saveDate.toLocaleString()}. Would you like to restore it?`;
    if (confirm(restoreMsg)) {
      restoreDataFromSave(data);
      return true;
    }
    
  } catch (error) {
    console.warn('Failed to load saved data:', error);
  }
  return false;
}

function restoreDataFromSave(data) {
  try {
    // Restore basic data
    availableCourts = data.availableCourts || [];
    playerRows = data.playerRows || [];
    allSetsData = data.allSetsData || {};
    manualMatches = data.manualMatches || [];
    currentData = data.currentData;
    currentMatches = data.currentMatches;
    
    // Restore UI elements
    document.getElementById('setNumberSelector').value = data.currentSetNumber || 1;
    document.getElementById('formatSelector').value = data.setFormatPreference || 'Same-Sex';
    
    // Update court display
    updateAvailableCourtsDisplay();
    
    // Restore player table
    restorePlayerTable();
    
    // Show appropriate sections
    if (playerRows.some(p => p.name && p.name.trim() !== '')) {
      document.getElementById('playerSelectionSection').style.display = 'block';
    }
    
    if (availableCourts.length > 0 && playerRows.some(p => p.name && p.name.trim() !== '')) {
      document.getElementById('manualMatchSection').style.display = 'block';
    }
    
    if (currentMatches && currentMatches.length > 0) {
      document.getElementById('matches').style.display = 'block';
      displayResults(currentData, currentMatches.filter(m => !m.isManual));
    }
    
    updateSitOffCalculation();
    updateProceedButton();
    
    alert('Data restored successfully!');
    
  } catch (error) {
    alert('Error restoring data: ' + error.message);
  }
}

function restorePlayerTable() {
  const tbody = document.getElementById('playerTableBody');
  tbody.innerHTML = '';
  
  // Ensure we have at least 10 rows
  while (playerRows.length < 10) {
    playerRows.push({
      name: '', grade: '', gender: '', nhc: false, nxd: false,
      resting: false, pso: false, so: false
    });
  }
  
  playerRows.forEach((player, index) => {
    addPlayerRowAtIndex(index);
    // Restore player data
    if (player.name) {
      document.querySelector(`[data-row="${index}"]`).value = player.name;
      document.getElementById(`grade-${index}`).value = player.grade;
      document.getElementById(`gender-${index}`).value = player.gender;
      document.getElementById(`nhc-${index}`).checked = player.nhc;
      document.getElementById(`nxd-${index}`).checked = player.nxd;
      document.getElementById(`resting-${index}`).checked = player.resting;
      document.getElementById(`pso-${index}`).checked = player.pso;
      document.getElementById(`so-${index}`).checked = player.so;
      
      // Show delete button if player has data
      if (player.name && player.grade && player.gender) {
        document.querySelector(`[data-row="${index}"].delete-player-btn`).style.display = 'block';
      }
    }
  });
}

function addPlayerRowAtIndex(rowIndex) {
  const tbody = document.getElementById('playerTableBody');
  
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td style="position: relative;">
      <div style="display: flex; align-items: center; gap: 5px;">
        <input type="text" class="name-input" placeholder="Start typing name..." 
               data-row="${rowIndex}" autocomplete="off" style="flex: 1;">
        <button type="button" class="delete-player-btn" data-row="${rowIndex}" 
                style="background: #dc3545; color: white; border: none; border-radius: 3px; 
                       padding: 3px 6px; font-size: 12px; cursor: pointer; display: none;"
                title="Remove player">×</button>
      </div>
      <div class="autocomplete-suggestions" id="suggestions-${rowIndex}" style="display: none;"></div>
    </td>
    <td>
      <select class="grade-select" id="grade-${rowIndex}" data-row="${rowIndex}">
        <option value="">-</option>
        <option value="5">2</option>
        <option value="4">2A</option>
        <option value="3">2B</option>
        <option value="2">3</option>
        <option value="1">3A</option>
      </select>
    </td>
    <td>
      <select class="gender-select" id="gender-${rowIndex}" data-row="${rowIndex}">
        <option value="">-</option>
        <option value="M">M</option>
        <option value="F">F</option>
      </select>
    </td>
    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="nhc-${rowIndex}" data-row="${rowIndex}">
    </td>
    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="nxd-${rowIndex}" data-row="${rowIndex}">
    </td>
    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="resting-${rowIndex}" data-row="${rowIndex}">
    </td>
    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="pso-${rowIndex}" data-row="${rowIndex}">
    </td>
    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="so-${rowIndex}" data-row="${rowIndex}">
    </td>
  `;
  
  tbody.appendChild(tr);
  
  // Add all the event listeners (same as in addPlayerRow function)
  const nameInput = tr.querySelector('.name-input');
  nameInput.addEventListener('input', (e) => handleNameInput(e, rowIndex));
  nameInput.addEventListener('keydown', (e) => handleNameKeydown(e, rowIndex));
  nameInput.addEventListener('blur', (e) => setTimeout(() => hideSuggestions(rowIndex), 150));
  
// ADD THIS MISSING LISTENER: Manual name entry for visitors
nameInput.addEventListener('input', (e) => {
  // Update the playerRows data when someone types manually
  playerRows[rowIndex].name = e.target.value;
  
  // Show delete button if player has name, grade, and gender
  const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
  if (e.target.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
    deleteBtn.style.display = 'block';
  } else {
    deleteBtn.style.display = 'none';
  }
  
  // Update calculations
  updateSitOffCalculation();
  updateProceedButton();
  saveDataToStorage(); // Auto-save
});

  // Add other event listeners...
  const restingCheckbox = tr.querySelector(`#resting-${rowIndex}`);
  restingCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].resting = e.target.checked;
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
  });
  
  const psoCheckbox = tr.querySelector(`#pso-${rowIndex}`);
  psoCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].pso = e.target.checked;
    saveDataToStorage(); // Auto-save
  });
  
  const soCheckbox = tr.querySelector(`#so-${rowIndex}`);
  soCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].so = e.target.checked;
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
  });
  
  const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
  deleteBtn.addEventListener('click', () => {
    clearPlayerRow(rowIndex);
    saveDataToStorage(); // Auto-save
  });
  
  const gradeSelect = tr.querySelector(`#grade-${rowIndex}`);
  gradeSelect.addEventListener('change', (e) => {
    playerRows[rowIndex].grade = e.target.value === '' ? '' : parseInt(e.target.value);
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
  });
  
  const genderSelect = tr.querySelector(`#gender-${rowIndex}`);
  genderSelect.addEventListener('change', (e) => {
    playerRows[rowIndex].gender = e.target.value;
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
  });
  
  const nhcCheckbox = tr.querySelector(`#nhc-${rowIndex}`);
  nhcCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].nhc = e.target.checked;
    saveDataToStorage(); // Auto-save
  });
  
  const nxdCheckbox = tr.querySelector(`#nxd-${rowIndex}`);
  nxdCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].nxd = e.target.checked;
    saveDataToStorage(); // Auto-save
  });
}

function showSaveIndicator() {
  // Create or update save indicator
  let indicator = document.getElementById('saveIndicator');
  if (!indicator) {
    indicator = document.createElement('div');
    indicator.id = 'saveIndicator';
    indicator.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #28a745;
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10000;
      transition: opacity 0.3s;
    `;
    document.body.appendChild(indicator);
  }
  
  indicator.textContent = 'Saved ✓';
  indicator.style.opacity = '1';
  
  setTimeout(() => {
    indicator.style.opacity = '0';
  }, 2000);
}

function clearSavedData() {
  if (confirm('Are you sure you want to clear all saved data? This cannot be undone.')) {
    localStorage.removeItem('tennisMatchMaker_autoSave');
    localStorage.removeItem('tennisMatchMaker_lastSave');
    alert('Saved data cleared successfully.');
  }
}

// Logging function
function log(message) {
  console.log(message);
  debugLog.push(message);
}
// Smooth scroll function
function scrollToElement(elementId) {
  const element = document.getElementById(elementId);
  if (element) {
    element.scrollIntoView({ 
      behavior: 'smooth', 
      block: 'start' 
    });
  }
}

// Grade translation function - converts numeric grades to club format
function translateGrade(numericGrade) {
  switch(numericGrade) {
    case 5: return '2';
    case 4: return '2A';
    case 3: return '2B';
    case 2: return '3';
    case 1: return '3A';
    default: return numericGrade; // fallback for any unexpected values
  }
}

// Reverse grade translation function - converts club codes to numeric grades
function reverseTranslateGrade(clubCode) {
  switch(clubCode) {
    case "2": return 5;      // Strongest
    case "2A": return 4;
    case "2B": return 3;
    case "3": return 2;
    case "3A": return 1;     // Weakest
    default: return clubCode; // fallback for any unexpected values
  }
}

// Helper function to generate the JavaScript file content
function generateJSFileContent(membersArray) {
  let jsContent = '// Tennis Club Member Master List\n';
  jsContent += '// Generated on: ' + new Date().toLocaleString() + '\n';
  jsContent += '// Total Members: ' + membersArray.length + '\n\n';
  jsContent += 'const MEMBERS = [\n';
  
  membersArray.forEach((member, index) => {
    jsContent += '  {\n';
    jsContent += `    name: "${member.name}",\n`;
    jsContent += `    grade: ${member.grade},\n`;
    jsContent += `    gender: "${member.gender}",\n`;
    jsContent += `    nhc: ${member.nhc}\n`;
    jsContent += '  }';
    
    // Add comma if not the last item
    if (index < membersArray.length - 1) {
      jsContent += ',';
    }
    jsContent += '\n';
  });
  
  jsContent += '];\n';
  return jsContent;
}

// Helper function to download the JavaScript file
function downloadJSFile(content) {
  // Create a blob with the JavaScript content
  const blob = new Blob([content], { type: 'text/javascript' });
  
  // Create a download link
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  
  // Generate filename with timestamp
  const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
  link.download = `Member Master List - Updated ${timestamp}.js`;
  
  // Trigger download
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up the URL
  URL.revokeObjectURL(url);
}

// Initialize courts (37 courts: 1-27, H1-H10)
function initializeCourts() {
  const courtPool = document.getElementById('courtPool');
  courtPool.innerHTML = '';
  
  const courts = [];
  
  // Grass courts 1-27
  for (let i = 1; i <= 27; i++) {
    courts.push(i.toString());
  }
  
  // Hard courts H1-H10
  for (let i = 1; i <= 10; i++) {
    courts.push('H' + i);
  }
  
  courts.forEach(court => {
  const courtDiv = document.createElement('div');
  // Determine court type and add appropriate class
  const isHardCourt = court.toString().toUpperCase().startsWith('H');
  courtDiv.className = isHardCourt ? 'court-item hard-court' : 'court-item grass-court';
  courtDiv.textContent = court;
  courtDiv.draggable = true;
  courtDiv.dataset.court = court;
    
   courtDiv.addEventListener('dragstart', handleCourtDragStart);
courtDiv.addEventListener('dragend', handleCourtDragEnd);
courtDiv.addEventListener('click', () => moveCourtToSelected(court, courtDiv));

courtPool.appendChild(courtDiv);
  });
}

// Court drag and drop handlers
function handleCourtDragStart(e) {
  e.dataTransfer.setData('text/plain', e.target.dataset.court);
  e.target.classList.add('dragging');
}

function handleCourtDragEnd(e) {
  e.target.classList.remove('dragging');
}

// Available courts drag and drop
const availableCourtsDiv = document.getElementById('availableCourts');

availableCourtsDiv.addEventListener('dragover', (e) => {
  e.preventDefault();
  availableCourtsDiv.classList.add('drag-over');
});

availableCourtsDiv.addEventListener('dragleave', (e) => {
  availableCourtsDiv.classList.remove('drag-over');
});

availableCourtsDiv.addEventListener('drop', (e) => {
  e.preventDefault();
  availableCourtsDiv.classList.remove('drag-over');
  
  const court = e.dataTransfer.getData('text/plain');
  if (court && !availableCourts.includes(court)) {
    availableCourts.push(court);
    updateAvailableCourtsDisplay();
    
    // Remove from court pool
    const courtElement = document.querySelector(`[data-court="${court}"]`);
    if (courtElement && courtElement.parentElement.id === 'courtPool') {
      courtElement.remove();
    }
  }
});

// Function to generate and download updated Member Master List
function generateUpdatedMasterList() {
  try {
    // Start with existing members from the original file
    let updatedMembers = [...masterListData];
    
    // Get all players that have been manually entered or modified
    const currentPlayers = playerRows.filter(p => 
      p.name && p.name.trim() !== '' && 
      p.grade !== '' && 
      p.gender !== ''
    );
    
    let addedCount = 0;
    let updatedCount = 0;
    
    currentPlayers.forEach(currentPlayer => {
      // Check if this player exists in the original master list
      const existingIndex = updatedMembers.findIndex(member => 
        member.name.toLowerCase() === currentPlayer.name.toLowerCase()
      );
      
      if (existingIndex >= 0) {
        // Player exists - check if any data has changed
        const existing = updatedMembers[existingIndex];
        if (existing.grade !== currentPlayer.grade || 
            existing.gender !== currentPlayer.gender ||
            existing.nhc !== currentPlayer.nhc) {
          
          // Update existing player
          updatedMembers[existingIndex] = {
            name: currentPlayer.name,
            grade: currentPlayer.grade,
            gender: currentPlayer.gender,
            nhc: currentPlayer.nhc
          };
          updatedCount++;
        }
      } else {
        // New player - add to the list
        updatedMembers.push({
          name: currentPlayer.name,
          grade: currentPlayer.grade,
          gender: currentPlayer.gender,
          nhc: currentPlayer.nhc
        });
        addedCount++;
      }
    });
    
    // Sort the updated list alphabetically by name
    updatedMembers.sort((a, b) => a.name.localeCompare(b.name));
    
    // Generate the JavaScript file content
    const jsContent = generateJSFileContent(updatedMembers);
    
    // Create and download the file
    downloadJSFile(jsContent);
    
    // Show success message
    const message = `Master list updated successfully!\nAdded: ${addedCount} new players\nUpdated: ${updatedCount} existing players\nTotal players: ${updatedMembers.length}`;
    alert(message);
    
    log(`Master list generated: ${addedCount} added, ${updatedCount} updated, ${updatedMembers.length} total`);
    
  } catch (error) {
    alert(`Error generating master list: ${error.message}`);
    log(`Error generating master list: ${error.message}`);
  }
}

function updateAvailableCourtsDisplay() {
  const availableCourtsDiv = document.getElementById('availableCourts');
  
  if (availableCourts.length === 0) {
    availableCourtsDiv.innerHTML = '<em style="color: #666;">Click courts below to add them in priority order...</em>';
    return;
  }
  
  availableCourtsDiv.innerHTML = '';
  
  availableCourts.forEach((court, index) => {
    const courtDiv = document.createElement('div');
const isHardCourt = court.toString().toUpperCase().startsWith('H');
courtDiv.className = isHardCourt ? 'court-item hard-court' : 'court-item grass-court';
    courtDiv.textContent = court;
    courtDiv.style.cursor = 'pointer';
    courtDiv.title = 'Click to remove from selection';
    
    // Allow removing courts by clicking
    courtDiv.addEventListener('click', () => {
      moveCourtBackToPool(court, index);
    });
    
    availableCourtsDiv.appendChild(courtDiv);
  });
}

function moveCourtBackToPool(court, index) {
  // Remove from available courts
  availableCourts.splice(index, 1);
  updateAvailableCourtsDisplay();
  
  // Add back to court pool with click functionality
  addCourtToPool(court);
}

function addCourtToPool(court) {
  const courtPool = document.getElementById('courtPool');
  const newCourtDiv = document.createElement('div');
  const isHardCourt = court.toString().toUpperCase().startsWith('H');
  newCourtDiv.className = isHardCourt ? 'court-item hard-court' : 'court-item grass-court';
  newCourtDiv.textContent = court;
  newCourtDiv.draggable = true;
  newCourtDiv.dataset.court = court;
  newCourtDiv.style.cursor = 'pointer';
  newCourtDiv.title = 'Click to add to selection, or drag to specific position';
  
  // Add drag functionality
  newCourtDiv.addEventListener('dragstart', handleCourtDragStart);
  newCourtDiv.addEventListener('dragend', handleCourtDragEnd);

  // Add click functionality  
  newCourtDiv.addEventListener('click', () => {
    if (!availableCourts.includes(court)) {
      moveCourtToSelected(court, newCourtDiv);
    }
  });
  
  // Insert in correct position instead of just appending
  const existingCourts = Array.from(courtPool.children);
  let insertPosition = existingCourts.length; // Default to end
  
  for (let i = 0; i < existingCourts.length; i++) {
    const existingCourt = existingCourts[i].dataset.court;
    if (shouldCourtComeBefore(court, existingCourt)) {
      insertPosition = i;
      break;
    }
  }
  
  if (insertPosition >= existingCourts.length) {
    courtPool.appendChild(newCourtDiv);
  } else {
    courtPool.insertBefore(newCourtDiv, existingCourts[insertPosition]);
  }
}

// Helper function to determine court order
function shouldCourtComeBefore(court1, court2) {
  const isHard1 = court1.toString().toUpperCase().startsWith('H');
  const isHard2 = court2.toString().toUpperCase().startsWith('H');
  
  // Grass courts (1-27) come before hard courts (H1-H10)
  if (!isHard1 && isHard2) return true;
  if (isHard1 && !isHard2) return false;
  
  // Both are same type, sort numerically
  if (!isHard1 && !isHard2) {
    // Both grass courts - numerical sort
    return parseInt(court1) < parseInt(court2);
  } else {
    // Both hard courts - extract number after H and sort
    const num1 = parseInt(court1.substring(1));
    const num2 = parseInt(court2.substring(1));
    return num1 < num2;
  }
}
  

function moveCourtToSelected(court, courtElement) {
  // Only add if not already selected
  if (!availableCourts.includes(court)) {
    availableCourts.push(court);
    updateAvailableCourtsDisplay();
saveDataToStorage();
    
    // Remove from court pool
    courtElement.remove();
  }
}

// Clear courts button
document.getElementById('clearCourts').addEventListener('click', () => {
  availableCourts = [];
  updateAvailableCourtsDisplay();
  initializeCourts();
});

// Auto-load member list on page initialization
function loadMemberListOnStartup() {
  try {
    // Check if MEMBERS is available
    if (typeof MEMBERS === 'undefined') {
      document.getElementById('memberLoadStatus').innerHTML = 
        '<div class="error">❌ Member Master List.js file not found. Please ensure the file is in the same folder as this HTML file.</div>';
      return;
    }
    
   // Load members from the JavaScript file and convert club codes to numeric
masterListData = MEMBERS.map(member => ({
  name: member.name,
  grade: reverseTranslateGrade(member.grade), // Convert club code to numeric
  gender: member.gender,
  nhc: member.nhc,
 nxd: member.nxd,
  originalGrade: member.grade // Keep original club code for display
}));
    
    document.getElementById('memberLoadStatus').innerHTML = 
      `<div class="success">✓ Loaded ${masterListData.length} players from member list</div>`;
    
    // Show player selection section
    document.getElementById('playerSelectionSection').style.display = 'block';
    initializePlayerTable();
    
  } catch (error) {
    document.getElementById('memberLoadStatus').innerHTML = 
      `<div class="error">Error loading member list: ${error.message}</div>`;
  }
}

// Initialize player table
function initializePlayerTable() {
  playerRows = [];
  const tbody = document.getElementById('playerTableBody');
  tbody.innerHTML = '';
  
  // Add initial 10 rows
  for (let i = 0; i < 10; i++) {
    addPlayerRow();
  }
  
  updateSitOffCalculation();
}

function addPlayerRow() {
  const tbody = document.getElementById('playerTableBody');
  const rowIndex = playerRows.length;
  
  const row = {
  name: '',
  grade: '',
  gender: '',
  nhc: false,
nxd: false,
  resting: false,
  pso: false,
  so: false
};
  playerRows.push(row);
  
  const tr = document.createElement('tr');
tr.innerHTML = `
  <td style="position: relative;">
    <div style="display: flex; align-items: center; gap: 5px;">
      <input type="text" class="name-input" placeholder="Start typing name..." 
             data-row="${rowIndex}" autocomplete="off" style="flex: 1;">
      <button type="button" class="delete-player-btn" data-row="${rowIndex}" 
              style="background: #dc3545; color: white; border: none; border-radius: 3px; 
                     padding: 3px 6px; font-size: 12px; cursor: pointer; display: none;"
              title="Remove player">×</button>
    </div>
    <div class="autocomplete-suggestions" id="suggestions-${rowIndex}" style="display: none;"></div>
  </td>
  <td>
    <select class="grade-select" id="grade-${rowIndex}" data-row="${rowIndex}">
  <option value="">-</option>
  <option value="5">2</option>
  <option value="4">2A</option>
  <option value="3">2B</option>
  <option value="2">3</option>
  <option value="1">3A</option>
</select>
  </td>
  <td>
    <select class="gender-select" id="gender-${rowIndex}" data-row="${rowIndex}">
      <option value="">-</option>
      <option value="M">M</option>
      <option value="F">F</option>
    </select>
  </td>
 <td class="checkbox-cell">
  <input type="checkbox" class="status-checkbox" id="nhc-${rowIndex}" data-row="${rowIndex}">
</td>
<td class="checkbox-cell">
  <input type="checkbox" class="status-checkbox" id="nxd-${rowIndex}" data-row="${rowIndex}">
</td>
<td class="checkbox-cell">
  <input type="checkbox" class="status-checkbox" id="resting-${rowIndex}" data-row="${rowIndex}">
</td>
<td class="checkbox-cell">
  <input type="checkbox" class="status-checkbox" id="pso-${rowIndex}" data-row="${rowIndex}">
</td>
<td class="checkbox-cell">
  <input type="checkbox" class="status-checkbox" id="so-${rowIndex}" data-row="${rowIndex}">
</td>
`;
  
  tbody.appendChild(tr);
  
  // Add event listeners
  const nameInput = tr.querySelector('.name-input');
  nameInput.addEventListener('input', (e) => handleNameInput(e, rowIndex));
  nameInput.addEventListener('keydown', (e) => handleNameKeydown(e, rowIndex));
  nameInput.addEventListener('blur', (e) => setTimeout(() => hideSuggestions(rowIndex), 150));

// Add event listener for manual name entry (visitors)
nameInput.addEventListener('input', (e) => {
  // Update the playerRows data when someone types manually
  playerRows[rowIndex].name = e.target.value;
  
  // Show delete button if player has name, grade, and gender
  const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
  if (e.target.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
    deleteBtn.style.display = 'block';
  } else {
    deleteBtn.style.display = 'none';
  }
  
  // Update calculations
  updateSitOffCalculation();
  updateProceedButton();
});
  
 const restingCheckbox = tr.querySelector(`#resting-${rowIndex}`);
restingCheckbox.addEventListener('change', (e) => {
  playerRows[rowIndex].resting = e.target.checked;
  updateSitOffCalculation();
  updateProceedButton();
});
  
  const psoCheckbox = tr.querySelector(`#pso-${rowIndex}`);
  psoCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].pso = e.target.checked;
  });
const soCheckbox = tr.querySelector(`#so-${rowIndex}`);
soCheckbox.addEventListener('change', (e) => {
  playerRows[rowIndex].so = e.target.checked;
  updateSitOffCalculation();
  updateProceedButton();
});

const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
deleteBtn.addEventListener('click', () => {
  clearPlayerRow(rowIndex);
});
// Add event listeners for manual editing
const gradeSelect = tr.querySelector(`#grade-${rowIndex}`);
gradeSelect.addEventListener('change', (e) => {
playerRows[rowIndex].grade = e.target.value === '' ? '' : parseInt(e.target.value);
  // Show delete button if player has name, grade, and gender
  const nameInput = tr.querySelector('.name-input');
  const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
  if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
    deleteBtn.style.display = 'block';
  }
  updateSitOffCalculation();
  updateProceedButton();
});

const genderSelect = tr.querySelector(`#gender-${rowIndex}`);
genderSelect.addEventListener('change', (e) => {
  playerRows[rowIndex].gender = e.target.value;
  // Show delete button if player has name, grade, and gender
  const nameInput = tr.querySelector('.name-input');
  const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
  if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
    deleteBtn.style.display = 'block';
  }
  updateSitOffCalculation();
  updateProceedButton();
});

const nhcCheckbox = tr.querySelector(`#nhc-${rowIndex}`);
nhcCheckbox.addEventListener('change', (e) => {
  playerRows[rowIndex].nhc = e.target.checked;
});

const nxdCheckbox = tr.querySelector(`#nxd-${rowIndex}`);
nxdCheckbox.addEventListener('change', (e) => {
  playerRows[rowIndex].nxd = e.target.checked;
});
}

function handleNameInput(e, rowIndex) {
  const input = e.target.value.toLowerCase();
  const suggestionsDiv = document.getElementById(`suggestions-${rowIndex}`);
  
  if (input.length === 0) {
    hideSuggestions(rowIndex);
    return;
  }
  
  // Get list of already used names (excluding current row)
  const usedNames = playerRows
    .map((p, index) => index !== rowIndex ? p.name : null)
    .filter(name => name && name.trim() !== '');
  
  // PREFIX MATCHING: Filter players whose first OR last name starts with the input
  const matches = masterListData.filter(player => {
    if (usedNames.includes(player.name)) return false; // Exclude already used names
    
    const nameParts = player.name.toLowerCase().split(' ');
    // Check if any name part (first, last, etc.) starts with the input
    return nameParts.some(part => part.startsWith(input));
  }).sort((a, b) => a.name.localeCompare(b.name)) // Sort alphabetically by name
    .slice(0, 10); // Limit to 10 suggestions
  
  if (matches.length === 0) {
    hideSuggestions(rowIndex);
    return;
  }
  
  suggestionsDiv.innerHTML = '';
  matches.forEach((player, index) => {
    const suggestionDiv = document.createElement('div');
    suggestionDiv.className = 'autocomplete-suggestion';
    if (index === 0) suggestionDiv.classList.add('selected'); // Auto-select first item
    suggestionDiv.textContent = `${player.name} (${player.originalGrade || translateGrade(player.grade)})`;
    suggestionDiv.addEventListener('click', () => selectPlayer(rowIndex, player));
    suggestionsDiv.appendChild(suggestionDiv);
  });
  
  suggestionsDiv.style.display = 'block';
}
function handleNameKeydown(e, rowIndex) {
  const suggestionsDiv = document.getElementById(`suggestions-${rowIndex}`);
  const suggestions = suggestionsDiv.querySelectorAll('.autocomplete-suggestion');
  
  if (suggestions.length === 0) return;
  
  let selectedIndex = -1;
  // Find currently selected suggestion
  suggestions.forEach((suggestion, index) => {
    if (suggestion.classList.contains('selected')) {
      selectedIndex = index;
    }
  });
  
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    // Remove current selection
    if (selectedIndex >= 0) {
      suggestions[selectedIndex].classList.remove('selected');
    }
    // Select next item (or first if none selected)
    selectedIndex = selectedIndex < suggestions.length - 1 ? selectedIndex + 1 : 0;
    suggestions[selectedIndex].classList.add('selected');
    suggestions[selectedIndex].scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    // Remove current selection
    if (selectedIndex >= 0) {
      suggestions[selectedIndex].classList.remove('selected');
    }
    // Select previous item (or last if none selected)
    selectedIndex = selectedIndex > 0 ? selectedIndex - 1 : suggestions.length - 1;
    suggestions[selectedIndex].classList.add('selected');
    suggestions[selectedIndex].scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'Enter') {
    e.preventDefault();
    // If something is selected, click it; otherwise click the first suggestion
    const targetSuggestion = selectedIndex >= 0 ? suggestions[selectedIndex] : suggestions[0];
    if (targetSuggestion) {
      targetSuggestion.click();
    }
  } else if (e.key === 'Escape') {
    hideSuggestions(rowIndex);
  }
}
function selectPlayer(rowIndex, player) {
 playerRows[rowIndex] = {
  name: player.name,
  grade: player.grade,
  gender: player.gender,
  nhc: player.nhc,
nxd: player.nxd,
  resting: playerRows[rowIndex].resting,
  pso: playerRows[rowIndex].pso,
  so: playerRows[rowIndex].so
};
  
// Update the UI
  document.querySelector(`[data-row="${rowIndex}"]`).value = player.name;
  document.getElementById(`grade-${rowIndex}`).value = player.grade;
  document.getElementById(`gender-${rowIndex}`).value = player.gender;
  document.getElementById(`nhc-${rowIndex}`).checked = player.nhc;
document.getElementById(`nxd-${rowIndex}`).checked = player.nxd; 
  
// Show the delete button
document.querySelector(`[data-row="${rowIndex}"].delete-player-btn`).style.display = 'block';

hideSuggestions(rowIndex);
updateSitOffCalculation();
updateProceedButton();
saveDataToStorage();

// Auto-focus next empty name field
setTimeout(() => {
  for (let i = rowIndex + 1; i < playerRows.length; i++) {
    if (!playerRows[i].name || playerRows[i].name.trim() === '') {
      const nextInput = document.querySelector(`[data-row="${i}"]`);
      if (nextInput) {
        nextInput.focus();
        break;
      }
    }
  }
}, 100);
}
function clearPlayerRow(rowIndex) {
  // Clear the player data
  playerRows[rowIndex] = {
    name: '',
    grade: '',
    gender: '',
    nhc: false,
nxd: false,
    resting: false,
    pso: false,
    so: false
  };
  
// Clear the UI
  document.querySelector(`[data-row="${rowIndex}"]`).value = '';
  document.getElementById(`grade-${rowIndex}`).value = '';
  document.getElementById(`gender-${rowIndex}`).value = '';
  document.getElementById(`nhc-${rowIndex}`).checked = false;
document.getElementById(`nxd-${rowIndex}`).checked = false;
  document.getElementById(`resting-${rowIndex}`).checked = false;
  document.getElementById(`pso-${rowIndex}`).checked = false;
  document.getElementById(`so-${rowIndex}`).checked = false;
  
  // Hide the delete button
  document.querySelector(`[data-row="${rowIndex}"].delete-player-btn`).style.display = 'none';
  
  // Update calculations
  updateSitOffCalculation();
  updateProceedButton();
}

function hideSuggestions(rowIndex) {
  const suggestionsDiv = document.getElementById(`suggestions-${rowIndex}`);
  suggestionsDiv.style.display = 'none';
}

function updateSitOffCalculation() {
  const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting);
  const soPlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting && p.so);
  const totalActivePlayers = activePlayers.length;
  
  // Calculate court capacity
  const maxCourtCapacity = availableCourts.length * 4;
  
  // Calculate sit-offs needed for divisibility (groups of 4)
  const divisibilitySitOffs = totalActivePlayers % 4;
  
  // Calculate sit-offs needed due to court capacity
  const capacitySitOffs = Math.max(0, totalActivePlayers - maxCourtCapacity);
  
  // Total sit-offs needed is the larger of the two requirements
  const totalNeededToSitOff = Math.max(divisibilitySitOffs, capacitySitOffs);
  
  const alreadySelectedToSitOff = soPlayers.length;
  const remainingToSelect = Math.max(0, totalNeededToSitOff - alreadySelectedToSitOff);
  
  const sitOffElement = document.getElementById('sitOffCount');
  const calculatorElement = document.getElementById('sitOffCalculator');
  
  // Update the display text with explanation
  let displayText = `Players to sit off: ${remainingToSelect}`;
  
  if (totalActivePlayers > 0 && availableCourts.length > 0) {
    if (capacitySitOffs > 0) {
  displayText += ` (due to court capacity: ${totalActivePlayers} players > ${maxCourtCapacity} max capacity)`;
} else if (divisibilitySitOffs > 0) {
  displayText += ` (for even teams of 4)`;
}
  }
  
  sitOffElement.innerHTML = displayText;
  
  // Update styling based on remaining count
  calculatorElement.className = 'sit-off-calculator';
  if (totalNeededToSitOff === 0) {
    calculatorElement.classList.add('sit-off-good');
  } else if (remainingToSelect === 0) {
    calculatorElement.classList.add('sit-off-good');
  } else {
    // Keep default styling when players still need to be selected
  }
}

function autoSelectSitOffPlayers() {
  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting);
  // Calculate court capacity
const maxCourtCapacity = availableCourts.length * 4;

// Calculate sit-offs needed for divisibility (groups of 4)
const divisibilitySitOffs = activePlayers.length % 4;

// Calculate sit-offs needed due to court capacity
const capacitySitOffs = Math.max(0, activePlayers.length - maxCourtCapacity);

// Total sit-offs needed is the larger of the two requirements
const totalNeededToSitOff = Math.max(divisibilitySitOffs, capacitySitOffs);
  
  if (totalNeededToSitOff === 0) return; // No sit-offs needed
  
  // Clear any existing SO selections (but not PSO)
  playerRows.forEach((player, index) => {
    if (!player.pso) {
      player.so = false;
      const soCheckbox = document.getElementById(`so-${index}`);
      if (soCheckbox) soCheckbox.checked = false;
    }
  });
  
  let eligiblePlayers = [];
  
  if (currentSetNum === 1) {
    // Set 1: All non-PSO active players are eligible (from bottom of arrival list)
    eligiblePlayers = activePlayers.filter(player => !player.pso).slice(-totalNeededToSitOff);
  } else {
    // Set 2+: Calculate participation for each player, preserving original order
    const playerSetCounts = activePlayers
      .filter(player => !player.pso)
      .map(player => {
        let setsPlayed = 0;
        for (let setNum = 1; setNum < currentSetNum; setNum++) {
          if (!allSetsData[setNum] || !allSetsData[setNum].matches) continue;
          
          const playedInSet = allSetsData[setNum].matches.some(match => 
            match.team1.some(p => p.name === player.name) || 
            match.team2.some(p => p.name === player.name)
          );
          
          if (playedInSet) setsPlayed++;
        }
        return { player, setsPlayed };
      });
    
    // Try each participation level from highest to lowest
    const maxSetsPlayed = Math.max(...playerSetCounts.map(p => p.setsPlayed));
    
    for (let setsPlayed = maxSetsPlayed; setsPlayed >= 0 && eligiblePlayers.length < totalNeededToSitOff; setsPlayed--) {
      // Get players at this level, maintaining original arrival order
      const playersAtThisLevel = playerSetCounts
        .filter(p => p.setsPlayed === setsPlayed)
        .map(p => p.player);
      
      // Select from bottom of this group
      const needed = totalNeededToSitOff - eligiblePlayers.length;
      const toAdd = playersAtThisLevel.slice(-needed);
      eligiblePlayers = eligiblePlayers.concat(toAdd);
      
      if (eligiblePlayers.length >= totalNeededToSitOff) {
        log(`Selected from players with ${setsPlayed} sets played`);
        break;
      }
    }
  }
  
  // Apply the selections
  eligiblePlayers.forEach(selectedPlayer => {
    const playerIndex = playerRows.findIndex(p => p.name === selectedPlayer.name);
    if (playerIndex >= 0) {
      playerRows[playerIndex].so = true;
      const soCheckbox = document.getElementById(`so-${playerIndex}`);
      if (soCheckbox) soCheckbox.checked = true;
    }
  });
  
  // Update UI
  updateSitOffCalculation();
  updateProceedButton();
  saveDataToStorage();
  
  log(`Auto-selected ${eligiblePlayers.length} players to sit off for Set ${currentSetNum}: ${eligiblePlayers.map(p => p.name).join(', ')}`);
}

function updateProceedButton() {
  const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting);
  const soPlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.gender !== '' && !p.resting && p.so);
  const proceedBtn = document.getElementById('proceedToMatches');
  
  if (activePlayers.length >= 4 && availableCourts.length > 0) {
    const totalActivePlayers = activePlayers.length;

// Calculate court capacity (same logic as updateSitOffCalculation)
const maxCourtCapacity = availableCourts.length * 4;
const divisibilitySitOffs = totalActivePlayers % 4;
const capacitySitOffs = Math.max(0, totalActivePlayers - maxCourtCapacity);
const sitOffNeeded = Math.max(divisibilitySitOffs, capacitySitOffs);

const sitOffSelected = soPlayers.length;
    
    if (sitOffNeeded === 0 && sitOffSelected === 0) {
      // No sit-offs needed, none selected - perfect
      proceedBtn.disabled = false;
      proceedBtn.textContent = 'Proceed to Match Setup';
      proceedBtn.dataset.action = 'proceed';
    } else if (sitOffNeeded > 0 && sitOffSelected === sitOffNeeded) {
      // Sit-offs needed and correct number selected
      proceedBtn.disabled = false;
      proceedBtn.textContent = 'Proceed to Match Setup';
      proceedBtn.dataset.action = 'proceed';
    } else if (sitOffNeeded > 0 && sitOffSelected < sitOffNeeded) {
      // Need more selections - show suggest button
      proceedBtn.disabled = false;
      proceedBtn.textContent = 'Suggest names to sit off';
      proceedBtn.dataset.action = 'suggest';
    } else if (sitOffNeeded > 0 && sitOffSelected > sitOffNeeded) {
      // Too many selected
      const excess = sitOffSelected - sitOffNeeded;
      proceedBtn.disabled = true;
      proceedBtn.textContent = `Remove ${excess} sit-off selections`;
      proceedBtn.dataset.action = 'disabled';
    } else if (sitOffNeeded === 0 && sitOffSelected > 0) {
      // No sit-offs needed but some selected
      proceedBtn.disabled = true;
      proceedBtn.textContent = `Remove ${sitOffSelected} sit-off selections (none needed)`;
      proceedBtn.dataset.action = 'disabled';
    }
  } else {
    proceedBtn.disabled = true;
    proceedBtn.textContent = 'Proceed to Match Setup';
    proceedBtn.dataset.action = 'disabled';
  }
}
// Add more rows button
document.getElementById('addMoreRows').addEventListener('click', () => {
  for (let i = 0; i < 10; i++) {
    addPlayerRow();
  }
});

// Update Master List button
document.getElementById('updateMasterList').addEventListener('click', generateUpdatedMasterList);
// Set number change handler
document.getElementById('setNumberSelector').addEventListener('change', function() {
  const newSetNumber = parseInt(this.value);
  const previousSetNumber = newSetNumber - 1;
  
  // If moving to set 2 or higher, move SO players to PSO
  if (newSetNumber > 1 && allSetsData[previousSetNumber]) {
    const previousSatOffPlayers = allSetsData[previousSetNumber].satOffPlayers || [];
    
    // Update player data: move SO to PSO for previously sat-off players
    playerRows.forEach((player, index) => {
      if (previousSatOffPlayers.includes(player.name)) {
        // Move from SO to PSO
        player.so = false;
        player.pso = true;
        
        // Update the UI checkboxes
        const soCheckbox = document.getElementById(`so-${index}`);
        const psoCheckbox = document.getElementById(`pso-${index}`);
        
        if (soCheckbox) soCheckbox.checked = false;
        if (psoCheckbox) psoCheckbox.checked = true;
      }
    });
    
    console.log(`Moved ${previousSatOffPlayers.length} players from SO to PSO for Set ${newSetNumber}`);
  }
  
  // Reset current set SO selections and validation
  playerRows.forEach((player, index) => {
    if (!player.pso) { // Don't reset PSO players
      player.so = false;
      const soCheckbox = document.getElementById(`so-${index}`);
      if (soCheckbox) soCheckbox.checked = false;
    }
  });
  
  // Update calculations and button state
  updateSitOffCalculation();
  updateProceedButton();
  
  // Hide any open sections
  document.getElementById('manualMatchSection').style.display = 'none';
  document.getElementById('matches').style.display = 'none';
  document.getElementById('generateMatches').textContent = `Generate Remaining Matches for Set ${newSetNumber}`;
});

// Proceed to matches button - improved with conditional logic
document.getElementById('proceedToMatches').addEventListener('click', (e) => {
  const action = e.target.dataset.action;
  
  if (action === 'proceed') {
    processPlayersAndProceed();
    // Scroll to manual match section after a brief delay
    setTimeout(() => {
      scrollToElement('manualMatchSection');
    }, 100);
  } else if (action === 'suggest') {
    autoSelectSitOffPlayers();
  }
  // Do nothing if action is 'disabled' or undefined
});

function processPlayersAndProceed() {
  // Create data structure similar to original format
  const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting && !p.so);
  
  const availableMen = activePlayers.filter(p => p.gender === 'M');
  const availableWomen = activePlayers.filter(p => p.gender === 'F');
  
  // Create courts data structure with mixing for Set 2+
const courts = availableCourts.map((court, index) => ({
  priority: index + 1,
  court: court
}));

const setNumber = parseInt(document.getElementById('setNumberSelector').value);
const finalCourts = mixCourts(courts, setNumber);
  
  currentData = {
  setFormatPreference: document.getElementById('formatSelector').value,
  availableMen: availableMen,
  availableWomen: availableWomen,
  courts: finalCourts
};
  
  console.log('Processed data:', currentData);
  
  // Show manual match setup and scroll to it
  setupManualMatchInterface(currentData);
  document.getElementById('manualMatchSection').style.display = 'block';
  saveDataToStorage();
  document.getElementById('generateMatches').textContent = `Generate Remaining Matches for Set ${document.getElementById('setNumberSelector').value}`;
  
  // Scroll to manual match section after a brief delay
  setTimeout(() => {
    scrollToElement('manualMatchSection');
  }, 100);
}

  
 
// Manual match setup functions
function setupManualMatchInterface(data) {
  const playerGrid = document.getElementById('manualPlayerGrid');
  const courtGrid = document.getElementById('courtGrid');
  
  // Clear previous setup
  playerGrid.innerHTML = '';
  courtGrid.innerHTML = '';
  manualMatches = [];
  updateManualMatchDisplay();
  
  // Populate available players
  const allPlayers = [];
  data.availableMen.forEach(p => allPlayers.push({...p, gender: 'M'}));
  data.availableWomen.forEach(p => allPlayers.push({...p, gender: 'F'}));
  
  allPlayers.sort((a, b) => {
    if (b.grade !== a.grade) return b.grade - a.grade;
    return a.name.localeCompare(b.name);
  });
  
  allPlayers.forEach(player => {
    const playerDiv = document.createElement('div');
    playerDiv.className = 'manual-player-item';
    playerDiv.innerHTML = `${player.name} (${translateGrade(player.grade)})`;
    playerDiv.dataset.playerName = player.name;
    playerDiv.dataset.playerGrade = player.grade;
    playerDiv.dataset.playerGender = player.gender;
    
    playerDiv.addEventListener('click', () => selectPlayerForManualMatch(playerDiv, player));
    playerGrid.appendChild(playerDiv);
  });
  
 // Populate available courts
data.courts.forEach(courtData => {
  const courtDiv = document.createElement('div');
  courtDiv.className = 'court-option';
  courtDiv.innerHTML = `Court ${courtData.court}`;
  courtDiv.dataset.court = courtData.court;
  
  courtDiv.addEventListener('click', () => selectCourtForManualMatch(courtDiv, courtData.court));
  courtGrid.appendChild(courtDiv);
});
}

function selectPlayerForManualMatch(element, player) {
  if (element.classList.contains('excluded')) return;
  
  if (element.classList.contains('selected')) {
    // Deselect player
    element.classList.remove('selected');
    selectedManualPlayers = selectedManualPlayers.filter(p => p.name !== player.name);
    removePlayerFromTeams(player.name);
  } else {
    // Select player (max 4)
    if (selectedManualPlayers.length >= 4) {
      alert('Maximum 4 players can be selected for a match');
      return;
    }
    
    element.classList.add('selected');
    selectedManualPlayers.push(player);
    addPlayerToTeam(player);
  }
  
  updateTeamDisplay();
  updateAddMatchButton();
}

function addPlayerToTeam(player) {
  if (manualTeam1.length < 2) {
    manualTeam1.push(player);
  } else {
    manualTeam2.push(player);
  }
}

function removePlayerFromTeams(playerName) {
  manualTeam1 = manualTeam1.filter(p => p.name !== playerName);
  manualTeam2 = manualTeam2.filter(p => p.name !== playerName);
}

function updateTeamDisplay() {
  const team1Div = document.getElementById('team1Players');
  const team2Div = document.getElementById('team2Players');
  
  team1Div.innerHTML = manualTeam1.map(p => 
`<div class="team-player">${p.name} (${translateGrade(p.grade)}, ${p.gender})</div>`
  ).join('');
  
  team2Div.innerHTML = manualTeam2.map(p => 
    `<div class="team-player">${p.name} (${translateGrade(p.grade)}, ${p.gender})</div>`
  ).join('');
  
  // Update team slot styling
  document.getElementById('team1Slot').classList.toggle('has-players', manualTeam1.length > 0);
  document.getElementById('team2Slot').classList.toggle('has-players', manualTeam2.length > 0);
}

function selectCourtForManualMatch(element, court) {
  if (element.classList.contains('excluded')) return;
  
  // Clear previous selection
  document.querySelectorAll('.court-option').forEach(el => el.classList.remove('selected'));
  
  // Select new court
  element.classList.add('selected');
  selectedCourt = court;
  updateAddMatchButton();
}

function updateAddMatchButton() {
  const addBtn = document.getElementById('addManualMatch');
  const canAdd = selectedManualPlayers.length === 4 && 
                 manualTeam1.length === 2 && 
                 manualTeam2.length === 2 && 
                 selectedCourt !== null;
  
  addBtn.disabled = !canAdd;
  
  if (canAdd) {
    addBtn.textContent = `Add Match: Court ${selectedCourt}`;
  } else {
    addBtn.textContent = 'Add Manual Match';
  }
}

function addManualMatch() {
  if (selectedManualPlayers.length !== 4 || !selectedCourt) return;
  
  // Determine match format
  const team1Men = manualTeam1.filter(p => p.gender === 'M').length;
  const team1Women = manualTeam1.filter(p => p.gender === 'F').length;
  const team2Men = manualTeam2.filter(p => p.gender === 'M').length;
  const team2Women = manualTeam2.filter(p => p.gender === 'F').length;
  
  let format;
  if (team1Men === 1 && team1Women === 1 && team2Men === 1 && team2Women === 1) {
    format = "Mixed Doubles";
  } else if (team1Men === 2 && team2Men === 2) {
    format = "Same-Sex Doubles (Men)";
  } else if (team1Women === 2 && team2Women === 2) {
    format = "Same-Sex Doubles (Women)";
  } else {
    format = "Mixed Gender";
  }
  
  const manualMatch = {
    court: selectedCourt,
    team1: [...manualTeam1],
    team2: [...manualTeam2],
    format: format,
    note: "Manual Setup",
    isManual: true
  };
  
  manualMatches.push(manualMatch);
  
  // Mark players as excluded
  selectedManualPlayers.forEach(player => {
    const playerElement = document.querySelector(`[data-player-name="${player.name}"]`);
    if (playerElement) {
      playerElement.classList.remove('selected');
      playerElement.classList.add('excluded');
    }
  });
  
  // Mark court as excluded
  const courtElement = document.querySelector(`[data-court="${selectedCourt}"]`);
  if (courtElement) {
    courtElement.classList.remove('selected');
    courtElement.classList.add('excluded');
  }
  
  // Clear selection
  selectedManualPlayers = [];
  selectedCourt = null;
  manualTeam1 = [];
  manualTeam2 = [];
  
  updateTeamDisplay();
  updateAddMatchButton();
  updateManualMatchDisplay();
saveDataToStorage();
  
  console.log(`Manual match added: Court ${manualMatch.court} - ${format}`);
}

function updateManualMatchDisplay() {
  const listDiv = document.getElementById('manualMatchesList');
  
  if (manualMatches.length === 0) {
    listDiv.innerHTML = '<p style="color: #666; font-style: italic;">No manual matches set up yet.</p>';
    return;
  }
  
  let html = '<h4>Manual Matches:</h4>';
  
  manualMatches.forEach((match, index) => {
    const team1Str = match.team1.map(p => `${p.name} (${p.grade})`).join(', ');
    const team2Str = match.team2.map(p => `${p.name} (${p.grade})`).join(', ');
    
    html += `
      <div class="manual-match-item">
        <div class="manual-match-details">
          <div class="manual-match-court">Court ${match.court}</div>
          <div class="manual-match-teams">${team1Str} vs ${team2Str}</div>
          <div style="font-size: 12px; color: #666;">${match.format}</div>
        </div>
        <button class="danger" onclick="removeManualMatch(${index})">Remove</button>
      </div>
    `;
  });
  
  listDiv.innerHTML = html;
}

function removeManualMatch(index) {
  const removedMatch = manualMatches[index];
  
  // Restore players as available
  [...removedMatch.team1, ...removedMatch.team2].forEach(player => {
    const playerElement = document.querySelector(`[data-player-name="${player.name}"]`);
    if (playerElement) {
      playerElement.classList.remove('excluded');
    }
  });
  
  // Restore court as available
  const courtElement = document.querySelector(`[data-court="${removedMatch.court}"]`);
  if (courtElement) {
    courtElement.classList.remove('excluded');
  }
  
  manualMatches.splice(index, 1);
  updateManualMatchDisplay();
  
  console.log(`Manual match removed: Court ${removedMatch.court}`);
}

function clearManualSetup() {
  // Clear all selections
  document.querySelectorAll('.manual-player-item').forEach(el => {
    el.classList.remove('selected', 'excluded');
  });
  document.querySelectorAll('.court-option').forEach(el => {
    el.classList.remove('selected', 'excluded');
  });
  
  selectedManualPlayers = [];
  selectedCourt = null;
  manualTeam1 = [];
  manualTeam2 = [];
  
  updateTeamDisplay();
  updateAddMatchButton();
}

// Event handlers for manual match setup
document.getElementById('toggleManualSetup').addEventListener('click', function() {
  const panel = document.getElementById('manualSetupPanel');
  const isVisible = panel.style.display !== 'none';
  
  panel.style.display = isVisible ? 'none' : 'block';
  this.textContent = isVisible ? 'Setup Manual Match' : 'Hide Manual Setup';
});

document.getElementById('addManualMatch').addEventListener('click', addManualMatch);
document.getElementById('clearManualSetup').addEventListener('click', clearManualSetup);

// Generate matches button
document.getElementById('generateMatches').addEventListener('click', () => {
  processMatchesWithManualSetup();
  // Scroll to results section after a brief delay
  setTimeout(() => {
    scrollToElement('matches');
  }, 500); // Slightly longer delay to allow for match generation
});

function processMatchesWithManualSetup() {
  // Remove manual match players from available pools
  const excludedPlayers = [];
  const excludedCourts = [];
  
  manualMatches.forEach(match => {
    match.team1.forEach(p => excludedPlayers.push(p.name));
    match.team2.forEach(p => excludedPlayers.push(p.name));
    excludedCourts.push(match.court);
  });
  
  // Filter out excluded players
  const adjustedData = {
  ...currentData,
  availableMen: currentData.availableMen.filter(p => !excludedPlayers.includes(p.name)),
  availableWomen: currentData.availableWomen.filter(p => !excludedPlayers.includes(p.name)),
  courts: currentData.courts.filter(c => !excludedCourts.includes(c.court))
};

  
  console.log(`Excluded ${excludedPlayers.length} players and ${excludedCourts.length} courts for manual matches`);
  
  const totalRemainingPlayers = adjustedData.availableMen.length + adjustedData.availableWomen.length;
  const remainder = totalRemainingPlayers % 4;
  
  if (remainder === 0) {
  // Don't overwrite currentData - keep the original for Excel export
  const dataForMatching = adjustedData;
  processMatchesWithAdjustedData(dataForMatching);
} else {
  alert(`Cannot proceed: ${remainder} players remaining after manual matches. Need multiple of 4.`);
}
}

// Match generation functions (from original code)
// Original processMatches function (for when no manual matches)

function processMatches() {
  
// Check for Perfect 16 first
  if (detectPerfect16Scenario()) {
    const perfect16Matches = generatePerfect16Matches(parseInt(document.getElementById('setNumberSelector').value));
    if (perfect16Matches) {
      // Apply court preferences to Perfect 16 matches
      const courtOptimizedMatches = processCourtPreferences(currentData, perfect16Matches);
      currentMatches = courtOptimizedMatches;
      displayResults(currentData, courtOptimizedMatches);
      return;
    } else {
const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
    if (currentSetNum === 6) {
        log("=== EXITING PERFECT 16 MODE - SWITCHING TO NORMAL ALGORITHMS ===");
    }
      log("Perfect 16 failed, falling back to normal algorithm");
    }
  }
  
  log("=== STARTING MATCH FORMATION ===");
  
  const sortedData = sortPlayers(currentData);

  const matches = formMatchesStrict(sortedData);
  const balancedMatches = matches.map(match => balanceTeamsIfNeeded(match));
  const finalMatches = processCourtPreferences(sortedData, balancedMatches);
 
// Auto-fix repeat partnerships before display
const optimizedMatches = autoFixRepeatPartnerships(sortedData, finalMatches);

// NEW: Auto-fix repeat opponents (after partnerships, before competitiveness)
const opponentOptimizedMatches = autoFixRepeatOpponents(sortedData, optimizedMatches);

// NEW: Final competitiveness optimization
const competitiveMatches = fixUncompetitiveMatches(sortedData, opponentOptimizedMatches);

  // NEW: Final individual match balancing
  const finalBalancedMatches = balanceIndividualMatches(sortedData, competitiveMatches);

  currentData = sortedData;
  currentMatches = finalBalancedMatches;
  displayResults(sortedData, finalBalancedMatches);
}
// New function for processing with adjusted data (after manual matches)

function processMatchesWithAdjustedData(adjustedData) {
  // Check for Perfect 16 first
  if (detectPerfect16Scenario()) {
    const perfect16Matches = generatePerfect16Matches(parseInt(document.getElementById('setNumberSelector').value));
    if (perfect16Matches) {
      // Apply court preferences to Perfect 16 matches
      const courtOptimizedMatches = processCourtPreferences(currentData, perfect16Matches);
      currentMatches = courtOptimizedMatches;
      displayResults(currentData, courtOptimizedMatches);
      return;
    } else {
      log("Perfect 16 failed, falling back to normal algorithm");
    }
  }
  
  log("=== STARTING MATCH FORMATION (ADJUSTED FOR MANUAL MATCHES) ===");
  
  const sortedData = sortPlayers(adjustedData);
  const matches = formMatchesStrict(sortedData);
  const balancedMatches = matches.map(match => balanceTeamsIfNeeded(match));
  const finalMatches = processCourtPreferences(sortedData, balancedMatches);
  const optimizedMatches = autoFixRepeatPartnerships(sortedData, finalMatches);

// NEW: Auto-fix repeat opponents (after partnerships, before competitiveness)
const opponentOptimizedMatches = autoFixRepeatOpponents(sortedData, optimizedMatches);

// NEW: Final competitiveness optimization
const competitiveMatches = fixUncompetitiveMatches(sortedData, opponentOptimizedMatches);

  // NEW: Final individual match balancing  
  const individuallyBalancedMatches = balanceIndividualMatches(sortedData, competitiveMatches);

  currentMatches = individuallyBalancedMatches;
  // Use original currentData for display/export, but show generated matches
  displayResults(currentData, individuallyBalancedMatches);
}

function mixCourts(courts, setNumber) {
  if (!courts || courts.length === 0 || setNumber === 1) {
    return courts; // Set 1: use original order exactly as selected
  }
  
  // Separate grass courts from hard courts
  const grassCourts = courts.filter(c => !c.court.toString().toUpperCase().startsWith('H'));
  const hardCourts = courts.filter(c => c.court.toString().toUpperCase().startsWith('H'));
  
  // Only shuffle grass courts if we have more than 1
  if (grassCourts.length <= 1) {
    return courts; // No mixing needed
  }
  
  // Shuffle grass courts randomly
  const shuffledGrassCourts = [...grassCourts];
  for (let i = shuffledGrassCourts.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledGrassCourts[i], shuffledGrassCourts[j]] = [shuffledGrassCourts[j], shuffledGrassCourts[i]];
  }
  
  log(`Court mixing: Randomly shuffled ${grassCourts.length} grass courts for Set ${setNumber}`);
  log(`Original grass order: ${grassCourts.map(c => c.court).join(', ')}`);
  log(`Shuffled grass order: ${shuffledGrassCourts.map(c => c.court).join(', ')}`);
  
  // Recombine: shuffled grass courts first, then hard courts as backup
  const mixedCourts = [...shuffledGrassCourts, ...hardCourts];
  
  // Restore priority numbering
  return mixedCourts.map((court, index) => ({
    priority: index + 1,
    court: court.court
  }));
}

function sortPlayers(data) {
  // Always start with grade-sorted lists
  const sortedMen = data.availableMen.sort((a, b) => b.grade - a.grade);
  const sortedWomen = data.availableWomen.sort((a, b) => b.grade - a.grade);

  // === Mixing step (toggle: A/B vs Torus) ===
  const setNumber = parseInt(document.getElementById('setNumberSelector').value);

  let mixedMen, mixedWomen;
  if (MIXING_MODE === "ab-smart") {
    mixedMen = mixABSmart(sortedMen.slice(), setNumber);
    mixedWomen = mixABSmart(sortedWomen.slice(), setNumber);
    log("Applied A/B Smart Mixing for Set " + setNumber);
  } else {
    // Torus drift fallback (only used if MIXING_MODE = "torus")
    const drift = Math.max(0, setNumber - 1);
    function rotatePlayersTorus(arr, drift) {
      const n = arr.length; if (n <= 1) return arr.slice();
      const k = ((drift % n) + n) % n;
      return arr.slice(k).concat(arr.slice(0, k));
    }
    mixedMen = rotatePlayersTorus(sortedMen.slice(), drift);
    mixedWomen = rotatePlayersTorus(sortedWomen.slice(), drift);
    log("Applied Torus Drift rotation (drift = " + drift + ") for Set " + setNumber);
  }

  // Logging after mixing
  log("=== SORTED PLAYERS (after mixing) ===");
  for (let grade = 5; grade >= 1; grade--) {
    const menCount = mixedMen.filter(p => p.grade === grade).length;
    const womenCount = mixedWomen.filter(p => p.grade === grade).length;
    if (menCount > 0 || womenCount > 0) {
      log("Grade " + grade + ": " + menCount + " men, " + womenCount + " women");
    }
  }

  // Return with mixed lists
  return { ...data, sortedMen: mixedMen, sortedWomen: mixedWomen };
}

function formMatchesStrict(data) {
  log("=== STRICT MATCH FORMATION ===");
  
  if (data.setFormatPreference === "Mixed") {
    return formMixedDoublesMatches(data);
  } else {
    return formSameSexDoublesMatches(data);
  }
}

function formMixedDoublesMatches(data) {
  log("Using Mixed Doubles Logic");
  
  const matches = [];
  const assigned = new Set();
  let courtIndex = 0;

  const createMatch = (team1, team2, format, note) => {
    if (courtIndex >= data.courts.length) {
      log("ERROR: No more courts available");
      return null;
    }

    const t1Men = team1.filter(p => data.sortedMen.find(m => m.name === p.name)).length;
    const t1Women = team1.filter(p => data.sortedWomen.find(w => w.name === p.name)).length;
    const t2Men = team2.filter(p => data.sortedMen.find(m => m.name === p.name)).length;
    const t2Women = team2.filter(p => data.sortedWomen.find(w => w.name === p.name)).length;

    if ((t1Men === 2 && t1Women === 0 && t2Men === 0 && t2Women === 2) ||
        (t1Men === 0 && t1Women === 2 && t2Men === 2 && t2Women === 0)) {
      log("ERROR: Attempted prohibited 2M vs 2W match");
      return null;
    }

    const court = data.courts[courtIndex].court;
    courtIndex++;

    team1.forEach(p => assigned.add(p.name));
    team2.forEach(p => assigned.add(p.name));

    log("Created match on Court " + court + ": " + 
        team1.map(p => p.name + "(" + p.grade + ")").join(",") + " vs " +
        team2.map(p => p.name + "(" + p.grade + ")").join(",") + " - " + format);

    return { court, team1, team2, format, note };
  };

  for (let targetGrade = 5; targetGrade >= 1; targetGrade--) {
    log("=== PROCESSING GRADE " + targetGrade + " ===");
    
    // ENHANCED: Check for cross-grade balancing opportunity first
const unassignedMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
const unassignedWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
const lowerMen = data.sortedMen.filter(p => p.grade === (targetGrade - 1) && !assigned.has(p.name));
const lowerWomen = data.sortedWomen.filter(p => p.grade === (targetGrade - 1) && !assigned.has(p.name));

// If we have exactly 1M+1W of current grade and 1M+1W of lower grade, create balanced match
if (unassignedMen.length === 1 && unassignedWomen.length === 1 && 
    lowerMen.length >= 1 && lowerWomen.length >= 1) {
  const match = createMatch(
    [unassignedMen[0], lowerWomen[0]],
    [lowerMen[0], unassignedWomen[0]],
    "Mixed Doubles",
    "Cross-grade balanced"
  );
  if (match) {
    matches.push(match);
    continue; // Process next grade
  }
}

// Normal in-grade processing
while (true) {
  const currentMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
  const currentWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
  
  if (currentMen.length >= 2 && currentWomen.length >= 2) {
    const match = createMatch(
      [currentMen[0], currentWomen[0]],
      [currentMen[1], currentWomen[1]],
      "Mixed Doubles",
      "In-grade"
    );
    if (match) matches.push(match);
  } else {
    break;
  }
}

    log("MANDATORY COMPLETION: All Grade " + targetGrade + " players must be assigned");
    
    let attempts = 0;
    while (attempts < 100) {
      attempts++;
      
      const remainingMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      const remainingWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      
      if (remainingMen.length === 0 && remainingWomen.length === 0) {
        log("✓ SUCCESS: ALL Grade " + targetGrade + " players assigned");
        break;
      }

      const lowerMen = data.sortedMen.filter(p => p.grade < targetGrade && !assigned.has(p.name));
      const lowerWomen = data.sortedWomen.filter(p => p.grade < targetGrade && !assigned.has(p.name));

      log("Attempt " + attempts + ": Grade " + targetGrade + " remaining: " + 
          remainingMen.length + "M + " + remainingWomen.length + "F");
      log("Available lower: " + lowerMen.length + "M + " + lowerWomen.length + "F");

      let matchCreated = false;

      if (remainingMen.length >= 4) {
        const match = createMatch(
          [remainingMen[0], remainingMen[1]],
          [remainingMen[2], remainingMen[3]],
          "Same-Sex Doubles (Men)",
          "Mandatory completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 4) {
        const match = createMatch(
          [remainingWomen[0], remainingWomen[1]],
          [remainingWomen[2], remainingWomen[3]],
          "Same-Sex Doubles (Women)",
          "Mandatory completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length === 3 && remainingWomen.length >= 1) {
        const match = createMatch(
          [remainingMen[0], remainingWomen[0]],
          [remainingMen[1], remainingMen[2]],
          "Mixed Gender",
          "Mandatory completion 3M+1W"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length === 3 && remainingMen.length >= 1) {
        const match = createMatch(
          [remainingMen[0], remainingWomen[0]],
          [remainingWomen[1], remainingWomen[2]],
          "Mixed Gender",
          "Mandatory completion 1M+3W"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 2 && lowerWomen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerWomen[0]],
          [remainingMen[1], lowerWomen[1]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 2 && lowerMen.length >= 2) {
        const match = createMatch(
          [lowerMen[0], remainingWomen[0]],
          [lowerMen[1], remainingWomen[1]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 1 && lowerMen.length >= 3) {
        const match = createMatch(
          [remainingMen[0], lowerMen[0]],
          [lowerMen[1], lowerMen[2]],
          "Same-Sex Doubles (Men)",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 1 && lowerWomen.length >= 3) {
        const match = createMatch(
          [remainingWomen[0], lowerWomen[0]],
          [lowerWomen[1], lowerWomen[2]],
          "Same-Sex Doubles (Women)",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 1 && lowerMen.length >= 1 && lowerWomen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerWomen[0]],
          [lowerMen[0], lowerWomen[1]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 1 && lowerWomen.length >= 1 && lowerMen.length >= 2) {
        const match = createMatch(
          [lowerMen[0], remainingWomen[0]],
          [lowerMen[1], lowerWomen[0]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }

      if (!matchCreated) {
        log("❌ CRITICAL ERROR: Cannot complete Grade " + targetGrade);
        log("Remaining target players: " + 
            remainingMen.map(p => p.name).join(",") + " | " + 
            remainingWomen.map(p => p.name).join(","));
        log("Available lower players: " + lowerMen.length + "M + " + lowerWomen.length + "F");
        break;
      }
    }
  }

  log("=== FINAL CLEANUP PHASE ===");
  let cleanupAttempts = 0;
  while (cleanupAttempts < 20) {
    cleanupAttempts++;
    
    const allUnassignedMen = data.sortedMen.filter(p => !assigned.has(p.name));
    const allUnassignedWomen = data.sortedWomen.filter(p => !assigned.has(p.name));
    
    if (allUnassignedMen.length === 0 && allUnassignedWomen.length === 0) {
      log("✓ CLEANUP SUCCESS: All players assigned");
      break;
    }
    
    log("Cleanup attempt " + cleanupAttempts + ": " + allUnassignedMen.length + "M + " + allUnassignedWomen.length + "W remaining");
    
    let cleanupMatchCreated = false;
    
    if (allUnassignedMen.length >= 4) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedMen[1]],
        [allUnassignedMen[2], allUnassignedMen[3]],
        "Same-Sex Doubles (Men)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length >= 4) {
      const match = createMatch(
        [allUnassignedWomen[0], allUnassignedWomen[1]],
        [allUnassignedWomen[2], allUnassignedWomen[3]],
        "Same-Sex Doubles (Women)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length >= 2 && allUnassignedWomen.length >= 2) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedWomen[1]],
        "Mixed Doubles",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length === 3 && allUnassignedWomen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedMen[2]],
        "Mixed Gender",
        "Final cleanup 3M+1W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length === 3 && allUnassignedMen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedWomen[1], allUnassignedWomen[2]],
        "Mixed Gender",
        "Final cleanup 1M+3W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    
    if (!cleanupMatchCreated) {
      log("❌ CLEANUP FAILED: Cannot form matches from remaining players");
      break;
    }
  }

  const finalUnassignedMen = data.sortedMen.filter(p => !assigned.has(p.name));
  const finalUnassignedWomen = data.sortedWomen.filter(p => !assigned.has(p.name));
  
  log("=== FINAL STATUS ===");
  log("Total matches created: " + matches.length);
  log("Unassigned players: " + (finalUnassignedMen.length + finalUnassignedWomen.length));
  
  if (finalUnassignedMen.length > 0 || finalUnassignedWomen.length > 0) {
    log("❌ ERROR: Players remain unassigned!");
    log("Unassigned men: " + finalUnassignedMen.map(p => p.name + "(" + p.grade + ")").join(", "));
    log("Unassigned women: " + finalUnassignedWomen.map(p => p.name + "(" + p.grade + ")").join(", "));
  }

  return matches;
}

function formSameSexDoublesMatches(data) {
  log("Using Same-Sex Doubles Logic");
  
  const matches = [];
  const assigned = new Set();
  let courtIndex = 0;

  const createMatch = (team1, team2, format, note) => {
    if (courtIndex >= data.courts.length) return null;

    const court = data.courts[courtIndex].court;
    courtIndex++;

    team1.forEach(p => assigned.add(p.name));
    team2.forEach(p => assigned.add(p.name));

    log("Created match on Court " + court + ": " + 
        team1.map(p => p.name + "(" + p.grade + ")").join(",") + " vs " +
        team2.map(p => p.name + "(" + p.grade + ")").join(","));

    return { court, team1, team2, format, note };
  };

  for (let targetGrade = 5; targetGrade >= 1; targetGrade--) {
    log("=== PROCESSING GRADE " + targetGrade + " ===");
    
    while (true) {
      const menThisGrade = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      if (menThisGrade.length >= 4) {
        const match = createMatch(
          [menThisGrade[0], menThisGrade[1]],
          [menThisGrade[2], menThisGrade[3]],
          "Same-Sex Doubles (Men)", "In-grade"
        );
        if (match) matches.push(match);
      } else break;
    }
    
    while (true) {
      const womenThisGrade = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      if (womenThisGrade.length >= 4) {
        const match = createMatch(
          [womenThisGrade[0], womenThisGrade[1]],
          [womenThisGrade[2], womenThisGrade[3]],
          "Same-Sex Doubles (Women)", "In-grade"
        );
        if (match) matches.push(match);
      } else break;
    }
    
    let attempts = 0;
    while (attempts < 20) {
      attempts++;
      
      const remainingMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      const remainingWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      
      if (remainingMen.length === 0 && remainingWomen.length === 0) {
        log("✓ SUCCESS: ALL Grade " + targetGrade + " players assigned");
        break;
      }

      const lowerMen = data.sortedMen.filter(p => p.grade < targetGrade && !assigned.has(p.name));
      const lowerWomen = data.sortedWomen.filter(p => p.grade < targetGrade && !assigned.has(p.name));

      let matchCreated = false;

      // Prefer, in order (same-sex): 3+1 (when exactly 3 leftovers), then 2+2, then 1+3.
// Mixed-gender cross-grade is considered only after same-sex options.

// ===== 3+1 SAME-SEX (MEN) — use all three Grade-5 together: 5+5 vs 5+4
if (!matchCreated && remainingMen.length === 3 && lowerMen.length >= 1) {
  const match = createMatch(
    [remainingMen[0], remainingMen[1]],
    [remainingMen[2], lowerMen[0]],
    "Same-Sex Doubles (Men)",
    "Cross-grade 3+1 (preferred for exactly 3 leftovers)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== 3+1 SAME-SEX (WOMEN)
else if (!matchCreated && remainingWomen.length === 3 && lowerWomen.length >= 1) {
  const match = createMatch(
    [remainingWomen[0], remainingWomen[1]],
    [remainingWomen[2], lowerWomen[0]],
    "Same-Sex Doubles (Women)",
    "Cross-grade 3+1 (preferred for exactly 3 leftovers)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== 2+2 SAME-SEX (MEN) — 5+4 vs 5+4 (preferred when >=2 leftovers)
else if (!matchCreated && remainingMen.length >= 2 && lowerMen.length >= 2) {
  const match = createMatch(
    [remainingMen[0], lowerMen[0]],
    [remainingMen[1], lowerMen[1]],
    "Same-Sex Doubles (Men)",
    "Cross-grade 2+2 (preferred after 3+1)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== 2+2 SAME-SEX (WOMEN)
else if (!matchCreated && remainingWomen.length >= 2 && lowerWomen.length >= 2) {
  const match = createMatch(
    [remainingWomen[0], lowerWomen[0]],
    [remainingWomen[1], lowerWomen[1]],
    "Same-Sex Doubles (Women)",
    "Cross-grade 2+2 (preferred after 3+1)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== Mixed-gender completions (only if policy allows), after same-sex options
else if (!matchCreated && remainingMen.length === 3 && remainingWomen.length === 1) {
  const match = createMatch(
    [remainingMen[0], remainingWomen[0]],
    [remainingMen[1], remainingMen[2]],
    "Mixed Gender",
    "3M+1W completion"
  );
  if (match) { matches.push(match); matchCreated = true; }
}
else if (!matchCreated && remainingWomen.length === 3 && remainingMen.length === 1) {
  const match = createMatch(
    [remainingMen[0], remainingWomen[0]],
    [remainingWomen[1], remainingWomen[2]],
    "Mixed Gender",
    "1M+3W completion"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== Cross-grade Mixed Doubles (after same-sex options, if permitted)
else if (!matchCreated && remainingMen.length >= 2 && lowerWomen.length >= 2) {
  const match = createMatch(
    [remainingMen[0], lowerWomen[0]],
    [remainingMen[1], lowerWomen[1]],
    "Mixed Doubles",
    "Cross-grade mixed completion"
  );
  if (match) { matches.push(match); matchCreated = true; }
}
else if (!matchCreated && remainingWomen.length >= 2 && lowerMen.length >= 2) {
  const match = createMatch(
    [lowerMen[0], remainingWomen[0]],
    [lowerMen[1], remainingWomen[1]],
    "Mixed Doubles",
    "Cross-grade mixed completion"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== 1+3 SAME-SEX (MEN) — last resort for a single leftover
else if (!matchCreated && remainingMen.length >= 1 && lowerMen.length >= 3) {
  const match = createMatch(
    [remainingMen[0], lowerMen[0]],
    [lowerMen[1], lowerMen[2]],
    "Same-Sex Doubles (Men)",
    "Cross-grade 1+3 fallback (last resort)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== 1+3 SAME-SEX (WOMEN) — last resort
else if (!matchCreated && remainingWomen.length >= 1 && lowerWomen.length >= 3) {
  const match = createMatch(
    [remainingWomen[0], lowerWomen[0]],
    [lowerWomen[1], lowerWomen[2]],
    "Same-Sex Doubles (Women)",
    "Cross-grade 1+3 fallback (last resort)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

      
      if (!matchCreated) {
        log("Cannot complete Grade " + targetGrade + " - remaining: " + 
            remainingMen.length + "M + " + remainingWomen.length + "F");
        break;
      }
    }
  }

  log("=== FINAL CLEANUP PHASE ===");
  let cleanupAttempts = 0;
  while (cleanupAttempts < 20) {
    cleanupAttempts++;
    
    const allUnassignedMen = data.sortedMen.filter(p => !assigned.has(p.name));
    const allUnassignedWomen = data.sortedWomen.filter(p => !assigned.has(p.name));
    
    if (allUnassignedMen.length === 0 && allUnassignedWomen.length === 0) {
      log("✓ CLEANUP SUCCESS: All players assigned");
      break;
    }
    
    log("Cleanup attempt " + cleanupAttempts + ": " + allUnassignedMen.length + "M + " + allUnassignedWomen.length + "W remaining");
    
    let cleanupMatchCreated = false;
    
    if (allUnassignedMen.length >= 4) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedMen[1]],
        [allUnassignedMen[2], allUnassignedMen[3]],
        "Same-Sex Doubles (Men)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length >= 4) {
      const match = createMatch(
        [allUnassignedWomen[0], allUnassignedWomen[1]],
        [allUnassignedWomen[2], allUnassignedWomen[3]],
        "Same-Sex Doubles (Women)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length >= 2 && allUnassignedWomen.length >= 2) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedWomen[1]],
        "Mixed Doubles",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length === 3 && allUnassignedWomen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedMen[2]],
        "Mixed Gender",
        "Final cleanup 3M+1W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length === 3 && allUnassignedMen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedWomen[1], allUnassignedWomen[2]],
        "Mixed Gender",
        "Final cleanup 1M+3W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    
    if (!cleanupMatchCreated) {
      log("❌ CLEANUP FAILED: Cannot form matches from remaining players");
      break;
    }
  }

  log("=== FINAL STATUS ===");
  log("Total matches created: " + matches.length);
  return matches;
}

function balanceTeamsIfNeeded(match) {
  // Only balance same-sex matches (the problematic ones)
  if (match.format !== "Same-Sex Doubles (Men)" && match.format !== "Same-Sex Doubles (Women)") {
    return match;
  }
  
  const team1Grades = match.team1.map(p => p.grade);
  const team2Grades = match.team2.map(p => p.grade);
  
  // Check for "2 strong vs 2 weak" pattern (grades 4-5 vs grades 1-3)
  const team1Strong = team1Grades.filter(g => g >= 4).length;
  const team2Strong = team2Grades.filter(g => g >= 4).length;
  
  // If one team has 2 strong and other has 0 strong, swap one player
  if (team1Strong === 2 && team2Strong === 0) {
    // Swap the weaker player from team1 with stronger player from team2
    const weakerInTeam1 = team1Grades[0] < team1Grades[1] ? 0 : 1;
    const strongerInTeam2 = team2Grades[0] > team2Grades[1] ? 0 : 1;
    
    const tempPlayer = match.team1[weakerInTeam1];
    match.team1[weakerInTeam1] = match.team2[strongerInTeam2];
    match.team2[strongerInTeam2] = tempPlayer;
    
    log("⚖️ Balanced teams: Swapped " + tempPlayer.name + " ↔ " + match.team1[weakerInTeam1].name);
  }
  else if (team1Strong === 0 && team2Strong === 2) {
    // Swap the weaker player from team2 with stronger player from team1
    const weakerInTeam2 = team2Grades[0] < team2Grades[1] ? 0 : 1;
    const strongerInTeam1 = team1Grades[0] > team1Grades[1] ? 0 : 1;
    
    const tempPlayer = match.team2[weakerInTeam2];
    match.team2[weakerInTeam2] = match.team1[strongerInTeam1];
    match.team1[strongerInTeam1] = tempPlayer;
    
    log("⚖️ Balanced teams: Swapped " + tempPlayer.name + " ↔ " + match.team2[weakerInTeam2].name);
  }
  
  return match;
}

function processCourtPreferences(data, matches) {
  log("=== COURT PREFERENCES ===");
  
  const isHardCourt = (court) => court && court.toString().toUpperCase().startsWith('H');
  const isGrassCourt = (court) => {
    const courtStr = court && court.toString().toUpperCase();
    return courtStr && (courtStr.startsWith('G') || (!courtStr.startsWith('H') && /^\d+$/.test(courtStr)));
  };
  
 const hasNHCPlayer = (match) => {
  const allPlayers = [...match.team1, ...match.team2];
  return allPlayers.some(player => {
    const menPlayer = data.sortedMen ? data.sortedMen.find(p => p.name === player.name) : null;
    const womenPlayer = data.sortedWomen ? data.sortedWomen.find(p => p.name === player.name) : null;
    
    // If not found in sorted arrays, check available arrays
    const menPlayerAvailable = !menPlayer && data.availableMen ? data.availableMen.find(p => p.name === player.name) : null;
    const womenPlayerAvailable = !womenPlayer && data.availableWomen ? data.availableWomen.find(p => p.name === player.name) : null;
    
    const foundPlayer = menPlayer || womenPlayer || menPlayerAvailable || womenPlayerAvailable;
    return foundPlayer && foundPlayer.nhc;
  });
};
  
  const nhcOnHard = [];
  const nonNhcOnGrass = [];
  
  matches.forEach((match, index) => {
    if (isHardCourt(match.court) && hasNHCPlayer(match)) {
      nhcOnHard.push({index, match});
    } else if (isGrassCourt(match.court) && !hasNHCPlayer(match)) {
      nonNhcOnGrass.push({index, match});
    }
  });
  
  const swaps = Math.min(nhcOnHard.length, nonNhcOnGrass.length);
  for (let i = 0; i < swaps; i++) {
    const tempCourt = nhcOnHard[i].match.court;
    matches[nhcOnHard[i].index].court = nonNhcOnGrass[i].match.court;
    matches[nonNhcOnGrass[i].index].court = tempCourt;
    log("Court swap: " + tempCourt + " ↔ " + nonNhcOnGrass[i].match.court);
  }
  
  return matches;
}

function checkForRepeatPartnerships(currentSetNumber, currentMatches) {
  if (currentSetNumber <= 1) return [];
  
  const repeatPartners = [];
  
  // Get all partnerships from current set
  const currentPartnerships = [];
  currentMatches.forEach((match, matchIndex) => {
    // Team 1 partnership
    if (match.team1.length === 2) {
      currentPartnerships.push({
        matchIndex: matchIndex,
        team: 1,
        players: [match.team1[0].name, match.team1[1].name].sort()
      });
    }
    // Team 2 partnership
    if (match.team2.length === 2) {
      currentPartnerships.push({
        matchIndex: matchIndex,
        team: 2,
        players: [match.team2[0].name, match.team2[1].name].sort()
      });
    }
  });
  
  // Check against all previous sets
  for (let setNum = 1; setNum < currentSetNumber; setNum++) {
    if (!allSetsData[setNum] || !allSetsData[setNum].matches) continue;
    
    const previousMatches = allSetsData[setNum].matches;
    const previousPartnerships = [];
    
    previousMatches.forEach(match => {
      if (match.team1.length === 2) {
        previousPartnerships.push([match.team1[0].name, match.team1[1].name].sort());
      }
      if (match.team2.length === 2) {
        previousPartnerships.push([match.team2[0].name, match.team2[1].name].sort());
      }
    });
    
    // Compare current partnerships with previous ones
    currentPartnerships.forEach(current => {
      previousPartnerships.forEach(previous => {
        if (current.players[0] === previous[0] && current.players[1] === previous[1]) {
          repeatPartners.push({
            matchIndex: current.matchIndex,
            team: current.team,
            players: current.players,
            previousSet: setNum
          });
          log("Repeat partnership found: " + current.players.join(" & ") + " (previously in Set " + setNum + ")");
        }
      });
    });
  }
  
  return repeatPartners;
}

function checkForRepeatOpponents(currentSetNumber, currentMatches) {
  if (currentSetNumber <= 1) return [];
  
  const repeatOpponents = [];
  
  // Get previous set data
  const previousSetData = allSetsData[currentSetNumber - 1];
  if (!previousSetData || !previousSetData.matches) return [];
  
  const previousMatches = previousSetData.matches;
  
  // For each current match, check if any players were opponents in previous set
  currentMatches.forEach((currentMatch, currentMatchIndex) => {
    const currentPlayers = [...currentMatch.team1, ...currentMatch.team2];
    
    // Check each pair of players in current match (they are opponents)
    for (let i = 0; i < currentPlayers.length; i++) {
      for (let j = i + 1; j < currentPlayers.length; j++) {
        const player1 = currentPlayers[i];
        const player2 = currentPlayers[j];
        
        // Skip if they're on the same team (partners, not opponents)
        const player1Team = currentMatch.team1.some(p => p.name === player1.name) ? 1 : 2;
        const player2Team = currentMatch.team1.some(p => p.name === player2.name) ? 1 : 2;
        if (player1Team === player2Team) continue;
        
        // Check if these two were opponents in previous set
        previousMatches.forEach(previousMatch => {
          const prevPlayer1Team = previousMatch.team1.some(p => p.name === player1.name) ? 1 : 
                                 previousMatch.team2.some(p => p.name === player1.name) ? 2 : 0;
          const prevPlayer2Team = previousMatch.team1.some(p => p.name === player2.name) ? 1 : 
                                 previousMatch.team2.some(p => p.name === player2.name) ? 2 : 0;
          
          // If both players were in previous match and on different teams (opponents)
          if (prevPlayer1Team !== 0 && prevPlayer2Team !== 0 && prevPlayer1Team !== prevPlayer2Team) {
            repeatOpponents.push({
              matchIndex: currentMatchIndex,
              player1: player1.name,
              player2: player2.name
            });
            log("Repeat opponents found: " + player1.name + " vs " + player2.name + " (previously opponents in Set " + (currentSetNumber - 1) + ")");
          }
        });
      }
    }
  });
  
  return repeatOpponents;
}

function autoFixRepeatPartnerships(data, matches) {
  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  if (currentSetNum <= 1) return matches;
  
  log("=== AUTO-FIXING REPEAT PARTNERSHIPS ===");
  
  // Create a working copy of matches
  const workingMatches = JSON.parse(JSON.stringify(matches));
  
  // Get repeat partnerships
  const repeatPartners = checkForRepeatPartnerships(currentSetNum, workingMatches);
  
  if (repeatPartners.length === 0) {
    log("No repeat partnerships found - no auto-fixes needed");
    return workingMatches;
  }
  
log("Found " + repeatPartners.length + " repeat partnerships to attempt fixing");

// Check if we should skip Phase 2 due to too many repeat partnerships
const repeatLimit = 20;
log("Repeat partnership limit set to: " + repeatLimit);
if (repeatPartners.length > repeatLimit) {
  log("=== REPEAT PARTNERSHIP THRESHOLD EXCEEDED ===");
  log("Found " + repeatPartners.length + " repeat partnerships (>" + repeatLimit + ")");
  log("Skipping Phase 2 inter-match fixes to prevent memory issues");
  log("Phase 1 intra-match fixes will still be attempted");
  log("Remaining repeat partnerships must be resolved manually by operator");
}

// PHASE 1: Try simple intra-match swaps first
log("=== PHASE 1: INTRA-MATCH FIXES ===");
  
repeatPartners.forEach((repeat, repeatIndex) => {
  const matchIndex = repeat.matchIndex;
  const teamNum = parseInt(repeat.team);
  const match = workingMatches[matchIndex];
  const currentTeam = teamNum === 1 ? match.team1 : match.team2;
  const opposingTeam = teamNum === 1 ? match.team2 : match.team1;
  
  log("Attempting intra-match fix for: " + repeat.players.join(" & ") + " (Match " + matchIndex + ", Team " + teamNum + ")");
  
  let fixedInMatch = false;
  
  // Handle Same-Sex matches (original logic)
  if (match.format.includes("Same-Sex")) {
    const beforeCount = checkForRepeatPartnerships(currentSetNum, workingMatches).length;
    
    // Try swapping each player in the problematic team with each player in opposing team
    for (let currentPlayerIndex = 0; currentPlayerIndex < currentTeam.length && !fixedInMatch; currentPlayerIndex++) {
      for (let opponentIndex = 0; opponentIndex < opposingTeam.length && !fixedInMatch; opponentIndex++) {
        
        const currentPlayer = currentTeam[currentPlayerIndex];
        const opponentPlayer = opposingTeam[opponentIndex];
        
        // For same-sex matches, players should be same gender, so swap should be safe
        if (getPlayerGender(currentPlayer.name, data) !== getPlayerGender(opponentPlayer.name, data)) {
          continue; // Skip if different genders (shouldn't happen in same-sex match)
        }
        
        // Create a test copy to check the effect of the swap
        const testMatches = JSON.parse(JSON.stringify(workingMatches));
        const testMatch = testMatches[matchIndex];
        const testCurrentTeam = teamNum === 1 ? testMatch.team1 : testMatch.team2;
        const testOpposingTeam = teamNum === 1 ? testMatch.team2 : testMatch.team1;
        
        // Perform the test swap on the copy
        const tempPlayer = testCurrentTeam[currentPlayerIndex];
        testCurrentTeam[currentPlayerIndex] = testOpposingTeam[opponentIndex];
        testOpposingTeam[opponentIndex] = tempPlayer;
        
        const afterCount = checkForRepeatPartnerships(currentSetNum, testMatches).length;
        
        if (afterCount < beforeCount) {
          // Success! Apply the swap to the real working matches
          currentTeam[currentPlayerIndex] = opponentPlayer;
          opposingTeam[opponentIndex] = currentPlayer;
          
          log("✅ Intra-match fix (Same-Sex): Swapped " + currentPlayer.name + " ↔ " + opponentPlayer.name);
          log("  Repeat partnerships reduced from " + beforeCount + " to " + afterCount);
          fixedInMatch = true;
          break;
        }
        // No need to revert since we only tested on a copy
      }
    }
  }
  
  // NEW: Handle Mixed Doubles matches
  else if (match.format === "Mixed Doubles") {
    const beforeCount = checkForRepeatPartnerships(currentSetNum, workingMatches).length;
    
    // In Mixed Doubles, we can swap the two men or the two women within the match
    // Get all players from both teams
    const allPlayers = [...match.team1, ...match.team2];
    const menInMatch = allPlayers.filter(p => getPlayerGender(p.name, data) === 'M');
    const womenInMatch = allPlayers.filter(p => getPlayerGender(p.name, data) === 'F');
    
    // Try swapping the two men
    if (menInMatch.length === 2 && !fixedInMatch) {
      // Create a test copy to check the effect of the swap
      const testMatches = JSON.parse(JSON.stringify(workingMatches));
      const testMatch = testMatches[matchIndex];
      
      // Find positions of the two men in the test match
      let man1Team = null, man1Index = null, man2Team = null, man2Index = null;
      
      // Check team 1
      testMatch.team1.forEach((player, index) => {
        if (player.name === menInMatch[0].name) { man1Team = testMatch.team1; man1Index = index; }
        if (player.name === menInMatch[1].name) { man2Team = testMatch.team1; man2Index = index; }
      });
      
      // Check team 2
      testMatch.team2.forEach((player, index) => {
        if (player.name === menInMatch[0].name) { man1Team = testMatch.team2; man1Index = index; }
        if (player.name === menInMatch[1].name) { man2Team = testMatch.team2; man2Index = index; }
      });
      
      // Perform the swap
      if (man1Team && man2Team && man1Index !== null && man2Index !== null) {
        const tempPlayer = man1Team[man1Index];
        man1Team[man1Index] = man2Team[man2Index];
        man2Team[man2Index] = tempPlayer;
        
        const afterCount = checkForRepeatPartnerships(currentSetNum, testMatches).length;
        
        if (afterCount < beforeCount) {
          // Success! Apply the swap to the real working matches
          // Find the same positions in the real match
          let realMan1Team = null, realMan1Index = null, realMan2Team = null, realMan2Index = null;
          
          // Check team 1
          match.team1.forEach((player, index) => {
            if (player.name === menInMatch[0].name) { realMan1Team = match.team1; realMan1Index = index; }
            if (player.name === menInMatch[1].name) { realMan2Team = match.team1; realMan2Index = index; }
          });
          
          // Check team 2
          match.team2.forEach((player, index) => {
            if (player.name === menInMatch[0].name) { realMan1Team = match.team2; realMan1Index = index; }
            if (player.name === menInMatch[1].name) { realMan2Team = match.team2; realMan2Index = index; }
          });
          
          // Apply the swap
          const realTempPlayer = realMan1Team[realMan1Index];
          realMan1Team[realMan1Index] = realMan2Team[realMan2Index];
          realMan2Team[realMan2Index] = realTempPlayer;
          
          log("✅ Intra-match fix (Mixed Doubles - Men): Swapped " + menInMatch[0].name + " ↔ " + menInMatch[1].name);
          log("  Repeat partnerships reduced from " + beforeCount + " to " + afterCount);
          fixedInMatch = true;
        }
      }
    }
    
    // Try swapping the two women (if men swap didn't work)
    if (womenInMatch.length === 2 && !fixedInMatch) {
      // Create a test copy to check the effect of the swap
      const testMatches = JSON.parse(JSON.stringify(workingMatches));
      const testMatch = testMatches[matchIndex];
      
      // Find positions of the two women in the test match
      let woman1Team = null, woman1Index = null, woman2Team = null, woman2Index = null;
      
      // Check team 1
      testMatch.team1.forEach((player, index) => {
        if (player.name === womenInMatch[0].name) { woman1Team = testMatch.team1; woman1Index = index; }
        if (player.name === womenInMatch[1].name) { woman2Team = testMatch.team1; woman2Index = index; }
      });
      
      // Check team 2
      testMatch.team2.forEach((player, index) => {
        if (player.name === womenInMatch[0].name) { woman1Team = testMatch.team2; woman1Index = index; }
        if (player.name === womenInMatch[1].name) { woman2Team = testMatch.team2; woman2Index = index; }
      });
      
      // Perform the swap
      if (woman1Team && woman2Team && woman1Index !== null && woman2Index !== null) {
        const tempPlayer = woman1Team[woman1Index];
        woman1Team[woman1Index] = woman2Team[woman2Index];
        woman2Team[woman2Index] = tempPlayer;
        
        const afterCount = checkForRepeatPartnerships(currentSetNum, testMatches).length;
        
        if (afterCount < beforeCount) {
          // Success! Apply the swap to the real working matches
          // Find the same positions in the real match
          let realWoman1Team = null, realWoman1Index = null, realWoman2Team = null, realWoman2Index = null;
          
          // Check team 1
          match.team1.forEach((player, index) => {
            if (player.name === womenInMatch[0].name) { realWoman1Team = match.team1; realWoman1Index = index; }
            if (player.name === womenInMatch[1].name) { realWoman2Team = match.team1; realWoman2Index = index; }
          });
          
          // Check team 2
          match.team2.forEach((player, index) => {
            if (player.name === womenInMatch[0].name) { realWoman1Team = match.team2; realWoman1Index = index; }
            if (player.name === womenInMatch[1].name) { realWoman2Team = match.team2; realWoman2Index = index; }
          });
          
          // Apply the swap
          const realTempPlayer = realWoman1Team[realWoman1Index];
          realWoman1Team[realWoman1Index] = realWoman2Team[realWoman2Index];
          realWoman2Team[realWoman2Index] = realTempPlayer;
          
          log("✅ Intra-match fix (Mixed Doubles - Women): Swapped " + womenInMatch[0].name + " ↔ " + womenInMatch[1].name);
          log("  Repeat partnerships reduced from " + beforeCount + " to " + afterCount);
          fixedInMatch = true;
        }
      }
    }
  }
  
  if (!fixedInMatch) {
    log("❌ Could not fix intra-match: " + repeat.players.join(" & "));
  }
});
  
  // Check if Phase 1 solved everything
  const remainingRepeats = checkForRepeatPartnerships(currentSetNum, workingMatches);
  if (remainingRepeats.length === 0) {
    log("🎉 Phase 1 resolved all repeat partnerships!");
    return workingMatches;
  }
  
 // PHASE 2: Complex inter-match swaps (original logic)
if (repeatPartners.length <= repeatLimit) {
  log("=== PHASE 2: INTER-MATCH FIXES ===");
  log("Remaining repeats after Phase 1: " + remainingRepeats.length);
  
  // Get set format preference for prioritizing swap types
  const setFormatPreference = data.setFormatPreference;
  
  // Process remaining repeat partnerships with original complex logic
  remainingRepeats.forEach((repeat, repeatIndex) => {
    const matchIndex = repeat.matchIndex;
    const teamNum = parseInt(repeat.team);
    const match = workingMatches[matchIndex];
    const currentTeam = teamNum === 1 ? match.team1 : match.team2;
    const opposingTeam = teamNum === 1 ? match.team2 : match.team1;
    
    log("Attempting inter-match fix for: " + repeat.players.join(" & ") + " (Match " + matchIndex + ", Team " + teamNum + ")");
    
    let fixedInMatch = false;
    
    // Define swap priority based on set format preference
    const swapStrategies = [];
    
    if (setFormatPreference === "Same-Sex") {
      swapStrategies.push(
        { name: "Same grade, same gender", criteria: (p1, p2) => p1.grade === p2.grade && getPlayerGender(p1.name, data) === getPlayerGender(p2.name, data) },
        { name: "Adjacent grade, same gender", criteria: (p1, p2) => Math.abs(p1.grade - p2.grade) === 1 && getPlayerGender(p1.name, data) === getPlayerGender(p2.name, data) },
        { name: "Same grade, cross gender", criteria: (p1, p2) => p1.grade === p2.grade && getPlayerGender(p1.name, data) !== getPlayerGender(p2.name, data) }
      );
    } else { // Mixed format preference
      swapStrategies.push(
        { name: "Same grade, cross gender", criteria: (p1, p2) => p1.grade === p2.grade && getPlayerGender(p1.name, data) !== getPlayerGender(p2.name, data) },
        { name: "Adjacent grade, cross gender", criteria: (p1, p2) => Math.abs(p1.grade - p2.grade) === 1 && getPlayerGender(p1.name, data) !== getPlayerGender(p2.name, data) },
        { name: "Same grade, same gender", criteria: (p1, p2) => p1.grade === p2.grade && getPlayerGender(p1.name, data) === getPlayerGender(p2.name, data) }
      );
    }
    
    // Try swaps with other matches
    for (let strategy of swapStrategies) {
      if (fixedInMatch) break;
      
      log("  Trying inter-match strategy: " + strategy.name);
      
      for (let otherMatchIndex = 0; otherMatchIndex < workingMatches.length && !fixedInMatch; otherMatchIndex++) {
        if (otherMatchIndex === matchIndex) continue;
        
        const otherMatch = workingMatches[otherMatchIndex];
        
        // Try swapping with players from both teams of other matches
        for (let otherTeamNum = 1; otherTeamNum <= 2 && !fixedInMatch; otherTeamNum++) {
          const otherTeam = otherTeamNum === 1 ? otherMatch.team1 : otherMatch.team2;
          
          // Try swapping each player from current team with each player from other team
          for (let currentPlayerIndex = 0; currentPlayerIndex < currentTeam.length && !fixedInMatch; currentPlayerIndex++) {
            for (let otherPlayerIndex = 0; otherPlayerIndex < otherTeam.length && !fixedInMatch; otherPlayerIndex++) {
              
              const currentPlayer = currentTeam[currentPlayerIndex];
              const otherPlayer = otherTeam[otherPlayerIndex];
              
              // Check if this swap meets the current strategy criteria
              if (!strategy.criteria(currentPlayer, otherPlayer)) continue;
              
              // For adjacent grade swaps, ensure balanced teams in both matches
              if (strategy.name.includes("Adjacent grade")) {
                if (!wouldCreateBalancedTeams(workingMatches, matchIndex, currentPlayerIndex, teamNum, otherPlayerIndex, otherTeamNum, otherMatchIndex)) {
                  continue;
                }
              }
              
              // Test the swap
              const beforeCount = checkForRepeatPartnerships(currentSetNum, workingMatches).length;
              
              // Perform the test swap
              currentTeam[currentPlayerIndex] = otherPlayer;
              otherTeam[otherPlayerIndex] = currentPlayer;
              
              const afterCount = checkForRepeatPartnerships(currentSetNum, workingMatches).length;
              
              if (afterCount < beforeCount) {
                // Success! The swap reduced conflicts
                log("✓ Inter-match fix (" + strategy.name + "): Swapped " + currentPlayer.name + " ↔ " + otherPlayer.name);
                log("  Repeat partnerships reduced from " + beforeCount + " to " + afterCount);
                fixedInMatch = true;
                break;
              } else {
                // Revert the swap - it didn't help
                currentTeam[currentPlayerIndex] = currentPlayer;
                otherTeam[otherPlayerIndex] = otherPlayer;
              }
            }
          }
        }
      }
    }
    
    if (!fixedInMatch) {
      log("❌ Could not auto-fix: " + repeat.players.join(" & ") + " - leaving for manual adjustment");
    }
  });
  
 const finalRepeats = checkForRepeatPartnerships(currentSetNum, workingMatches);
  if (finalRepeats.length > 0) {
    log("⚠ Could not resolve all repeat partnerships. Remaining: " + finalRepeats.length);
    finalRepeats.forEach(rp => {
      log("  - " + rp.players.join(" & ") + " (previously in Set " + rp.previousSet + ")");
    });
  } else {
    log("🎉 Successfully resolved all repeat partnerships!");
  }
} else {
  log("=== PHASE 2 SKIPPED DUE TO THRESHOLD ===");
  log("Phase 1 intra-match fixes completed only");
  log("Operator must manually resolve remaining repeat partnerships");
}

return workingMatches;
}

function autoFixRepeatOpponents(data, matches) {
  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  if (currentSetNum <= 1) return matches;
  
  log("=== AUTO-FIXING REPEAT OPPONENTS ===");
  
  // Create a working copy of matches
  const workingMatches = JSON.parse(JSON.stringify(matches));
  
  // Get repeat opponents
  const repeatOpponents = checkForRepeatOpponents(currentSetNum, workingMatches);
  
  if (repeatOpponents.length === 0) {
    log("No repeat opponents found - no auto-fixes needed");
    return workingMatches;
  }
  
  log("Found " + repeatOpponents.length + " repeat opponent instances to attempt fixing");
  
  // Process each repeat opponent instance
  repeatOpponents.forEach((repeat, repeatIndex) => {
    log(`\n--- Attempting to fix repeat opponent: ${repeat.player1} vs ${repeat.player2} (Match ${repeat.matchIndex}) ---`);
    
    let fixedOpponent = false;
    let attemptCount = 0;
    
    // Try up to 5 swap attempts for this repeat opponent instance
    for (let attempt = 1; attempt <= 5 && !fixedOpponent; attempt++) {
      attemptCount++;
      log(`  Attempt ${attempt} for ${repeat.player1} vs ${repeat.player2}`);
      
      // For each of the two players in the repeat opponent pair
      const playersToTry = [repeat.player1, repeat.player2];
      
      for (let playerToSwap of playersToTry) {
        if (fixedOpponent) break;
        
        // Find this player's current position in workingMatches
        let playerMatchIndex = null;
        let playerTeamNum = null;
        let playerPositionIndex = null;
        
        // Search for the player in all matches
        for (let matchIdx = 0; matchIdx < workingMatches.length; matchIdx++) {
          const match = workingMatches[matchIdx];
          
          // Check team 1
          for (let pos = 0; pos < match.team1.length; pos++) {
            if (match.team1[pos].name === playerToSwap) {
              playerMatchIndex = matchIdx;
              playerTeamNum = 1;
              playerPositionIndex = pos;
              break;
            }
          }
          
          // Check team 2 if not found in team 1
          if (playerMatchIndex === null) {
            for (let pos = 0; pos < match.team2.length; pos++) {
              if (match.team2[pos].name === playerToSwap) {
                playerMatchIndex = matchIdx;
                playerTeamNum = 2;
                playerPositionIndex = pos;
                break;
              }
            }
          }
          
          if (playerMatchIndex !== null) break;
        }
        
        if (playerMatchIndex === null) {
          log(`    ❌ Could not find player ${playerToSwap} in any match`);
          continue;
        }
        
        const currentMatch = workingMatches[playerMatchIndex];
        const currentTeam = playerTeamNum === 1 ? currentMatch.team1 : currentMatch.team2;
        const currentPlayer = currentTeam[playerPositionIndex];
        const currentPlayerGender = getPlayerGender(currentPlayer.name, data);
        const currentPlayerGrade = currentPlayer.grade;
        
        // Look for swap candidates in other matches
        for (let otherMatchIndex = 0; otherMatchIndex < workingMatches.length && !fixedOpponent; otherMatchIndex++) {
          if (otherMatchIndex === playerMatchIndex) continue;
          
          const otherMatch = workingMatches[otherMatchIndex];
          
          // Check both teams in the other match
          for (let otherTeamNum = 1; otherTeamNum <= 2 && !fixedOpponent; otherTeamNum++) {
            const otherTeam = otherTeamNum === 1 ? otherMatch.team1 : otherMatch.team2;
            
            for (let otherPlayerIndex = 0; otherPlayerIndex < otherTeam.length && !fixedOpponent; otherPlayerIndex++) {
              const otherPlayer = otherTeam[otherPlayerIndex];
              const otherPlayerGender = getPlayerGender(otherPlayer.name, data);
              const otherPlayerGrade = otherPlayer.grade;
              
              // Check if this is a valid swap candidate (same gender and grade)
              if (currentPlayerGender !== otherPlayerGender || currentPlayerGrade !== otherPlayerGrade) {
                continue;
              }
              
              log(`    Testing swap: ${currentPlayer.name} ↔ ${otherPlayer.name} (both ${currentPlayerGender}, grade ${currentPlayerGrade})`);
              
              // Store the exact positions and player data for the swap
              const swapData = {
                player1: {
                  matchIndex: playerMatchIndex,
                  teamNum: playerTeamNum,
                  positionIndex: playerPositionIndex,
                  playerData: JSON.parse(JSON.stringify(currentPlayer))
                },
                player2: {
                  matchIndex: otherMatchIndex,
                  teamNum: otherTeamNum,
                  positionIndex: otherPlayerIndex,
                  playerData: JSON.parse(JSON.stringify(otherPlayer))
                }
              };
              
              // Create test matches to check the effect of the swap
              const testMatches = JSON.parse(JSON.stringify(workingMatches));
              
              // Apply test swap using exact positions
              const testMatch1 = testMatches[swapData.player1.matchIndex];
              const testMatch2 = testMatches[swapData.player2.matchIndex];
              const testTeam1 = swapData.player1.teamNum === 1 ? testMatch1.team1 : testMatch1.team2;
              const testTeam2 = swapData.player2.teamNum === 1 ? testMatch2.team1 : testMatch2.team2;
              
              // Perform the actual swap in test
              testTeam1[swapData.player1.positionIndex] = swapData.player2.playerData;
              testTeam2[swapData.player2.positionIndex] = swapData.player1.playerData;
              
              // Check if this swap creates any new repeat partnerships
              const repeatPartnersAfter = checkForRepeatPartnerships(currentSetNum, testMatches);
              const repeatPartnersBefore = checkForRepeatPartnerships(currentSetNum, workingMatches);
              
              if (repeatPartnersAfter.length > repeatPartnersBefore.length) {
                log(`      ❌ Swap would create new repeat partnerships - rejected`);
                continue;
              }
              
              // Check if this swap reduces repeat opponents
              const repeatOpponentsAfter = checkForRepeatOpponents(currentSetNum, testMatches);
              const repeatOpponentsBefore = checkForRepeatOpponents(currentSetNum, workingMatches);
              
              if (repeatOpponentsAfter.length < repeatOpponentsBefore.length) {
                // Success! Apply the swap to workingMatches using exact same approach
                const realMatch1 = workingMatches[swapData.player1.matchIndex];
                const realMatch2 = workingMatches[swapData.player2.matchIndex];
                const realTeam1 = swapData.player1.teamNum === 1 ? realMatch1.team1 : realMatch1.team2;
                const realTeam2 = swapData.player2.teamNum === 1 ? realMatch2.team1 : realMatch2.team2;
                
                // Perform the exact same swap
                realTeam1[swapData.player1.positionIndex] = swapData.player2.playerData;
                realTeam2[swapData.player2.positionIndex] = swapData.player1.playerData;
                
                log(`      ✅ Successful swap: ${swapData.player1.playerData.name} ↔ ${swapData.player2.playerData.name}`);
                log(`      Repeat opponents reduced from ${repeatOpponentsBefore.length} to ${repeatOpponentsAfter.length}`);
                fixedOpponent = true;
                break;
              } else {
                log(`      ❌ Swap did not reduce repeat opponents`);
              }
            }
          }
        }
      }
    }
    
    if (!fixedOpponent) {
      log(`  ❌ Could not fix repeat opponent after ${attemptCount} attempts: ${repeat.player1} vs ${repeat.player2}`);
    }
  });
  
  const finalRepeatOpponents = checkForRepeatOpponents(currentSetNum, workingMatches);
  if (finalRepeatOpponents.length > 0) {
    log(`⚠️ Could not resolve all repeat opponents. Remaining: ${finalRepeatOpponents.length}`);
  } else {
    log("🎉 Successfully resolved all repeat opponents!");
  }
  
  return workingMatches;
}

function wouldCreateBalancedTeams(matches, match1Index, player1Index, team1Num, player2Index, team2Num, match2Index = null) {
  // If match2Index is null, we're swapping within the same match
  const match2Index_actual = match2Index !== null ? match2Index : match1Index;
  
  const match1 = matches[match1Index];
  const match2 = matches[match2Index_actual];
  
  const team1 = team1Num === 1 ? match1.team1 : match1.team2;
  const team2 = team2Num === 1 ? match2.team1 : match2.team2;
  
  const player1 = team1[player1Index];
  const player2 = team2[player2Index];
  
  // If swapping within same match, be more permissive (usually safe)
  if (match2Index === null) {
    return true;
  }
  
  // For inter-match swaps, check what the final team compositions would be
  const team1OtherPlayer = team1[1 - player1Index]; // The other player in team1
  const team2OtherPlayer = team2[1 - player2Index]; // The other player in team2
  
  // Calculate what the teams would look like after the swap
  const newTeam1 = [team1OtherPlayer, player2];
  const newTeam2 = [team2OtherPlayer, player1];
  
  // Get the opposing teams in each match
  const match1OpposingTeam = team1Num === 1 ? match1.team2 : match1.team1;
  const match2OpposingTeam = team2Num === 1 ? match2.team2 : match2.team1;
  
  // Check if both final matches would be balanced
  const match1Balanced = isMatchupBalanced(newTeam1, match1OpposingTeam);
  const match2Balanced = isMatchupBalanced(newTeam2, match2OpposingTeam);
  
  return match1Balanced && match2Balanced;
}

function fixUncompetitiveMatches(data, matches) {
  log("=== FINAL COMPETITIVENESS OPTIMIZATION ===");
  
  // Step 1: Identify uncompetitive matches
  const uncompetitiveMatches = [];
  matches.forEach((match, index) => {
    if (isUncompetitive(match)) {
      uncompetitiveMatches.push({index, match});
    }
  });
  
  log(`Found ${uncompetitiveMatches.length} uncompetitive matches`);
  
  if (uncompetitiveMatches.length <= 1) {
    log("≤1 uncompetitive match found - leaving for operator to handle");
    return matches;
  }
  
  // Step 2: Process pairs of uncompetitive matches
  const pairsToProcess = Math.floor(uncompetitiveMatches.length / 2);
  log(`Processing ${pairsToProcess} pairs of uncompetitive matches`);
  
  for (let pairIndex = 0; pairIndex < pairsToProcess; pairIndex++) {
    const matchA = uncompetitiveMatches[pairIndex * 2];
    const matchB = uncompetitiveMatches[pairIndex * 2 + 1];
    
    log(`\n--- Processing pair ${pairIndex + 1}: Match ${matchA.index} & Match ${matchB.index} ---`);
    
    // Try the swap
    if (attemptCompetitivenessSwap(data, matches, matchA.index, matchB.index)) {
      log(`✓ Successful competitiveness swap between matches ${matchA.index} & ${matchB.index}`);
    } else {
      log(`❌ No beneficial swap found between matches ${matchA.index} & ${matchB.index}`);
    }
  }
  
  // Report final status
  const finalUncompetitive = matches.filter(match => isUncompetitive(match)).length;
  log(`\n=== COMPETITIVENESS OPTIMIZATION COMPLETE ===`);
  log(`Uncompetitive matches reduced from ${uncompetitiveMatches.length} to ${finalUncompetitive}`);
  
  return matches;
}

function balanceIndividualMatches(data, matches) {
  log("=== FINAL INDIVIDUAL MATCH BALANCING ===");
  
  let totalImprovedMatches = 0;
  
  matches.forEach((match, matchIndex) => {
    // Check if match needs balancing (≥2 point gap)
    const team1Total = match.team1.reduce((sum, p) => sum + p.grade, 0);
    const team2Total = match.team2.reduce((sum, p) => sum + p.grade, 0);
    const currentGap = Math.abs(team1Total - team2Total);
    
    if (currentGap < 2) return; // Skip well-balanced matches
    
    log(`Match ${matchIndex} needs balancing: ${team1Total} vs ${team2Total} (gap=${currentGap})`);
    
    // Test all 3 possible swaps
    let bestSwap = null;
    let bestGap = currentGap;
    
    for (let t1Player = 0; t1Player < 2; t1Player++) {
      for (let t2Player = 0; t2Player < 2; t2Player++) {
        if (t1Player === 1 && t2Player === 1) continue; // Skip redundant swap
        
        // Test this swap
        const testMatch = JSON.parse(JSON.stringify(match));
        const tempPlayer = testMatch.team1[t1Player];
        testMatch.team1[t1Player] = testMatch.team2[t2Player];
        testMatch.team2[t2Player] = tempPlayer;
        
        // Check if creates 2M vs 2F
        if (creates2Mvs2F(testMatch, data)) continue;
        
        // Calculate new balance
        const newTeam1Total = testMatch.team1.reduce((sum, p) => sum + p.grade, 0);
        const newTeam2Total = testMatch.team2.reduce((sum, p) => sum + p.grade, 0);
        const newGap = Math.abs(newTeam1Total - newTeam2Total);
        
        // Keep if it's the best improvement so far
        if (newGap < bestGap) {
          bestGap = newGap;
          bestSwap = { t1Player, t2Player };
        }
      }
    }
    
    // Apply the best swap if found
    if (bestSwap) {
      const tempPlayer = match.team1[bestSwap.t1Player];
      match.team1[bestSwap.t1Player] = match.team2[bestSwap.t2Player];
      match.team2[bestSwap.t2Player] = tempPlayer;
      
      updateMatchFormat(match);
      log(`  ✓ Swapped players: Gap reduced from ${currentGap} to ${bestGap}`);
      totalImprovedMatches++;
    } else {
      log(`  No valid improvement found for match ${matchIndex}`);
    }
  });
  
  log(`=== INDIVIDUAL MATCH BALANCING COMPLETE: ${totalImprovedMatches} matches improved ===`);
  return matches;
}

function isUncompetitive(match) {
  const team1Grades = match.team1.map(p => p.grade).sort((a,b) => b-a); // [high, low]
  const team2Grades = match.team2.map(p => p.grade).sort((a,b) => b-a); // [high, low]
  
  // Calculate intra-team gaps
  const team1Gap = team1Grades[0] - team1Grades[1];
  const team2Gap = team2Grades[0] - team2Grades[1];
  
  // Uncompetitive if ANY partnership has 2+ grade gap
  const isUncomp = team1Gap >= 2 || team2Gap >= 2;
  
  if (isUncomp) {
    log(`Uncompetitive match: [${team1Grades.join(',')}] vs [${team2Grades.join(',')}] - gaps: ${team1Gap}, ${team2Gap}`);
  }
  
  return isUncomp;
}

function attemptCompetitivenessSwap(data, matches, matchAIndex, matchBIndex) {
  const matchA = matches[matchAIndex];
  const matchB = matches[matchBIndex];
  
  // Get all players from both matches with their current positions
  const playersA = [
    ...matchA.team1.map((p, i) => ({...p, match: matchAIndex, team: 1, position: i})),
    ...matchA.team2.map((p, i) => ({...p, match: matchAIndex, team: 2, position: i}))
  ];
  
  const playersB = [
    ...matchB.team1.map((p, i) => ({...p, match: matchBIndex, team: 1, position: i})),
    ...matchB.team2.map((p, i) => ({...p, match: matchBIndex, team: 2, position: i}))
  ];
  
  // Sort players by grade
  playersA.sort((a, b) => a.grade - b.grade); // weakest first
  playersB.sort((a, b) => b.grade - a.grade); // strongest first
  
  // Get the 2 weakest from A and 2 strongest from B
  const weakestFromA = playersA.slice(0, 2);
  const strongestFromB = playersB.slice(0, 2);
  
  log(`Swapping (no competitiveness check needed):`);
  log(`  Weakest from Match ${matchAIndex}: ${weakestFromA.map(p => `${p.name}(${p.grade})`).join(', ')}`);
  log(`  Strongest from Match ${matchBIndex}: ${strongestFromB.map(p => `${p.name}(${p.grade})`).join(', ')}`);
  
  // Create test versions of the matches
  const testMatchA = JSON.parse(JSON.stringify(matchA));
  const testMatchB = JSON.parse(JSON.stringify(matchB));
  
  // Perform direct 1-for-1 swaps
  // Swap weakest player 1 from A with strongest player 1 from B
  const weakPlayer1 = weakestFromA[0];
  const strongPlayer1 = strongestFromB[0];
  
  const weakTeam1 = weakPlayer1.team === 1 ? testMatchA.team1 : testMatchA.team2;
  const strongTeam1 = strongPlayer1.team === 1 ? testMatchB.team1 : testMatchB.team2;
  
  const temp1 = {...weakTeam1[weakPlayer1.position]};
  weakTeam1[weakPlayer1.position] = {...strongTeam1[strongPlayer1.position]};
  strongTeam1[strongPlayer1.position] = temp1;
  
  // Swap weakest player 2 from A with strongest player 2 from B
  const weakPlayer2 = weakestFromA[1];
  const strongPlayer2 = strongestFromB[1];
  
  const weakTeam2 = weakPlayer2.team === 1 ? testMatchA.team1 : testMatchA.team2;
  const strongTeam2 = strongPlayer2.team === 1 ? testMatchB.team1 : testMatchB.team2;
  
  const temp2 = {...weakTeam2[weakPlayer2.position]};
  weakTeam2[weakPlayer2.position] = {...strongTeam2[strongPlayer2.position]};
  strongTeam2[strongPlayer2.position] = temp2;
  
  // Only check if the swap creates the forbidden 2M vs 2F pattern
  if (creates2Mvs2F(testMatchA, data) || creates2Mvs2F(testMatchB, data)) {
    log(`  ❌ Swap would create 2M vs 2F - rejected`);
    return false;
  }
  
  // Accept the swap
  matches[matchAIndex] = testMatchA;
  matches[matchBIndex] = testMatchB;
  
  // Update match formats
  updateMatchFormat(matches[matchAIndex]);
  updateMatchFormat(matches[matchBIndex]);
  
  log(`  ✓ Swap completed`);
  return true;
}

function creates2Mvs2F(match, data) {
  const team1Men = match.team1.filter(p => getPlayerGender(p.name, data) === 'M').length;
  const team1Women = match.team1.filter(p => getPlayerGender(p.name, data) === 'F').length;
  const team2Men = match.team2.filter(p => getPlayerGender(p.name, data) === 'M').length;
  const team2Women = match.team2.filter(p => getPlayerGender(p.name, data) === 'F').length;
  
  // Check for 2M vs 2F pattern
  return (team1Men === 2 && team1Women === 0 && team2Men === 0 && team2Women === 2) ||
         (team1Men === 0 && team1Women === 2 && team2Men === 2 && team2Women === 0);
}

function isMatchupBalanced(team1, team2) {
  const team1Grades = team1.map(p => p.grade).sort((a, b) => b - a); // High to low
  const team2Grades = team2.map(p => p.grade).sort((a, b) => b - a); // High to low
  
  const team1High = team1Grades[0];
  const team1Low = team1Grades[1];
  const team2High = team2Grades[0];
  const team2Low = team2Grades[1];
  
  // Rule 1: Both teams should have similar highest grades (within 1 grade)
  if (Math.abs(team1High - team2High) > 1) {
    return false;
  }
  
  // Rule 2: Calculate total team strength
  const team1Total = team1High + team1Low;
  const team2Total = team2High + team2Low;
  
  // Rule 3: Special handling for Grade 5 players
  const team1HasGrade5 = team1Grades.includes(5);
  const team2HasGrade5 = team2Grades.includes(5);
  
  // If one team has Grade 5 and the other doesn't, be very strict
  if (team1HasGrade5 && !team2HasGrade5) {
    // Team 2 needs at least 4+4 to compete with a team that has a Grade 5
    return team2High === 4 && team2Low === 4;
  }
  if (team2HasGrade5 && !team1HasGrade5) {
    // Team 1 needs at least 4+4 to compete with a team that has a Grade 5
    return team1High === 4 && team1Low === 4;
  }
  
  // For teams without Grade 5, allow reasonable differences
  return Math.abs(team1Total - team2Total) <= 2;
}

function getPlayerGender(playerName, data) {
  // Check sorted arrays first
  let menPlayer = data.sortedMen ? data.sortedMen.find(p => p.name === playerName) : null;
  let womenPlayer = data.sortedWomen ? data.sortedWomen.find(p => p.name === playerName) : null;
  
  // If not found, check available arrays
  if (!menPlayer && data.availableMen) {
    menPlayer = data.availableMen.find(p => p.name === playerName);
  }
  if (!womenPlayer && data.availableWomen) {
    womenPlayer = data.availableWomen.find(p => p.name === playerName);
  }
  
  return menPlayer ? 'M' : (womenPlayer ? 'F' : null);
}

function checkPlayingDownStatus(currentSetNumber, allMatches) {
  const playingDownInstances = [];
  
  allMatches.forEach((match, matchIndex) => {
    const allPlayersInMatch = [...match.team1, ...match.team2];
    
    // For each player, check if they're playing with anyone 2+ grades lower
    allPlayersInMatch.forEach(player => {
      const playerGrade = player.grade;
      const otherPlayers = allPlayersInMatch.filter(p => p.name !== player.name);
      
      const playingDown = otherPlayers.some(other => (playerGrade - other.grade) >= 2);
      
      if (playingDown) {
        const lowestOpponentGrade = Math.min(...otherPlayers.map(p => p.grade));
        const gradeDifference = playerGrade - lowestOpponentGrade;
        
        playingDownInstances.push({
          matchIndex: matchIndex,
          playerName: player.name,
          playerGrade: playerGrade,
          lowestOpponentGrade: lowestOpponentGrade,
          gradeDifference: gradeDifference
        });
      }
    });
  });
  
  return playingDownInstances;
}

function hasPlayedDownBefore(playerName, currentSetNumber) {
  for (let setNum = 1; setNum < currentSetNumber; setNum++) {
    if (!allSetsData[setNum] || !allSetsData[setNum].matches) continue;
    
    const hasPlayedDown = allSetsData[setNum].matches.some(match => {
      const allPlayersInMatch = [...match.team1, ...match.team2];
      const thisPlayer = allPlayersInMatch.find(p => p.name === playerName);
      
      if (!thisPlayer) return false;
      
      // Check if this player was with anyone 2+ grades lower
      const otherPlayers = allPlayersInMatch.filter(p => p.name !== playerName);
      return otherPlayers.some(other => (thisPlayer.grade - other.grade) >= 1);
    });
    
    if (hasPlayedDown) return true;
  }
  return false;
}


function testSwapReducesConflicts(matches, match1Index, team1Num, player1Index, match2Index, team2Num, player2Index, currentSetNum) {
  // Create a test copy of matches with the proposed swap
  const testMatches = JSON.parse(JSON.stringify(matches));
  
  const match1 = testMatches[match1Index];
  const match2 = testMatches[match2Index];
  const team1 = team1Num === 1 ? match1.team1 : match1.team2;
  const team2 = team2Num === 1 ? match2.team1 : match2.team2;
  
  // Get conflict count before swap
  const conflictsBefore = checkForRepeatPartnerships(currentSetNum, matches).length;
  
  // Perform the test swap
  const tempPlayer = team1[player1Index];
  team1[player1Index] = team2[player2Index];
  team2[player2Index] = tempPlayer;
  
  // Get conflict count after swap
  const conflictsAfter = checkForRepeatPartnerships(currentSetNum, testMatches).length;
  
  // The swap is beneficial if it reduces conflicts and doesn't create new ones in different partnerships
  return conflictsAfter < conflictsBefore;
}

function displayResults(data, matches) {
  // Save current set data immediately when matches are generated
  currentSetNumber = parseInt(document.getElementById('setNumberSelector').value);
  
  // Combine manual matches with generated matches
  const allMatches = [...manualMatches, ...matches];
  
  allSetsData[currentSetNumber] = {
    data: JSON.parse(JSON.stringify(data)),
    matches: JSON.parse(JSON.stringify(allMatches)),
    satOffPlayers: []
  };

  // Store sat off players (players marked as SO, not resting)
  const satOffPlayers = playerRows.filter(p => p.name && p.so).map(p => p.name);
  if (satOffPlayers.length > 0) {
    allSetsData[currentSetNumber].satOffPlayers = [...satOffPlayers];
    log("Stored " + allSetsData[currentSetNumber].satOffPlayers.length + " sat-off players for Set " + currentSetNumber);
  } else {
    log("No players sat off for Set " + currentSetNumber + " (evenly divisible by 4)");
  }

  log("Set " + currentSetNumber + " data saved to memory");
  
  const matchesDiv = document.getElementById('matches');
  const matchResults = document.getElementById('matchResults');
  
 const repeatPartners = checkForRepeatPartnerships(currentSetNumber, allMatches);
const repeatOpponents = checkForRepeatOpponents(currentSetNumber, allMatches);
 let matchHtml = '<div class="success">✓ ' + allMatches.length + ' Matches Generated for Set ' + document.getElementById('setNumberSelector').value;
if (manualMatches.length > 0) {
  matchHtml += ' (' + manualMatches.length + ' manual + ' + matches.length + ' automatic)';
}
matchHtml += '</div>';
  matchHtml += '<p style="color: #666; font-style: italic;">Drag players or courts to swap them</p>';
  
  const isNHCPlayer = (playerName) => {
    // Check original data first (for manual match players)
    let menPlayer = data.availableMen ? data.availableMen.find(p => p.name === playerName) : null;
    let womenPlayer = data.availableWomen ? data.availableWomen.find(p => p.name === playerName) : null;
    
    // If not found in original lists, check sorted lists (for auto match players)
    if (!menPlayer && data.sortedMen) {
      menPlayer = data.sortedMen.find(p => p.name === playerName);
    }
    if (!womenPlayer && data.sortedWomen) {
      womenPlayer = data.sortedWomen.find(p => p.name === playerName);
    }
    
    const foundPlayer = menPlayer || womenPlayer;
    return foundPlayer && foundPlayer.nhc;
  };

const isNXDPlayer = (playerName) => {
  // Check original data first (for manual match players)
  let menPlayer = data.availableMen ? data.availableMen.find(p => p.name === playerName) : null;
  let womenPlayer = data.availableWomen ? data.availableWomen.find(p => p.name === playerName) : null;
  
  // If not found in original lists, check sorted lists (for auto match players)
  if (!menPlayer && data.sortedMen) {
    menPlayer = data.sortedMen.find(p => p.name === playerName);
  }
  if (!womenPlayer && data.sortedWomen) {
    womenPlayer = data.sortedWomen.find(p => p.name === playerName);
  }
  
  const foundPlayer = menPlayer || womenPlayer;
  return foundPlayer && foundPlayer.nxd;
};
  
  // Create compact table format
  matchHtml += '<table style="width: 100%; border-collapse: collapse; margin: 20px 0;">';
  
  // Header row
  matchHtml += '<tr style="background: #f8f9fa; border-bottom: 2px solid #333;">';
  matchHtml += '<th style="padding: 12px; text-align: center; font-weight: bold; border: 1px solid #ddd; width: 40px;">Court #</th>';
  matchHtml += '<th style="padding: 12px; text-align: center; font-weight: bold; border: 1px solid #ddd; width: 45%;">Team 1</th>';
matchHtml += '<th style="padding: 12px; text-align: center; font-weight: bold; border: 1px solid #ddd; width: 45%;">Team 2</th>';
  matchHtml += '</tr>';
  
  // Match rows
  allMatches.forEach((match, matchIndex) => {
    const isManual = match.isManual || false;
    const rowClass = isManual ? 'style="background: #fff8dc;"' : '';
    
    matchHtml += '<tr ' + rowClass + '>';
    
  // Court column
    const courtClass = isManual ? 'court-box manual' : 'court-box';
    matchHtml += '<td style="padding: 8px; text-align: center; border: 1px solid #ddd; vertical-align: middle;">';
    matchHtml += '<div class="' + courtClass + '" draggable="true" data-type="court" data-match="' + matchIndex + '" data-court="' + match.court + '" ';
    matchHtml += 'style="display: inline-block; background: white; color: black; border: 2px solid #333; ';
    matchHtml += 'padding: 6px 10px; border-radius: 5px; font-weight: bold; cursor: move; user-select: none;">';
    matchHtml += match.court;
    matchHtml += '</div></td>';
    
   // Team 1 column
matchHtml += '<td style="padding: 8px; border: 1px solid #ddd; vertical-align: middle;">';
match.team1.forEach((player, playerIndex) => {
  const nhcClass = isNHCPlayer(player.name) ? ' nhc' : '';
  const nxdClass = isNXDPlayer(player.name) ? ' nxd' : '';
  const manualClass = isManual ? ' manual-match' : '';
const isRepeatPartner = repeatPartners.some(rp => 
  rp.matchIndex === matchIndex && 
  rp.team === 1 && 
  rp.players.includes(player.name)
);
const isRepeatOpponent = repeatOpponents.some(ro => 
  ro.matchIndex === matchIndex && 
  (ro.player1 === player.name || ro.player2 === player.name)
);
const repeatClass = isRepeatPartner ? ' repeat-partner' : '';
const opponentClass = isRepeatOpponent ? ' repeat-opponent' : '';
  
  matchHtml += '<span class="player-box' + nhcClass + nxdClass + repeatClass + opponentClass + manualClass + '" draggable="true" ';
  matchHtml += 'data-type="player" data-match="' + matchIndex + '" data-team="1" data-player="' + playerIndex + '" ';
  matchHtml += 'data-name="' + player.name + '" data-grade="' + player.grade + '" ';
  matchHtml += 'style="display: inline-block; background: white; border: 2px solid #ddd; padding: 4px 8px; margin: 2px; ';
  matchHtml += 'border-radius: 5px; cursor: move; user-select: none; transition: all 0.2s ease;';
  
  // Apply styling based on player attributes
  if (isNHCPlayer(player.name) && isNXDPlayer(player.name)) {
    // Both NHC and NXD - let CSS handle the gradient
    matchHtml += ' font-weight: bold;';
  } else if (isNHCPlayer(player.name)) {
    matchHtml += ' background-color: #add8e6; font-weight: bold;';  // Light blue
  } else if (isNXDPlayer(player.name)) {
    matchHtml += ' background-color: #ffffe0; font-weight: bold;';   // Light yellow
  }
  
  if (isRepeatPartner) matchHtml += ' background-color: #ff9800; border: 2px solid #f57c00; font-weight: bold;';
  if (isManual) matchHtml += ' background-color: #fff8dc; border: 2px solid #ffc107;';
  
  matchHtml += '">';
  const downArrow = hasPlayedDownBefore(player.name, currentSetNumber) ? '↓' : '';
matchHtml += downArrow + player.name + ' (' + translateGrade(player.grade) + ')';
  matchHtml += '</span>';
  if (playerIndex === 0) matchHtml += ', ';
});
matchHtml += '</td>';
    
    // Team 2 column
matchHtml += '<td style="padding: 8px; border: 1px solid #ddd; vertical-align: middle;">';

match.team2.forEach((player, playerIndex) => {
  const nhcClass = isNHCPlayer(player.name) ? ' nhc' : '';
  const nxdClass = isNXDPlayer(player.name) ? ' nxd' : '';
  const manualClass = isManual ? ' manual-match' : '';
 const isRepeatPartner = repeatPartners.some(rp => 
  rp.matchIndex === matchIndex && 
  rp.team === 2 && 
  rp.players.includes(player.name)
);
const isRepeatOpponent = repeatOpponents.some(ro => 
  ro.matchIndex === matchIndex && 
  (ro.player1 === player.name || ro.player2 === player.name)
);
const repeatClass = isRepeatPartner ? ' repeat-partner' : '';
const opponentClass = isRepeatOpponent ? ' repeat-opponent' : '';
  
  matchHtml += '<span class="player-box' + nhcClass + nxdClass + repeatClass + opponentClass + manualClass + '" draggable="true" ';
  matchHtml += 'data-type="player" data-match="' + matchIndex + '" data-team="2" data-player="' + playerIndex + '" ';
  matchHtml += 'data-name="' + player.name + '" data-grade="' + player.grade + '" ';
  matchHtml += 'style="display: inline-block; background: white; border: 2px solid #ddd; padding: 4px 8px; margin: 2px; ';
  matchHtml += 'border-radius: 5px; cursor: move; user-select: none; transition: all 0.2s ease;';
  
  // Apply styling based on player attributes
  if (isNHCPlayer(player.name) && isNXDPlayer(player.name)) {
    // Both NHC and NXD - let CSS handle the gradient
    matchHtml += ' font-weight: bold;';
  } else if (isNHCPlayer(player.name)) {
    matchHtml += ' background-color: #add8e6; font-weight: bold;';  // Light blue
  } else if (isNXDPlayer(player.name)) {
    matchHtml += ' background-color: #ffffe0; font-weight: bold;';   // Light yellow
  }
  
  if (isRepeatPartner) matchHtml += ' background-color: #ff9800; border: 2px solid #f57c00; font-weight: bold;';
  if (isManual) matchHtml += ' background-color: #fff8dc; border: 2px solid #ffc107;';
  
  matchHtml += '">';
  const downArrow = hasPlayedDownBefore(player.name, currentSetNumber) ? '↓' : '';
matchHtml += downArrow + player.name + ' (' + translateGrade(player.grade) + ')';
  matchHtml += '</span>';
  if (playerIndex === 0) matchHtml += ', ';
});
matchHtml += '</td>';

matchHtml += '</tr>';
});  // ← CLOSING THE MAIN allMatches.forEach LOOP
  
  matchHtml += '</table>';

// Add legend
matchHtml += `
<div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 20px 0;">
  <div style="font-weight: bold; font-size: 16px; margin-bottom: 10px; color: #333;">Player Color Legend:</div>
  <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;">
    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="width: 40px; height: 20px; border: 2px solid #ddd; border-radius: 4px; font-size: 11px; text-align: center; line-height: 16px; font-weight: bold; background-color: #add8e6;">NHC</div>
      <span>No Hard Courts</span>
    </div>
    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="width: 40px; height: 20px; border: 2px solid #ddd; border-radius: 4px; font-size: 11px; text-align: center; line-height: 16px; font-weight: bold; background-color: #ffffe0;">NXD</div>
      <span>No Mixed Doubles</span>
    </div>
    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="width: 40px; height: 20px; border: 2px solid #ddd; border-radius: 4px; font-size: 11px; text-align: center; line-height: 16px; font-weight: bold; background: linear-gradient(90deg, #add8e6 0%, #ffffe0 100%);">Both</div>
      <span>NHC + NXD</span>
    </div>
    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="width: 40px; height: 20px; border: 2px solid #f57c00; border-radius: 4px; font-size: 11px; text-align: center; line-height: 16px; font-weight: bold; background-color: #ff9800;">RPP</div>
      <span>Repeat Partner (all)</span>
    </div>
    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="width: 40px; height: 20px; border: 3px dashed #dc3545; border-radius: 4px; font-size: 11px; text-align: center; line-height: 14px; font-weight: bold; background-color: white;">RO</div>
      <span>Repeat Opponent (last set)</span>
    </div>
    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="width: 40px; height: 20px; border: 2px solid #ffc107; border-radius: 4px; font-size: 11px; text-align: center; line-height: 16px; font-weight: bold; background-color: #fff8dc;">MAN</div>
      <span>Manual Match</span>
    </div>
<div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="color: #cc0000; font-weight: bold; font-size: 16px;">↓</div>
      <span>Played down previously</span>
    </div>
  </div>
</div>`;
  
  matchResults.innerHTML = matchHtml;
  matchesDiv.style.display = 'block';
  
  // Update current matches to include manual matches
  currentMatches = allMatches;
  
  setTimeout(() => initializeDragAndDrop(), 100);
saveDataToStorage();
}
function initializeDragAndDrop() {
  log("Initializing drag and drop");
  
  let draggedElement = null;
  let draggedData = null;
  
  const matchResults = document.getElementById('matchResults');
  if (!matchResults) return;
  
  const newMatchResults = matchResults.cloneNode(true);
  matchResults.parentNode.replaceChild(newMatchResults, matchResults);
  
  newMatchResults.addEventListener('dragstart', function(e) {
    if (e.target.getAttribute('draggable') === 'true') {
      draggedElement = e.target;
      draggedData = {
        type: e.target.dataset.type,
        match: parseInt(e.target.dataset.match),
        team: e.target.dataset.team,
        player: parseInt(e.target.dataset.player),
        court: e.target.dataset.court,
        name: e.target.dataset.name,
        grade: e.target.dataset.grade
      };
      e.target.classList.add('dragging');
      log("Dragging: " + (draggedData.name || draggedData.court));
    }
  });
  
  newMatchResults.addEventListener('dragend', function(e) {
    if (e.target.getAttribute('draggable') === 'true') {
      e.target.classList.remove('dragging');
      newMatchResults.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
    }
  });
  
  newMatchResults.addEventListener('dragover', function(e) {
    e.preventDefault();
  });
  
  newMatchResults.addEventListener('dragenter', function(e) {
    if (e.target.classList.contains('player-box') || e.target.classList.contains('court-box')) {
      e.target.classList.add('drag-over');
    }
  });
  
  newMatchResults.addEventListener('dragleave', function(e) {
    if (e.target.classList.contains('player-box') || e.target.classList.contains('court-box')) {
      e.target.classList.remove('drag-over');
    }
  });
  
  newMatchResults.addEventListener('drop', function(e) {
    e.preventDefault();
    
    if (!draggedElement || !draggedData) return;
    
    const dropTarget = e.target;
    if (dropTarget === draggedElement) return;
    
    dropTarget.classList.remove('drag-over');
    
    if (draggedData.type === 'player' && dropTarget.classList.contains('player-box')) {
      const targetData = {
        match: parseInt(dropTarget.dataset.match),
        team: dropTarget.dataset.team,
        player: parseInt(dropTarget.dataset.player),
        name: dropTarget.dataset.name
      };
      
      log("Swapping players: " + draggedData.name + " ↔ " + targetData.name);
      swapPlayers(draggedData, targetData);
      // Update stored data
      if (allSetsData[currentSetNumber]) {
        allSetsData[currentSetNumber].matches = JSON.parse(JSON.stringify(currentMatches));
      }
      refreshDisplay();
    }
    else if (draggedData.type === 'court' && dropTarget.classList.contains('court-box')) {
      const targetMatch = parseInt(dropTarget.dataset.match);
      const targetCourt = dropTarget.dataset.court;
      
      log("Swapping courts: " + draggedData.court + " ↔ " + targetCourt);
      swapCourts(draggedData.match, targetMatch);
      // Update stored data
      if (allSetsData[currentSetNumber]) {
        allSetsData[currentSetNumber].matches = JSON.parse(JSON.stringify(currentMatches));
      }
      refreshDisplay();
    }
    
    draggedElement = null;
    draggedData = null;
  });
}

function swapPlayers(player1, player2) {
  const match1 = currentMatches[player1.match];
  const match2 = currentMatches[player2.match];
  
  const team1 = player1.team === '1' ? match1.team1 : match1.team2;
  const team2 = player2.team === '1' ? match2.team1 : match2.team2;
  
  const tempPlayer = { ...team1[player1.player] };
  team1[player1.player] = { ...team2[player2.player] };
  team2[player2.player] = tempPlayer;

// Update match formats after swap
updateMatchFormat(currentMatches[player1.match]);
updateMatchFormat(currentMatches[player2.match]);
}

function updateMatchFormat(match) {
  if (!match || !match.team1 || !match.team2) return;
// Debug: Check what the data looks like
  console.log("currentData:", currentData);
  console.log("sortedMen:", currentData.sortedMen);
  console.log("sortedWomen:", currentData.sortedWomen);
  console.log("First player from team1:", match.team1[0]);
  
  // Count players by gender in each team
  const team1Men = match.team1.filter(p => getPlayerGender(p.name, currentData) === 'M').length;
  const team1Women = match.team1.filter(p => getPlayerGender(p.name, currentData) === 'F').length;
  const team2Men = match.team2.filter(p => getPlayerGender(p.name, currentData) === 'M').length;
  const team2Women = match.team2.filter(p => getPlayerGender(p.name, currentData) === 'F').length;
  
  // Determine correct format
  if (team1Men === 1 && team1Women === 1 && team2Men === 1 && team2Women === 1) {
    match.format = "Mixed Doubles";
  } else if (team1Men === 2 && team2Men === 2) {
    match.format = "Same-Sex Doubles (Men)";
  } else if (team1Women === 2 && team2Women === 2) {
    match.format = "Same-Sex Doubles (Women)";
  } else {
    match.format = "Mixed Gender";
  }
}

function getPlayerGender(playerName, data) {
  // Check sorted arrays first
  let menPlayer = data.sortedMen ? data.sortedMen.find(p => p.name === playerName) : null;
  let womenPlayer = data.sortedWomen ? data.sortedWomen.find(p => p.name === playerName) : null;
  
  // If not found, check available arrays
  if (!menPlayer && data.availableMen) {
    menPlayer = data.availableMen.find(p => p.name === playerName);
  }
  if (!womenPlayer && data.availableWomen) {
    womenPlayer = data.availableWomen.find(p => p.name === playerName);
  }
  
  return menPlayer ? 'M' : (womenPlayer ? 'F' : null);
}

function swapCourts(match1Index, match2Index) {
  const tempCourt = currentMatches[match1Index].court;
  currentMatches[match1Index].court = currentMatches[match2Index].court;
  currentMatches[match2Index].court = tempCourt;
}

function refreshDisplay() {
  displayResults(currentData, currentMatches.filter(m => !m.isManual));
}

// Print match sheet function
function printMatchSheet(data, matches) {
  try {
    const printWindow = window.open('', '_blank', 'width=1200,height=800');
    
    const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
    const satOffPlayers = playerRows.filter(p => p.name && p.so).map(p => p.name);
    
    let printHTML = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Tennis Match Sheet - Set ${currentSetNum}</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 20px; 
      background: white; 
      color: black;
      line-height: 1.4;
    }
   .header { 
  margin-bottom: 20px; 
  border-bottom: 1px solid black; 
  padding-bottom: 10px;
}
.header-info { 
  font-size: 16px; 
  font-weight: bold;
  margin: 0;
}
    .sat-off-section { 
      background: #f0f0f0; 
      border: 2px solid black; 
      padding: 15px; 
      margin: 20px 0; 
      border-radius: 5px;
    }
    .sat-off-title { 
      font-size: 18px; 
      font-weight: bold; 
      margin-bottom: 10px;
    }
   .matches-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 15px;
  margin: 20px 0;
}
    .match-card {
      border: 2px solid #333;
      padding: 15px;
      border-radius: 8px;
      background: white;
      break-inside: avoid;
    }
    .match-card.manual {
      background: #fff8dc;
      border-color: #ffc107;
    }
    .team {
      margin-bottom: 15px;
    }
    .player-line {
  margin: 8px 0;
  font-size: 14px;
  display: flex;
  align-items: center;
}
.player-info {
  width: 220px;
  flex-shrink: 0;
}
.player-name {
  font-weight: bold;
}
.court-boxes {
  display: flex;
  gap: 2px;
}
.court-box {
  width: 20px;
  height: 20px;
  border: 1px solid #333;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: bold;
  background: white;
  flex-shrink: 0;
}
    .court-box.filled {
      background: white;
    }
    .court-box.team2 {
  background: white;
}
    .court-box.sat-off {
      background: white;
    }
    @media print {
      body { margin: 15px; font-size: 12px; }
      .matches-grid { grid-template-columns: repeat(2, 1fr); gap: 15px; }
      .match-card { padding: 10px; }
      .player-line { font-size: 12px; }
      .court-box { width: 18px; height: 18px; font-size: 9px; }
    }
  </style>
</head>
<body>
  <div class="header">
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <div class="header-info">Date: ${new Date().toLocaleDateString()}</div>
    <div class="header-info">Set Number: ${currentSetNum}</div>
    <div class="header-info">Format: ${data.setFormatPreference}</div>
  </div>
</div>
`;

    if (satOffPlayers.length > 0) {
      printHTML += `
  <div class="sat-off-section">
    <div class="sat-off-title">Players Sitting Off This Set:</div>
    <div class="sat-off-list">${satOffPlayers.join(', ')}</div>
  </div>
`;
    }

// Function to get court boxes with team position shading
function getCourtBoxes(playerName) {
  const boxes = [];
  for (let setNum = 1; setNum <= 6; setNum++) {
    let courtFound = false;
    let courtValue = '';
    let boxClass = 'court-box';
    
    if (setNum <= currentSetNum) {
      if (setNum === currentSetNum) {
        // Current set - check current matches
        matches.forEach(match => {
          // Check if player is in team1
          const inTeam1 = match.team1.some(p => p.name === playerName);
          // Check if player is in team2
          const inTeam2 = match.team2.some(p => p.name === playerName);
          
          if (inTeam1) {
  courtValue = match.court;
  boxClass = 'court-box filled'; // Team 1 - no dot
  courtFound = true;
} else if (inTeam2) {
  courtValue = match.court + '.';
  boxClass = 'court-box filled'; // Team 2 - with dot
  courtFound = true;
}
        });
      } else {
        // Previous sets - check stored data
        if (allSetsData[setNum] && allSetsData[setNum].matches) {
          allSetsData[setNum].matches.forEach(match => {
            // Check if player is in team1
            const inTeam1 = match.team1.some(p => p.name === playerName);
            // Check if player is in team2  
            const inTeam2 = match.team2.some(p => p.name === playerName);
            
           if (inTeam1) {
  courtValue = match.court;
  boxClass = 'court-box filled'; // Team 1 - no dot
  courtFound = true;
} else if (inTeam2) {
  courtValue = match.court + '.';
  boxClass = 'court-box filled'; // Team 2 - with dot
  courtFound = true;
}
          });
        }
      }
      
      // If player sat off, mark with 'X'
      if (!courtFound) {
        if (setNum < currentSetNum && allSetsData[setNum] && allSetsData[setNum].satOffPlayers && 
            allSetsData[setNum].satOffPlayers.includes(playerName)) {
          courtValue = 'X';
          boxClass = 'court-box sat-off';
        } else if (setNum === currentSetNum && satOffPlayers.includes(playerName)) {
          courtValue = 'X';
          boxClass = 'court-box sat-off';
        }
      }
    }
    
    boxes.push(`<div class="${boxClass}">${courtValue}</div>`);
  }
  return boxes.join('');
}

    printHTML += '<div class="matches-grid">';

    matches.forEach((match, index) => {
      const isManual = match.isManual || false;
      const cardClass = isManual ? 'match-card manual' : 'match-card';
      
      printHTML += `<div class="${cardClass}">`;
      
      // Team 1
      printHTML += '<div class="team">';
      match.team1.forEach(player => {
        printHTML += `<div class="player-line">`;
        printHTML += `<div class="player-info">`;
        printHTML += `<span class="player-name">${player.name}</span> (${translateGrade(player.grade)})`;
        printHTML += `</div>`;
        printHTML += `<div class="court-boxes">${getCourtBoxes(player.name)}</div>`;
        printHTML += `</div>`;
      });
      printHTML += '</div>';

      // Team 2 (with gap)
      printHTML += '<div class="team" style="margin-top: 15px;">';
      match.team2.forEach(player => {
        printHTML += `<div class="player-line">`;
        printHTML += `<div class="player-info">`;
        printHTML += `<span class="player-name">${player.name}</span> (${translateGrade(player.grade)})`;
        printHTML += `</div>`;
        printHTML += `<div class="court-boxes">${getCourtBoxes(player.name)}</div>`;
        printHTML += `</div>`;
      });
      printHTML += '</div>';
      
      printHTML += '</div>';
    });

    printHTML += '</div>';
    printHTML += '</body></html>';

    printWindow.document.write(printHTML);
    printWindow.document.close();
    
    setTimeout(() => {
      printWindow.focus();
      printWindow.print();
    }, 250);
    
    log("Print dialog opened for match sheet with court history boxes");
    
  } catch (error) {
    alert("Error creating print sheet: " + error.message);
    log("Error creating print sheet: " + error.message);
  }
}
function downloadResults(data, matches) {
  try {
    const wb = XLSX.utils.book_new();
    
    // Get all completed sets from storage
    const completedSets = Object.keys(allSetsData).sort((a, b) => parseInt(a) - parseInt(b));
    
    if (completedSets.length === 0) {
      // Fallback to current set if no stored data
      createSingleSetSheet(wb, data, matches, currentSetNumber);
    } else {
      // Create a sheet for each completed set
      completedSets.forEach(setNum => {
        const setData = allSetsData[setNum];
        createSingleSetSheet(wb, setData.data, setData.matches, setNum, setData.satOffPlayers);
      });
    }
    
    // Generate filename with timestamp
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const setCount = completedSets.length || 1;
    const filename = `Tennis_Matches_${setCount}_Sets_${timestamp}.xlsx`;
    
    // Download the file
    XLSX.writeFile(wb, filename);
    
    log("Excel file downloaded: " + filename + " with " + (completedSets.length || 1) + " sheets");
    
  } catch (error) {
    alert("Error creating Excel file: " + error.message);
    log("Error creating Excel file: " + error.message);
  }
}

function createSingleSetSheet(wb, data, matches, setNumber, satOffPlayers = []) {
  const wsData = [];
  
  // Add header information
  wsData.push(['Date', new Date().toISOString().split('T')[0]]);
  wsData.push(['Set Number', 'Set ' + setNumber]);
  wsData.push(['Set Format Preference', data.setFormatPreference]);
  wsData.push([]);
  
  // Add match headers AND player list headers on the same row (row 5)
  wsData.push(['Court', 'Team 1', 'Team 2', 'Match Format', 'Match Type', 'Sat Off Players', '', 'Total Men Players', 'Grade', 'NHC', 'Resting', 'PSO', '', 'Total Women Players', 'Grade', 'NHC', 'Resting', 'PSO']);
  
  // Determine how many rows we need (matches vs players)
  const maxRows = Math.max(matches.length, data.availableMen.length, data.availableWomen.length);
  
  // Add data rows
  for (let i = 0; i < maxRows; i++) {
    const row = ['', '', '', '', '', '', '']; // Columns A-G (matches + spacing)
    
    // Add match data if we have a match for this row
    if (i < matches.length) {
      const match = matches[i];
     const team1Str = match.team1.map(p => `${p.name} (${translateGrade(p.grade)})`).join(', ');
const team2Str = match.team2.map(p => `${p.name} (${translateGrade(p.grade)})`).join(', ');
      const satOffPlayer = i < satOffPlayers.length ? satOffPlayers[i] : '';
      const matchType = match.isManual ? 'Manual' : 'Auto';
      
      row[0] = match.court;           // A: Court
      row[1] = team1Str;              // B: Team 1
      row[2] = team2Str;              // C: Team 2
      row[3] = match.format;          // D: Match Format
      row[4] = matchType;             // E: Match Type
      row[5] = satOffPlayer;          // F: Sat Off Players
      row[6] = '';                    // G: Spacing
    }
    
    // Add men's data if we have a man for this row (columns H-L)
    if (i < data.availableMen.length) {
      const player = data.availableMen[i];
      row[7] = player.name;           // H: Men's names
      row[8] = player.grade;          // I: Men's grade
      row[9] = player.nhc ? 'y' : ''; // J: Men's NHC
      row[10] = player.resting ? 'y' : ''; // K: Men's resting
      row[11] = player.pso ? 'y' : ''; // L: Men's PSO
    }
    
    // Column M: Spacing between men and women
    row[12] = '';
    
    // Add women's data if we have a woman for this row (columns N-R)
    if (i < data.availableWomen.length) {
      const player = data.availableWomen[i];
      row[13] = player.name;          // N: Women's names
      row[14] = player.grade;         // O: Women's grade
      row[15] = player.nhc ? 'y' : ''; // P: Women's NHC
      row[16] = player.resting ? 'y' : ''; // Q: Women's resting
      row[17] = player.pso ? 'y' : ''; // R: Women's PSO
    }
    
    wsData.push(row);
  }
  
  // Create worksheet
  const ws = XLSX.utils.aoa_to_sheet(wsData);
  
  // Set column widths - wider for names, narrower for single letters
  ws['!cols'] = [
    { wch: 20 }, // A: Court
    { wch: 50 }, // B: Team 1
    { wch: 50 }, // C: Team 2
    { wch: 25 }, // D: Match Format
    { wch: 10 }, // E: Match Type
    { wch: 20 }, // F: Sat Off Players
    { wch: 3 },  // G: Spacing
    { wch: 20 }, // H: Men's names
    { wch: 8 },  // I: Men's grade
    { wch: 6 },  // J: Men's NHC
    { wch: 8 },  // K: Men's resting
    { wch: 6 },  // L: Men's PSO
    { wch: 3 },  // M: Spacing
    { wch: 20 }, // N: Women's names
    { wch: 8 },  // O: Women's grade
    { wch: 6 },  // P: Women's NHC
    { wch: 8 },  // Q: Women's resting
    { wch: 6 }   // R: Women's PSO
  ];
  
  // Add worksheet to workbook
  XLSX.utils.book_append_sheet(wb, ws, 'Set ' + setNumber + ' Summary');
}

// Initialize the page with auto-restore
document.addEventListener('DOMContentLoaded', () => {
  initializeCourts();
  loadMemberListOnStartup();
  
  // Try to load saved data
  setTimeout(() => {
    loadDataFromStorage();
  }, 500);
});
// Download and print functions
document.getElementById('downloadBtn').onclick = function() {
  if (currentData && currentMatches) {
    downloadResults(currentData, currentMatches);
  } else {
    alert('No matches to download. Please generate matches first.');
  }
};

document.getElementById('printBtn').onclick = function() {
  if (currentData && currentMatches) {
    printMatchSheet(currentData, currentMatches);
  } else {
    alert('No matches to print. Please generate matches first.');
  }
};

// Excel import functionality
document.getElementById('importExcelBtn').addEventListener('click', () => {
  document.getElementById('excelFileInput').click();
});

document.getElementById('excelFileInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    const arrayBuffer = await file.arrayBuffer();
    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
    
    // Check if required sheets exist
    if (!workbook.SheetNames.includes("Today's Players")) {
      alert("Error: Excel file must contain a sheet named \"Today's Players\"");
      return;
    }
    if (!workbook.SheetNames.includes("Available Courts")) {
      alert("Error: Excel file must contain a sheet named \"Available Courts\"");
      return;
    }
    
    // Parse Today's Players sheet
    const playersSheet = workbook.Sheets["Today's Players"];
    const playersData = XLSX.utils.sheet_to_json(playersSheet, { header: 1 });
    
    // Parse Available Courts sheet
    const courtsSheet = workbook.Sheets["Available Courts"];
    const courtsData = XLSX.utils.sheet_to_json(courtsSheet, { header: 1 });
    
    // Process players data
    const importedPlayers = [];
    
    // Skip header row (index 0), process data rows
    for (let i = 1; i < playersData.length; i++) {
      const row = playersData[i];
      if (!row || row.length === 0) continue;
      
      // Men's data (columns A-D)
      if (row[0] && typeof row[0] === 'string' && row[0].trim() !== '') {
        const menGrade = parseGrade(row[1]);
        if (menGrade !== null) {
          importedPlayers.push({
            name: row[0].trim(),
            grade: menGrade,
            gender: 'M',
            nhc: parseBoolean(row[2]),
            nxd: parseBoolean(row[3]),
            resting: false,
            pso: false,
            so: false
          });
        }
      }
      
      // Women's data (columns F-I)
      if (row[5] && typeof row[5] === 'string' && row[5].trim() !== '') {
        const womenGrade = parseGrade(row[6]);
        if (womenGrade !== null) {
          importedPlayers.push({
            name: row[5].trim(),
            grade: womenGrade,
            gender: 'F',
            nhc: parseBoolean(row[7]),
            nxd: parseBoolean(row[8]),
            resting: false,
            pso: false,
            so: false
          });
        }
      }
    }
    
// Process courts data
const importedCourts = [];

console.log("Courts sheet data:", courtsData);

// Skip header row, process data rows
for (let i = 1; i < courtsData.length; i++) {
  const row = courtsData[i];
  console.log(`Row ${i}:`, row);
  
  if (!row || row.length < 2) {
    console.log(`Skipping row ${i} - insufficient data`);
    continue;
  }
  
  const priority = parseInt(row[0]);
  const courtName = row[1];
  
  console.log(`Row ${i}: priority=${priority}, courtName="${courtName}"`);
  
  const isValidPriority = !isNaN(priority) && priority > 0;
const isValidCourtName = courtName !== null && courtName !== undefined && courtName.toString().trim() !== '';

if (isValidPriority && isValidCourtName) {
    const courtToAdd = {
      priority: priority,
      court: courtName.toString().trim()
    };
    console.log(`Adding court:`, courtToAdd);
    importedCourts.push(courtToAdd);
  } else {
    console.log(`Skipping row ${i} - invalid data: priority=${priority}, courtName="${courtName}"`);
  }
}

console.log("Final imported courts:", importedCourts);
    
    // Sort courts by priority
    importedCourts.sort((a, b) => a.priority - b.priority);
    
    
    
    // Clear existing data
    playerRows = [];
    availableCourts = [];
    
    // Import players
    playerRows = [...importedPlayers];
    
// Restore PSO status from all previous sets for imported players
const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
for (let setNum = 1; setNum < currentSetNum; setNum++) {
  if (allSetsData[setNum] && allSetsData[setNum].satOffPlayers) {
    const previousSatOffPlayers = allSetsData[setNum].satOffPlayers;
    playerRows.forEach(player => {
      if (previousSatOffPlayers.includes(player.name)) {
        player.pso = true;
      }
    });
  }
}

 // Ensure we have at least 10 rows for manual additions
    while (playerRows.length < 10) {
      playerRows.push({
        name: '', grade: '', gender: '', nhc: false, nxd: false,
        resting: false, pso: false, so: false
      });
    }
    
    // Import courts
    availableCourts = importedCourts.map(c => c.court);
    
    // Refresh UI
    refreshPlayerTable();
    updateAvailableCourtsDisplay();

  // Refresh court pool and remove selected courts
initializeCourts();
availableCourts.forEach(court => {
  const courtElement = document.querySelector(`[data-court="${court}"]`);
  if (courtElement && courtElement.parentElement.id === 'courtPool') {
    courtElement.remove();
  }
});
    updateSitOffCalculation();
    updateProceedButton();
    
    // Show success message
// Show success message in the status area
document.getElementById('memberLoadStatus').innerHTML = 
  `<div class="success">✓ Imported ${importedPlayers.length} players and ${importedCourts.length} courts from Excel file</div>`;
    
    // Auto-save the imported data
    saveDataToStorage();
    
  } catch (error) {
    alert(`Error reading Excel file: ${error.message}`);
    console.error('Excel import error:', error);
  }
  
  // Clear file input
  e.target.value = '';
});

// Helper function to parse grade values
function parseGrade(gradeValue) {
  if (!gradeValue) return null;
  return reverseTranslateGrade(gradeValue.toString().trim());
}

// Helper function to parse boolean values
function parseBoolean(value) {
  if (!value) return false;
  
  if (typeof value === 'boolean') return value;
  
  if (typeof value === 'string') {
    const str = value.toString().trim().toLowerCase();
    return str === 'y' || str === 'yes' || str === 'true' || str === '1';
  }
  
  if (typeof value === 'number') {
    return value === 1;
  }
  
  return false;
}

// Function to refresh the player table after import
function refreshPlayerTable() {
  const tbody = document.getElementById('playerTableBody');
  tbody.innerHTML = '';
  
  playerRows.forEach((player, index) => {
    addPlayerRowAtIndex(index);
    
    // Populate the row with imported data
    if (player.name) {
      document.querySelector(`[data-row="${index}"]`).value = player.name;
      document.getElementById(`grade-${index}`).value = player.grade;
      document.getElementById(`gender-${index}`).value = player.gender;
      document.getElementById(`nhc-${index}`).checked = player.nhc;
      document.getElementById(`nxd-${index}`).checked = player.nxd;
      document.getElementById(`resting-${index}`).checked = player.resting;
      document.getElementById(`pso-${index}`).checked = player.pso;
      document.getElementById(`so-${index}`).checked = player.so;
      
      // Show delete button if player has complete data
      if (player.name && player.grade && player.gender) {
        document.querySelector(`[data-row="${index}"].delete-player-btn`).style.display = 'block';
      }
    }
  });
}

// Button-style selectors for format and set number
document.addEventListener('DOMContentLoaded', function() {
  // Format button handlers
  document.querySelectorAll('.format-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      // Remove active from all format buttons
      document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
      // Add active to clicked button
      this.classList.add('active');
      // Update hidden select
      document.getElementById('formatSelector').value = this.dataset.format;
      // Trigger change event for compatibility
      document.getElementById('formatSelector').dispatchEvent(new Event('change'));
    });
  });

  // Set number button handlers
  document.querySelectorAll('.set-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      // Remove active from all set buttons
      document.querySelectorAll('.set-btn').forEach(b => b.classList.remove('active'));
      // Add active to clicked button
      this.classList.add('active');
      // Update hidden select
      document.getElementById('setNumberSelector').value = this.dataset.set;
      // Trigger change event for compatibility
      document.getElementById('setNumberSelector').dispatchEvent(new Event('change'));
    });
  });
});

</script>

</body>
</html>
        