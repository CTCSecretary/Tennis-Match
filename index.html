<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Social Tennis Match Maker</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="Member Master List.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f4f4f4; }

/* Logo Section Styles */
.logo-section {
  text-align: center;
  margin-bottom: 20px;
  padding: 15px;
  background: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
/* Step Header Styles */
.step-header {
  background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
  color: white;
  font-size: 24px;
  font-weight: bold;
  padding: 20px 30px;
  margin: -15px -15px 20px -15px;
  border-radius: 8px 8px 0 0;
  text-align: left;
  box-shadow: 0 2px 8px rgba(30, 64, 175, 0.3);
}
.logo {
  max-height: 80px;
  max-width: 100%;
  height: auto;
  border-radius: 8px;
  transition: all 0.3s ease;
}
.logo:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

h1 { text-align: center; color: #333; }
    .section { background: white; margin: 15px 0; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .error { color: red; font-weight: bold; }
    .success { color: green; font-weight: bold; }
    .warning { color: orange; font-weight: bold; }
    button { padding: 10px 20px; margin: 10px 5px; border: none; border-radius: 5px; cursor: pointer; }
    .primary { background: #007acc; color: white; }
    .secondary { background: #6c757d; color: white; }
    .danger { background: #dc3545; color: white; }
    
    /* Court Selection Styles */
    .court-pool {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 8px;
      margin: 15px 0;
      padding: 15px;
      border: 2px dashed #ddd;
      border-radius: 8px;
      background: #fafafa;
      min-height: 120px;
    }
    .court-item {
      background: #007acc;
      color: white;
      padding: 10px;
      text-align: center;
      border-radius: 5px;
      cursor: move;
      user-select: none;
      font-weight: bold;
      transition: all 0.2s;
    }

/* Court type specific colors */
.court-item.grass-court {
  background: #28a745 !important; /* Green for grass courts */
}

.court-item.grass-court:hover {
  background: #1e7e34 !important; /* Darker green on hover */
}

.court-item.hard-court {
  background: #007acc !important; /* Blue for hard courts */
}

.court-item.hard-court:hover {
  background: #005a99 !important; /* Darker blue on hover */
}

/* Also apply to available courts area */
.available-courts .court-item.grass-court {
  background: #28a745 !important;
}

.available-courts .court-item.grass-court:hover {
  background: #1e7e34 !important;
}

.available-courts .court-item.hard-court {
  background: #007acc !important;
}

.available-courts .court-item.hard-court:hover {
  background: #005a99 !important;
}

.court-item:hover { background: #005a99; transform: scale(1.05); }

    .court-item:hover { background: #005a99; transform: scale(1.05); }
    .court-item.dragging { opacity: 0.5; }
    
    .available-courts {
      min-height: 80px;
      padding: 15px;
      border: 2px dashed #28a745;
      border-radius: 8px;
      background: #f8fff8;
      margin: 15px 0;
    }
    .available-courts.drag-over { border-color: #007acc; background: #e3f2fd; }
    .available-courts .court-item { 
      background: #28a745; 
      margin: 5px;
      display: inline-block;
    }
    .available-courts .court-item:hover { background: #1e7e34; }
    
    /* Player Table Styles */
    .player-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
    .player-table th, .player-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    .player-table th {
      background: #f8f9fa;
      font-weight: bold;
    }
    .player-table tr:nth-child(even) {
      background: #f9f9f9;
    }
    .player-table tr:hover {
      background: #e8f4fd;
    }
    
    .name-input {
  width: 100%;
  padding: 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 16px;
}
    .name-input:focus {
      border-color: #007acc;
      outline: none;
    }
    
    .autocomplete-suggestions {
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-top: none;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      width: 100%;
    }
    .autocomplete-suggestion {
  padding: 8px;
  cursor: pointer;
  border-bottom: 1px solid #eee;
  font-size: 16px;
}
    .autocomplete-suggestion:hover {
      background: #e8f4fd;
    }
    .autocomplete-suggestion.selected {
      background: #007acc;
      color: white;
    }
    
    .checkbox-cell {
      text-align: center;
      width: 60px;
    }
    .status-checkbox {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
.grade-select, .gender-select {
      width: 100%;
      padding: 4px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-size: 14px;
      background: white;
    }
    .grade-select:focus, .gender-select:focus {
      border-color: #007acc;
      outline: none;
    }
    
    .sit-off-calculator {
      background: #fff3cd;
      border: 1px solid #ffc107;
      padding: 15px;
      border-radius: 5px;
      margin: 15px 0;
      text-align: center;
      font-size: 18px;
      font-weight: bold;
    }
    .sit-off-good { background: #d4edda; border-color: #28a745; color: #155724; }
    .sit-off-bad { background: #f8d7da; border-color: #dc3545; color: #721c24; }
    
    /* Manual Match Setup Styles */
    .manual-match-setup {
      border: 2px solid #ffc107;
      background: #fff8dc;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .manual-match-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .manual-match-title {
      font-size: 18px;
      font-weight: bold;
      color: #856404;
    }
    .manual-matches-list {
      margin: 15px 0;
    }
    .manual-match-item {
      background: white;
      border: 1px solid #ffc107;
      border-radius: 5px;
      padding: 12px;
      margin: 8px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .manual-match-details {
      flex: 1;
    }
    .manual-match-court {
      font-weight: bold;
      color: #007acc;
      margin-bottom: 5px;
    }
    .manual-match-teams {
      font-size: 14px;
      color: #333;
    }
    
    /* Player Selection for Manual Matches */
    .manual-player-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin: 15px 0;
    }
    .manual-player-item {
      background: white;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }
    .manual-player-item:hover {
      border-color: #007acc;
      background: #f8f9fa;
    }
    .manual-player-item.selected {
      background: #007acc;
      color: white;
      border-color: #0056b3;
    }
    .manual-player-item.excluded {
      background: #f8f9f9;
      color: #6c757d;
      border-color: #dee2e6;
      cursor: not-allowed;
    }
    
    /* Team Formation Area */
    .team-formation {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 20px;
      margin: 20px 0;
      align-items: center;
    }
    .team-slot {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 15px;
      min-height: 100px;
      background: #fafafa;
    }
    .team-slot.has-players {
      border-color: #007acc;
      background: #e3f2fd;
    }
    .team-slot-title {
      font-weight: bold;
      margin-bottom: 10px;
      text-align: center;
    }
    .team-player {
      background: white;
      border: 1px solid #007acc;
      border-radius: 4px;
      padding: 5px 8px;
      margin: 3px 0;
      font-size: 14px;
    }
    .vs-divider {
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      color: #666;
    }
    
    /* Court Selection for Manual Matches */
    .court-selector {
      margin: 15px 0;
    }
    .court-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
      margin: 10px 0;
    }
    .court-option {
      background: white;
      border: 2px solid #ddd;
      border-radius: 5px;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .court-option:hover {
      border-color: #007acc;
    }
    .court-option.selected {
      background: #007acc;
      color: white;
      border-color: #0056b3;
    }
    .court-option.excluded {
      background: #f8f9f9;
      color: #6c757d;
      border-color: #dee2e6;
      cursor: not-allowed;
    }
    
    /* Match Display Styles */
    .match-container {
      background: #f9f9f9; border: 1px solid #ddd; padding: 15px; margin: 8px 0;
      border-radius: 6px; border-left: 4px solid #007acc;
    }
    .match-container.manual-match {
      border-left: 4px solid #ffc107;
      background: #fff8dc;
    }
    .court-box {
      display: inline-block; background: #007acc; color: white; padding: 8px 12px;
      border-radius: 5px; margin-bottom: 10px; font-weight: bold; cursor: move;
      user-select: none;
    }
    .court-box.manual {
      background: #ffc107;
      color: #856404;
    }
    .court-box:hover { background: #005a99; }
    .court-box.manual:hover { background: #e0a800; }
    .court-box.dragging { opacity: 0.5; }
    .court-box.drag-over { background: #28a745; }
    
    .teams-row { display: flex; gap: 20px; align-items: flex-start; }
    .team-column { flex: 1; min-height: 80px; }
    .team-header {
      font-weight: bold; margin-bottom: 8px; text-align: center;
      padding: 5px; background: #e9e9e9; border-radius: 3px;
    }
    .player-box {
      background: white; border: 2px solid #ddd; padding: 8px; margin: 4px 0;
      border-radius: 5px; cursor: move; user-select: none; text-align: center;
      transition: all 0.2s ease;
    }
    .player-box:hover { border-color: #007acc; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    .player-box.dragging { opacity: 0.5; transform: rotate(2deg); }
    .player-box.nhc { background-color: #ffeb3b; font-weight: bold; }
    .player-box.repeat-partner { background-color: #ff9800; border: 2px solid #f57c00; font-weight: bold; }
    .player-box.manual-match { background-color: #fff8dc; border: 2px solid #ffc107; }
    .player-box.drag-over { border-color: #28a745; border-width: 3px; background-color: #e8f5e8; }
    .format { font-style: italic; color: #666; margin-top: 8px; font-size: 0.9em; }

.player-box-compact {
  background: white; 
  border: 2px solid #ddd; 
  padding: 4px 8px; 
  border-radius: 5px; 
  cursor: move; 
  user-select: none; 
  text-align: center;
  transition: all 0.2s ease;
  display: inline-block;
}
.player-box-compact:hover { 
  border-color: #007acc; 
  box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
}
.player-box-compact.dragging { 
  opacity: 0.5; 
  transform: rotate(2deg); 
}
.player-box-compact.nhc { 
  background-color: #ffeb3b; 
  font-weight: bold; 
}
.player-box-compact.repeat-partner { 
  background-color: #ff9800; 
  border: 2px solid #f57c00; 
  font-weight: bold; 
}
.player-box-compact.manual-match { 
  background-color: #fff8dc; 
  border: 2px solid #ffc107; 
}
.player-box-compact.drag-over { 
  border-color: #28a745; 
  border-width: 3px; 
  background-color: #e8f5e8; 
}
    
    .info-box { background: #cff4fc; border: 1px solid #0dcaf0; padding: 15px; border-radius: 5px; margin: 15px 0; }
    .warning-box { background: #fff3cd; border: 1px solid #ffc107; padding: 15px; border-radius: 5px; margin: 15px 0; }
.info-box { background: #cff4fc; border: 1px solid #0dcaf0; padding: 15px; border-radius: 5px; margin: 15px 0; }
.warning-box { background: #fff3cd; border: 1px solid #ffc107; padding: 15px; border-radius: 5px; margin: 15px 0; }

/* Player Selection Styles */
.selection-grid { 
  display: grid; 
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
  gap: 10px; 
  margin: 15px 0; 
}
.player-checkbox { 
  display: flex; 
  align-items: center; 
  padding: 8px; 
  border: 1px solid #ddd; 
  border-radius: 5px; 
  background: white; 
  cursor: pointer; 
  transition: all 0.2s;
}
.player-checkbox:hover { 
  border-color: #007acc; 
  background: #f8f9fa; 
}
.player-checkbox.pso { 
  background-color: #fff3cd; 
  border-color: #ffc107; 
}
.player-checkbox.selected { 
  background-color: #d4edda; 
  border-color: #28a745; 
}
.player-checkbox input { 
  margin-right: 10px; 
}
  </style>
</head>
<body>
  <!-- Logo Section -->
<div class="logo-section">
  <div style="display: flex; align-items: center; justify-content: center; gap: 20px;">
    <img src="CTClogo.jpg" alt="Tennis Club Logo" class="logo">
    <h1 style="margin: 0; color: #333;">Social Tennis Match Maker</h1>
  </div>
</div>
  
  <!-- Court Selection Section -->
<div class="section">
  <div class="step-header">Step 1: Select available courts</div>
     
    <h4>Selected Courts</h4>
    <div id="availableCourts" class="available-courts">
      <em style="color: #666;">Click or Drag courts here in the order they will be used</em>
    </div>
    
    <h4>Unselected Courts:</h4>
    <div id="courtPool" class="court-pool"></div>
    
    <button id="clearCourts" class="secondary">Clear All Courts</button>
  </div>

  <!-- Member Master List -->
<div class="section">
  <div class="step-header">Step 2: Upload List of Members</div>
  <button id="loadMembersBtn" class="primary">Upload</button>
  <div id="masterListStatus" style="margin-top: 10px;"></div>
</div>

  <!-- Set Configuration -->
  <div class="section">
  <div class="step-header">Step 3: Choose match format and set number</div>
  <div style="margin-bottom: 15px;">
      <label for="formatSelector" style="font-weight: bold; margin-right: 10px;">Set Format Preference:</label>
      <select id="formatSelector" style="padding: 8px; font-size: 16px; border-radius: 4px; border: 1px solid #ccc;">
        <option value="Same-Sex">Same-Sex Doubles</option>
        <option value="Mixed">Mixed Doubles</option>
      </select>
    </div>
    <div style="margin-bottom: 15px;">
      <label for="setNumberSelector" style="font-weight: bold; margin-right: 10px;">Set Number:</label>
      <select id="setNumberSelector" style="padding: 8px; font-size: 16px; border-radius: 4px; border: 1px solid #ccc;">
        <option value="1" selected>Set 1</option>
        <option value="2">Set 2</option>
        <option value="3">Set 3</option>
        <option value="4">Set 4</option>
        <option value="5">Set 5</option>
        <option value="6">Set 6</option>
      </select>
    </div>
  </div>

  <!-- Player Selection Section -->
  <div id="playerSelectionSection" class="section" style="display:none;">
    <div class="step-header">Step 4: Player Selection</div>
    
    <div id="sitOffCalculator" class="sit-off-calculator">
      Players to sit off: <span id="sitOffCount">-</span>
    </div>
    
    <table class="player-table">
      <thead>
        <tr>
  <th style="width: 200px;">Name</th>
  <th style="width: 80px;">Grade</th>
  <th style="width: 80px;">Gender</th>
  <th style="width: 60px;">NHC</th>
  <th style="width: 80px;">Resting</th>
  <th style="width: 60px;">PSO</th>
  <th style="width: 60px;">SO</th>
</tr>
      </thead>
      <tbody id="playerTableBody">
      </tbody>
    </table>
    
    <div style="text-align: center; margin: 15px 0;">
      <button id="addMoreRows" class="secondary">Add 10 More Rows</button>
      <button id="proceedToMatches" class="primary" disabled>Proceed to Match Setup</button>
    </div>
  </div>

  <!-- Manual Match Setup Section -->
<div id="manualMatchSection" class="section" style="display:none;">
  <div class="step-header">Step 5: Manual Match Setup (optional)</div>
  <div class="manual-match-setup">
    <div class="manual-match-header">
    
      <button id="toggleManualSetup" class="secondary">Setup Manual Match</button>
    </div>
      
      <div id="manualSetupPanel" style="display:none;">
        <div class="info-box">
          <h4>Create Special Matches</h4>
          <p>Set up demonstration matches, special requests, or exhibition games. These players will be excluded from automatic match generation.</p>
        </div>
        
        <div id="manualPlayerSelection">
          <h4>Available Players:</h4>
          <div id="manualPlayerGrid" class="manual-player-grid"></div>
        </div>
        
        <div class="team-formation">
          <div id="team1Slot" class="team-slot">
            <div class="team-slot-title">Team 1</div>
            <div id="team1Players"></div>
          </div>
          <div class="vs-divider">VS</div>
          <div id="team2Slot" class="team-slot">
            <div class="team-slot-title">Team 2</div>
            <div id="team2Players"></div>
          </div>
        </div>
        
        <div class="court-selector">
          <h4>Select Court:</h4>
          <div id="courtGrid" class="court-grid"></div>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
          <button id="addManualMatch" class="primary" disabled>Add Manual Match</button>
          <button id="clearManualSetup" class="secondary">Clear Setup</button>
        </div>
      </div>
      
      <div id="manualMatchesList" class="manual-matches-list"></div>
    </div>
    
    <div style="text-align: center; margin: 20px 0;">
      <button id="generateMatches" class="primary">Generate Remaining Matches</button>
    </div>
  </div>

  <!-- Results Section -->
<div id="matches" class="section" style="display:none;">
  <div class="step-header">Step 6: Generated Matches</div>
  <div style="margin-bottom: 15px;">
      <button id="downloadBtn" class="primary" style="background: #28a745;">📥 Download Results as Excel</button>
      <button id="printBtn" class="primary" style="background: #007acc; margin-left: 10px;">🖨️ Print Match Sheet</button>
    </div>
    <div id="matchResults"></div>
  </div>

<script>
// Global variables
let masterListData = [];
let availableCourts = [];
let playerRows = [];
let debugLog = [];
let currentData = null;
let currentMatches = null;
let allSetsData = {};
let currentSetNumber = 1;

// Manual match variables
let manualMatches = [];
let selectedManualPlayers = [];
let selectedCourt = null;
let manualTeam1 = [];
let manualTeam2 = [];

// Logging function
function log(message) {
  console.log(message);
  debugLog.push(message);
}
// Smooth scroll function
function scrollToElement(elementId) {
  const element = document.getElementById(elementId);
  if (element) {
    element.scrollIntoView({ 
      behavior: 'smooth', 
      block: 'start' 
    });
  }
}

// Grade translation function - converts numeric grades to club format
function translateGrade(numericGrade) {
  switch(numericGrade) {
    case 5: return '2';
    case 4: return '2A';
    case 3: return '2B';
    case 2: return '3';
    case 1: return '3B';
    default: return numericGrade; // fallback for any unexpected values
  }
}

// Initialize courts (37 courts: 1-27, H1-H10)
function initializeCourts() {
  const courtPool = document.getElementById('courtPool');
  courtPool.innerHTML = '';
  
  const courts = [];
  
  // Grass courts 1-27
  for (let i = 1; i <= 27; i++) {
    courts.push(i.toString());
  }
  
  // Hard courts H1-H10
  for (let i = 1; i <= 10; i++) {
    courts.push('H' + i);
  }
  
  courts.forEach(court => {
  const courtDiv = document.createElement('div');
  // Determine court type and add appropriate class
  const isHardCourt = court.toString().toUpperCase().startsWith('H');
  courtDiv.className = isHardCourt ? 'court-item hard-court' : 'court-item grass-court';
  courtDiv.textContent = court;
  courtDiv.draggable = true;
  courtDiv.dataset.court = court;
    
   courtDiv.addEventListener('dragstart', handleCourtDragStart);
courtDiv.addEventListener('dragend', handleCourtDragEnd);
courtDiv.addEventListener('click', () => moveCourtToSelected(court, courtDiv));

courtPool.appendChild(courtDiv);
  });
}

// Court drag and drop handlers
function handleCourtDragStart(e) {
  e.dataTransfer.setData('text/plain', e.target.dataset.court);
  e.target.classList.add('dragging');
}

function handleCourtDragEnd(e) {
  e.target.classList.remove('dragging');
}

// Available courts drag and drop
const availableCourtsDiv = document.getElementById('availableCourts');

availableCourtsDiv.addEventListener('dragover', (e) => {
  e.preventDefault();
  availableCourtsDiv.classList.add('drag-over');
});

availableCourtsDiv.addEventListener('dragleave', (e) => {
  availableCourtsDiv.classList.remove('drag-over');
});

availableCourtsDiv.addEventListener('drop', (e) => {
  e.preventDefault();
  availableCourtsDiv.classList.remove('drag-over');
  
  const court = e.dataTransfer.getData('text/plain');
  if (court && !availableCourts.includes(court)) {
    availableCourts.push(court);
    updateAvailableCourtsDisplay();
    
    // Remove from court pool
    const courtElement = document.querySelector(`[data-court="${court}"]`);
    if (courtElement && courtElement.parentElement.id === 'courtPool') {
      courtElement.remove();
    }
  }
});

function updateAvailableCourtsDisplay() {
  const availableCourtsDiv = document.getElementById('availableCourts');
  
  if (availableCourts.length === 0) {
    availableCourtsDiv.innerHTML = '<em style="color: #666;">Click courts below to add them in priority order...</em>';
    return;
  }
  
  availableCourtsDiv.innerHTML = '';
  
  availableCourts.forEach((court, index) => {
    const courtDiv = document.createElement('div');
const isHardCourt = court.toString().toUpperCase().startsWith('H');
courtDiv.className = isHardCourt ? 'court-item hard-court' : 'court-item grass-court';
    courtDiv.textContent = court;
    courtDiv.style.cursor = 'pointer';
    courtDiv.title = 'Click to remove from selection';
    
    // Allow removing courts by clicking
    courtDiv.addEventListener('click', () => {
      moveCourtBackToPool(court, index);
    });
    
    availableCourtsDiv.appendChild(courtDiv);
  });
}

function moveCourtBackToPool(court, index) {
  // Remove from available courts
  availableCourts.splice(index, 1);
  updateAvailableCourtsDisplay();
  
  // Add back to court pool with click functionality
  addCourtToPool(court);
}

function addCourtToPool(court) {
  const courtPool = document.getElementById('courtPool');
  const newCourtDiv = document.createElement('div');
  const isHardCourt = court.toString().toUpperCase().startsWith('H');
  newCourtDiv.className = isHardCourt ? 'court-item hard-court' : 'court-item grass-court';
  newCourtDiv.textContent = court;
  newCourtDiv.draggable = true;
  newCourtDiv.dataset.court = court;
  newCourtDiv.style.cursor = 'pointer';
  newCourtDiv.title = 'Click to add to selection, or drag to specific position';
  
  // Add drag functionality
  newCourtDiv.addEventListener('dragstart', handleCourtDragStart);
  newCourtDiv.addEventListener('dragend', handleCourtDragEnd);

  // Add click functionality  
  newCourtDiv.addEventListener('click', () => {
    if (!availableCourts.includes(court)) {
      moveCourtToSelected(court, newCourtDiv);
    }
  });
  
  // Insert in correct position instead of just appending
  const existingCourts = Array.from(courtPool.children);
  let insertPosition = existingCourts.length; // Default to end
  
  for (let i = 0; i < existingCourts.length; i++) {
    const existingCourt = existingCourts[i].dataset.court;
    if (shouldCourtComeBefore(court, existingCourt)) {
      insertPosition = i;
      break;
    }
  }
  
  if (insertPosition >= existingCourts.length) {
    courtPool.appendChild(newCourtDiv);
  } else {
    courtPool.insertBefore(newCourtDiv, existingCourts[insertPosition]);
  }
}

// Helper function to determine court order
function shouldCourtComeBefore(court1, court2) {
  const isHard1 = court1.toString().toUpperCase().startsWith('H');
  const isHard2 = court2.toString().toUpperCase().startsWith('H');
  
  // Grass courts (1-27) come before hard courts (H1-H10)
  if (!isHard1 && isHard2) return true;
  if (isHard1 && !isHard2) return false;
  
  // Both are same type, sort numerically
  if (!isHard1 && !isHard2) {
    // Both grass courts - numerical sort
    return parseInt(court1) < parseInt(court2);
  } else {
    // Both hard courts - extract number after H and sort
    const num1 = parseInt(court1.substring(1));
    const num2 = parseInt(court2.substring(1));
    return num1 < num2;
  }
}
  

function moveCourtToSelected(court, courtElement) {
  // Only add if not already selected
  if (!availableCourts.includes(court)) {
    availableCourts.push(court);
    updateAvailableCourtsDisplay();
    
    // Remove from court pool
    courtElement.remove();
  }
}

// Clear courts button
document.getElementById('clearCourts').addEventListener('click', () => {
  availableCourts = [];
  updateAvailableCourtsDisplay();
  initializeCourts();
});

// Master list load handler
document.getElementById('loadMembersBtn').addEventListener('click', function() {
  try {
    // Check if MEMBERS is available
    if (typeof MEMBERS === 'undefined') {
      document.getElementById('masterListStatus').innerHTML = 
        '<div class="error">❌ Member Master List.js file not found. Please ensure the file is in the same folder as this HTML file.</div>';
      return;
    }
    
    // Load members from the JavaScript file
    masterListData = MEMBERS.map(member => ({
      name: member.name,
      grade: member.grade,
      gender: member.gender,
      nhc: member.nhc
    }));
    
    document.getElementById('masterListStatus').innerHTML = 
      `<div class="success">✓ Loaded ${masterListData.length} players from member list</div>`;
    
    // Show player selection section
    document.getElementById('playerSelectionSection').style.display = 'block';
    initializePlayerTable();
    
  } catch (error) {
    document.getElementById('masterListStatus').innerHTML = 
      `<div class="error">Error loading member list: ${error.message}</div>`;
  }
});

// Initialize player table
function initializePlayerTable() {
  playerRows = [];
  const tbody = document.getElementById('playerTableBody');
  tbody.innerHTML = '';
  
  // Add initial 10 rows
  for (let i = 0; i < 10; i++) {
    addPlayerRow();
  }
  
  updateSitOffCalculation();
}

function addPlayerRow() {
  const tbody = document.getElementById('playerTableBody');
  const rowIndex = playerRows.length;
  
  const row = {
  name: '',
  grade: '',
  gender: '',
  nhc: false,
  resting: false,
  pso: false,
  so: false
};
  playerRows.push(row);
  
  const tr = document.createElement('tr');
tr.innerHTML = `
  <td style="position: relative;">
    <div style="display: flex; align-items: center; gap: 5px;">
      <input type="text" class="name-input" placeholder="Start typing name..." 
             data-row="${rowIndex}" autocomplete="off" style="flex: 1;">
      <button type="button" class="delete-player-btn" data-row="${rowIndex}" 
              style="background: #dc3545; color: white; border: none; border-radius: 3px; 
                     padding: 3px 6px; font-size: 12px; cursor: pointer; display: none;"
              title="Remove player">×</button>
    </div>
    <div class="autocomplete-suggestions" id="suggestions-${rowIndex}" style="display: none;"></div>
  </td>
  <td>
    <select class="grade-select" id="grade-${rowIndex}" data-row="${rowIndex}">
      <option value="">-</option>
      <option value="5">5</option>
      <option value="4">4</option>
      <option value="3">3</option>
      <option value="2">2</option>
      <option value="1">1</option>
    </select>
  </td>
  <td>
    <select class="gender-select" id="gender-${rowIndex}" data-row="${rowIndex}">
      <option value="">-</option>
      <option value="M">M</option>
      <option value="F">F</option>
    </select>
  </td>
  <td class="checkbox-cell">
    <input type="checkbox" class="status-checkbox" id="nhc-${rowIndex}" data-row="${rowIndex}">
  </td>
  <td class="checkbox-cell">
    <input type="checkbox" class="status-checkbox" id="resting-${rowIndex}" data-row="${rowIndex}">
  </td>
 <td class="checkbox-cell">
<input type="checkbox" class="status-checkbox" id="pso-${rowIndex}" data-row="${rowIndex}">
</td>
<td class="checkbox-cell">
<input type="checkbox" class="status-checkbox" id="so-${rowIndex}" data-row="${rowIndex}">
</td>
`;
  
  tbody.appendChild(tr);
  
  // Add event listeners
  const nameInput = tr.querySelector('.name-input');
  nameInput.addEventListener('input', (e) => handleNameInput(e, rowIndex));
  nameInput.addEventListener('keydown', (e) => handleNameKeydown(e, rowIndex));
  nameInput.addEventListener('blur', (e) => setTimeout(() => hideSuggestions(rowIndex), 150));

// Add event listener for manual name entry (visitors)
nameInput.addEventListener('input', (e) => {
  // Update the playerRows data when someone types manually
  playerRows[rowIndex].name = e.target.value;
  
  // Show delete button if player has name, grade, and gender
  const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
  if (e.target.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
    deleteBtn.style.display = 'block';
  } else {
    deleteBtn.style.display = 'none';
  }
  
  // Update calculations
  updateSitOffCalculation();
  updateProceedButton();
});
  
  const restingCheckbox = tr.querySelector(`#resting-${rowIndex}`);
  restingCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].resting = e.target.checked;
    updateSitOffCalculation();
  });
  
  const psoCheckbox = tr.querySelector(`#pso-${rowIndex}`);
  psoCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].pso = e.target.checked;
  });
const soCheckbox = tr.querySelector(`#so-${rowIndex}`);
soCheckbox.addEventListener('change', (e) => {
  playerRows[rowIndex].so = e.target.checked;
  updateSitOffCalculation();
  updateProceedButton();
});

const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
deleteBtn.addEventListener('click', () => {
  clearPlayerRow(rowIndex);
});
// Add event listeners for manual editing
const gradeSelect = tr.querySelector(`#grade-${rowIndex}`);
gradeSelect.addEventListener('change', (e) => {
playerRows[rowIndex].grade = e.target.value === '' ? '' : parseInt(e.target.value);
  // Show delete button if player has name, grade, and gender
  const nameInput = tr.querySelector('.name-input');
  const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
  if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
    deleteBtn.style.display = 'block';
  }
  updateSitOffCalculation();
  updateProceedButton();
});

const genderSelect = tr.querySelector(`#gender-${rowIndex}`);
genderSelect.addEventListener('change', (e) => {
  playerRows[rowIndex].gender = e.target.value;
  // Show delete button if player has name, grade, and gender
  const nameInput = tr.querySelector('.name-input');
  const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
  if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
    deleteBtn.style.display = 'block';
  }
  updateSitOffCalculation();
  updateProceedButton();
});

const nhcCheckbox = tr.querySelector(`#nhc-${rowIndex}`);
nhcCheckbox.addEventListener('change', (e) => {
  playerRows[rowIndex].nhc = e.target.checked;
});

}

function handleNameInput(e, rowIndex) {
  const input = e.target.value.toLowerCase();
  const suggestionsDiv = document.getElementById(`suggestions-${rowIndex}`);
  
  if (input.length === 0) {
    hideSuggestions(rowIndex);
    return;
  }
  
  // Get list of already used names (excluding current row)
  const usedNames = playerRows
    .map((p, index) => index !== rowIndex ? p.name : null)
    .filter(name => name && name.trim() !== '');
    
  const matches = masterListData.filter(player => 
  player.name.toLowerCase().includes(input) &&
  !usedNames.includes(player.name) // Exclude already used names
).sort((a, b) => a.name.localeCompare(b.name)) // Sort alphabetically by name
.slice(0, 10); // Limit to 10 suggestions
  
  if (matches.length === 0) {
    hideSuggestions(rowIndex);
    return;
  }
  
  suggestionsDiv.innerHTML = '';
  matches.forEach((player, index) => {
    const suggestionDiv = document.createElement('div');
    suggestionDiv.className = 'autocomplete-suggestion';
    if (index === 0) suggestionDiv.classList.add('selected'); // Auto-select first item
    suggestionDiv.textContent = `${player.name} (${player.grade})`;
    suggestionDiv.addEventListener('click', () => selectPlayer(rowIndex, player));
    suggestionsDiv.appendChild(suggestionDiv);
  });
  
  suggestionsDiv.style.display = 'block';
}
function handleNameKeydown(e, rowIndex) {
  const suggestionsDiv = document.getElementById(`suggestions-${rowIndex}`);
  const suggestions = suggestionsDiv.querySelectorAll('.autocomplete-suggestion');
  
  if (suggestions.length === 0) return;
  
  let selectedIndex = -1;
  // Find currently selected suggestion
  suggestions.forEach((suggestion, index) => {
    if (suggestion.classList.contains('selected')) {
      selectedIndex = index;
    }
  });
  
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    // Remove current selection
    if (selectedIndex >= 0) {
      suggestions[selectedIndex].classList.remove('selected');
    }
    // Select next item (or first if none selected)
    selectedIndex = selectedIndex < suggestions.length - 1 ? selectedIndex + 1 : 0;
    suggestions[selectedIndex].classList.add('selected');
    suggestions[selectedIndex].scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    // Remove current selection
    if (selectedIndex >= 0) {
      suggestions[selectedIndex].classList.remove('selected');
    }
    // Select previous item (or last if none selected)
    selectedIndex = selectedIndex > 0 ? selectedIndex - 1 : suggestions.length - 1;
    suggestions[selectedIndex].classList.add('selected');
    suggestions[selectedIndex].scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'Enter') {
    e.preventDefault();
    // If something is selected, click it; otherwise click the first suggestion
    const targetSuggestion = selectedIndex >= 0 ? suggestions[selectedIndex] : suggestions[0];
    if (targetSuggestion) {
      targetSuggestion.click();
    }
  } else if (e.key === 'Escape') {
    hideSuggestions(rowIndex);
  }
}
function selectPlayer(rowIndex, player) {
 playerRows[rowIndex] = {
  name: player.name,
  grade: player.grade,
  gender: player.gender,
  nhc: player.nhc,
  resting: playerRows[rowIndex].resting,
  pso: playerRows[rowIndex].pso,
  so: playerRows[rowIndex].so
};
  
// Update the UI
  document.querySelector(`[data-row="${rowIndex}"]`).value = player.name;
  document.getElementById(`grade-${rowIndex}`).value = player.grade;
  document.getElementById(`gender-${rowIndex}`).value = player.gender;
  document.getElementById(`nhc-${rowIndex}`).checked = player.nhc;
  
// Show the delete button
document.querySelector(`[data-row="${rowIndex}"].delete-player-btn`).style.display = 'block';

hideSuggestions(rowIndex);
updateSitOffCalculation();
updateProceedButton();

// Auto-focus next empty name field
setTimeout(() => {
  for (let i = rowIndex + 1; i < playerRows.length; i++) {
    if (!playerRows[i].name || playerRows[i].name.trim() === '') {
      const nextInput = document.querySelector(`[data-row="${i}"]`);
      if (nextInput) {
        nextInput.focus();
        break;
      }
    }
  }
}, 100);
}
function clearPlayerRow(rowIndex) {
  // Clear the player data
  playerRows[rowIndex] = {
    name: '',
    grade: '',
    gender: '',
    nhc: false,
    resting: false,
    pso: false,
    so: false
  };
  
// Clear the UI
  document.querySelector(`[data-row="${rowIndex}"]`).value = '';
  document.getElementById(`grade-${rowIndex}`).value = '';
  document.getElementById(`gender-${rowIndex}`).value = '';
  document.getElementById(`nhc-${rowIndex}`).checked = false;
  document.getElementById(`resting-${rowIndex}`).checked = false;
  document.getElementById(`pso-${rowIndex}`).checked = false;
  document.getElementById(`so-${rowIndex}`).checked = false;
  
  // Hide the delete button
  document.querySelector(`[data-row="${rowIndex}"].delete-player-btn`).style.display = 'none';
  
  // Update calculations
  updateSitOffCalculation();
  updateProceedButton();
}

function hideSuggestions(rowIndex) {
  const suggestionsDiv = document.getElementById(`suggestions-${rowIndex}`);
  suggestionsDiv.style.display = 'none';
}

function updateSitOffCalculation() {
  const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting);
  const soPlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting && p.so);
  const totalActivePlayers = activePlayers.length;
  const totalNeededToSitOff = totalActivePlayers % 4;
  const alreadySelectedToSitOff = soPlayers.length;
  const remainingToSelect = Math.max(0, totalNeededToSitOff - alreadySelectedToSitOff);
  
  const sitOffElement = document.getElementById('sitOffCount');
  const calculatorElement = document.getElementById('sitOffCalculator');
  
  sitOffElement.textContent = remainingToSelect;
  
  // Update styling based on remaining count
  calculatorElement.className = 'sit-off-calculator';
  if (totalNeededToSitOff === 0) {
    calculatorElement.classList.add('sit-off-good');
  } else if (remainingToSelect === 0) {
    calculatorElement.classList.add('sit-off-good');
  } else {
    // Keep default styling when players still need to be selected
  }
}
function updateProceedButton() {
 const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting);
const soPlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting && p.so);
  const proceedBtn = document.getElementById('proceedToMatches');
  
  if (activePlayers.length >= 4 && availableCourts.length > 0) {
    const totalActivePlayers = activePlayers.length;
    const sitOffNeeded = totalActivePlayers % 4;
    const sitOffSelected = soPlayers.length;
    
    if (sitOffNeeded === 0 && sitOffSelected === 0) {
      // No sit-offs needed, none selected - perfect
      proceedBtn.disabled = false;
      proceedBtn.textContent = 'Proceed to Match Setup';
    } else if (sitOffNeeded > 0 && sitOffSelected === sitOffNeeded) {
      // Sit-offs needed and correct number selected
      proceedBtn.disabled = false;
      proceedBtn.textContent = 'Proceed to Match Setup';
    } else if (sitOffNeeded > 0 && sitOffSelected < sitOffNeeded) {
      // Need more selections
      const needed = sitOffNeeded - sitOffSelected;
      proceedBtn.disabled = true;
      proceedBtn.textContent = `Select ${needed} more to sit off`;
    } else if (sitOffNeeded > 0 && sitOffSelected > sitOffNeeded) {
      // Too many selected
      const excess = sitOffSelected - sitOffNeeded;
      proceedBtn.disabled = true;
      proceedBtn.textContent = `Remove ${excess} sit-off selections`;
    } else if (sitOffNeeded === 0 && sitOffSelected > 0) {
      // No sit-offs needed but some selected
      proceedBtn.disabled = true;
      proceedBtn.textContent = `Remove ${sitOffSelected} sit-off selections (none needed)`;
    }
  } else {
    proceedBtn.disabled = true;
    proceedBtn.textContent = 'Proceed to Match Setup';
  }
}
// Add more rows button
document.getElementById('addMoreRows').addEventListener('click', () => {
  for (let i = 0; i < 10; i++) {
    addPlayerRow();
  }
});
// Set number change handler
document.getElementById('setNumberSelector').addEventListener('change', function() {
  const newSetNumber = parseInt(this.value);
  const previousSetNumber = newSetNumber - 1;
  
  // If moving to set 2 or higher, move SO players to PSO
  if (newSetNumber > 1 && allSetsData[previousSetNumber]) {
    const previousSatOffPlayers = allSetsData[previousSetNumber].satOffPlayers || [];
    
    // Update player data: move SO to PSO for previously sat-off players
    playerRows.forEach((player, index) => {
      if (previousSatOffPlayers.includes(player.name)) {
        // Move from SO to PSO
        player.so = false;
        player.pso = true;
        
        // Update the UI checkboxes
        const soCheckbox = document.getElementById(`so-${index}`);
        const psoCheckbox = document.getElementById(`pso-${index}`);
        
        if (soCheckbox) soCheckbox.checked = false;
        if (psoCheckbox) psoCheckbox.checked = true;
      }
    });
    
    console.log(`Moved ${previousSatOffPlayers.length} players from SO to PSO for Set ${newSetNumber}`);
  }
  
  // Reset current set SO selections and validation
  playerRows.forEach((player, index) => {
    if (!player.pso) { // Don't reset PSO players
      player.so = false;
      const soCheckbox = document.getElementById(`so-${index}`);
      if (soCheckbox) soCheckbox.checked = false;
    }
  });
  
  // Update calculations and button state
  updateSitOffCalculation();
  updateProceedButton();
  
  // Hide any open sections
  document.getElementById('manualMatchSection').style.display = 'none';
  document.getElementById('matches').style.display = 'none';
});

// Proceed to matches button
document.getElementById('proceedToMatches').addEventListener('click', () => {
  processPlayersAndProceed();
  // Scroll to manual match section after a brief delay
  setTimeout(() => {
    scrollToElement('manualMatchSection');
  }, 100);
});

function processPlayersAndProceed() {
  // Create data structure similar to original format
const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting && !p.so);
  
  const availableMen = activePlayers.filter(p => p.gender === 'M');
  const availableWomen = activePlayers.filter(p => p.gender === 'F');
  
  // Create courts data structure
  const courts = availableCourts.map((court, index) => ({
    priority: index + 1,
    court: court
  }));
  
  currentData = {
    setFormatPreference: document.getElementById('formatSelector').value,
    availableMen: availableMen,
    availableWomen: availableWomen,
    courts: courts
  };
  
  console.log('Processed data:', currentData);
  
  // Show manual match setup directly
  setupManualMatchInterface(currentData);
  document.getElementById('manualMatchSection').style.display = 'block';
}

  
 
// Manual match setup functions
function setupManualMatchInterface(data) {
  const playerGrid = document.getElementById('manualPlayerGrid');
  const courtGrid = document.getElementById('courtGrid');
  
  // Clear previous setup
  playerGrid.innerHTML = '';
  courtGrid.innerHTML = '';
  manualMatches = [];
  updateManualMatchDisplay();
  
  // Populate available players
  const allPlayers = [];
  data.availableMen.forEach(p => allPlayers.push({...p, gender: 'M'}));
  data.availableWomen.forEach(p => allPlayers.push({...p, gender: 'F'}));
  
  allPlayers.sort((a, b) => {
    if (b.grade !== a.grade) return b.grade - a.grade;
    return a.name.localeCompare(b.name);
  });
  
  allPlayers.forEach(player => {
    const playerDiv = document.createElement('div');
    playerDiv.className = 'manual-player-item';
    playerDiv.innerHTML = `${player.name} (${translateGrade(player.grade)})`;
    playerDiv.dataset.playerName = player.name;
    playerDiv.dataset.playerGrade = player.grade;
    playerDiv.dataset.playerGender = player.gender;
    
    playerDiv.addEventListener('click', () => selectPlayerForManualMatch(playerDiv, player));
    playerGrid.appendChild(playerDiv);
  });
  
 // Populate available courts
data.courts.forEach(courtData => {
  const courtDiv = document.createElement('div');
  courtDiv.className = 'court-option';
  courtDiv.innerHTML = `Court ${courtData.court}`;
  courtDiv.dataset.court = courtData.court;
  
  courtDiv.addEventListener('click', () => selectCourtForManualMatch(courtDiv, courtData.court));
  courtGrid.appendChild(courtDiv);
});
}

function selectPlayerForManualMatch(element, player) {
  if (element.classList.contains('excluded')) return;
  
  if (element.classList.contains('selected')) {
    // Deselect player
    element.classList.remove('selected');
    selectedManualPlayers = selectedManualPlayers.filter(p => p.name !== player.name);
    removePlayerFromTeams(player.name);
  } else {
    // Select player (max 4)
    if (selectedManualPlayers.length >= 4) {
      alert('Maximum 4 players can be selected for a match');
      return;
    }
    
    element.classList.add('selected');
    selectedManualPlayers.push(player);
    addPlayerToTeam(player);
  }
  
  updateTeamDisplay();
  updateAddMatchButton();
}

function addPlayerToTeam(player) {
  if (manualTeam1.length < 2) {
    manualTeam1.push(player);
  } else {
    manualTeam2.push(player);
  }
}

function removePlayerFromTeams(playerName) {
  manualTeam1 = manualTeam1.filter(p => p.name !== playerName);
  manualTeam2 = manualTeam2.filter(p => p.name !== playerName);
}

function updateTeamDisplay() {
  const team1Div = document.getElementById('team1Players');
  const team2Div = document.getElementById('team2Players');
  
  team1Div.innerHTML = manualTeam1.map(p => 
`<div class="team-player">${p.name} (${translateGrade(p.grade)}, ${p.gender})</div>`
  ).join('');
  
  team2Div.innerHTML = manualTeam2.map(p => 
    `<div class="team-player">${p.name} (${translateGrade(p.grade)}, ${p.gender})</div>`
  ).join('');
  
  // Update team slot styling
  document.getElementById('team1Slot').classList.toggle('has-players', manualTeam1.length > 0);
  document.getElementById('team2Slot').classList.toggle('has-players', manualTeam2.length > 0);
}

function selectCourtForManualMatch(element, court) {
  if (element.classList.contains('excluded')) return;
  
  // Clear previous selection
  document.querySelectorAll('.court-option').forEach(el => el.classList.remove('selected'));
  
  // Select new court
  element.classList.add('selected');
  selectedCourt = court;
  updateAddMatchButton();
}

function updateAddMatchButton() {
  const addBtn = document.getElementById('addManualMatch');
  const canAdd = selectedManualPlayers.length === 4 && 
                 manualTeam1.length === 2 && 
                 manualTeam2.length === 2 && 
                 selectedCourt !== null;
  
  addBtn.disabled = !canAdd;
  
  if (canAdd) {
    addBtn.textContent = `Add Match: Court ${selectedCourt}`;
  } else {
    addBtn.textContent = 'Add Manual Match';
  }
}

function addManualMatch() {
  if (selectedManualPlayers.length !== 4 || !selectedCourt) return;
  
  // Determine match format
  const team1Men = manualTeam1.filter(p => p.gender === 'M').length;
  const team1Women = manualTeam1.filter(p => p.gender === 'F').length;
  const team2Men = manualTeam2.filter(p => p.gender === 'M').length;
  const team2Women = manualTeam2.filter(p => p.gender === 'F').length;
  
  let format;
  if (team1Men === 1 && team1Women === 1 && team2Men === 1 && team2Women === 1) {
    format = "Mixed Doubles";
  } else if (team1Men === 2 && team2Men === 2) {
    format = "Same-Sex Doubles (Men)";
  } else if (team1Women === 2 && team2Women === 2) {
    format = "Same-Sex Doubles (Women)";
  } else {
    format = "Mixed Gender";
  }
  
  const manualMatch = {
    court: selectedCourt,
    team1: [...manualTeam1],
    team2: [...manualTeam2],
    format: format,
    note: "Manual Setup",
    isManual: true
  };
  
  manualMatches.push(manualMatch);
  
  // Mark players as excluded
  selectedManualPlayers.forEach(player => {
    const playerElement = document.querySelector(`[data-player-name="${player.name}"]`);
    if (playerElement) {
      playerElement.classList.remove('selected');
      playerElement.classList.add('excluded');
    }
  });
  
  // Mark court as excluded
  const courtElement = document.querySelector(`[data-court="${selectedCourt}"]`);
  if (courtElement) {
    courtElement.classList.remove('selected');
    courtElement.classList.add('excluded');
  }
  
  // Clear selection
  selectedManualPlayers = [];
  selectedCourt = null;
  manualTeam1 = [];
  manualTeam2 = [];
  
  updateTeamDisplay();
  updateAddMatchButton();
  updateManualMatchDisplay();
  
  console.log(`Manual match added: Court ${manualMatch.court} - ${format}`);
}

function updateManualMatchDisplay() {
  const listDiv = document.getElementById('manualMatchesList');
  
  if (manualMatches.length === 0) {
    listDiv.innerHTML = '<p style="color: #666; font-style: italic;">No manual matches set up yet.</p>';
    return;
  }
  
  let html = '<h4>Manual Matches:</h4>';
  
  manualMatches.forEach((match, index) => {
    const team1Str = match.team1.map(p => `${p.name} (${p.grade})`).join(', ');
    const team2Str = match.team2.map(p => `${p.name} (${p.grade})`).join(', ');
    
    html += `
      <div class="manual-match-item">
        <div class="manual-match-details">
          <div class="manual-match-court">Court ${match.court}</div>
          <div class="manual-match-teams">${team1Str} vs ${team2Str}</div>
          <div style="font-size: 12px; color: #666;">${match.format}</div>
        </div>
        <button class="danger" onclick="removeManualMatch(${index})">Remove</button>
      </div>
    `;
  });
  
  listDiv.innerHTML = html;
}

function removeManualMatch(index) {
  const removedMatch = manualMatches[index];
  
  // Restore players as available
  [...removedMatch.team1, ...removedMatch.team2].forEach(player => {
    const playerElement = document.querySelector(`[data-player-name="${player.name}"]`);
    if (playerElement) {
      playerElement.classList.remove('excluded');
    }
  });
  
  // Restore court as available
  const courtElement = document.querySelector(`[data-court="${removedMatch.court}"]`);
  if (courtElement) {
    courtElement.classList.remove('excluded');
  }
  
  manualMatches.splice(index, 1);
  updateManualMatchDisplay();
  
  console.log(`Manual match removed: Court ${removedMatch.court}`);
}

function clearManualSetup() {
  // Clear all selections
  document.querySelectorAll('.manual-player-item').forEach(el => {
    el.classList.remove('selected', 'excluded');
  });
  document.querySelectorAll('.court-option').forEach(el => {
    el.classList.remove('selected', 'excluded');
  });
  
  selectedManualPlayers = [];
  selectedCourt = null;
  manualTeam1 = [];
  manualTeam2 = [];
  
  updateTeamDisplay();
  updateAddMatchButton();
}

// Event handlers for manual match setup
document.getElementById('toggleManualSetup').addEventListener('click', function() {
  const panel = document.getElementById('manualSetupPanel');
  const isVisible = panel.style.display !== 'none';
  
  panel.style.display = isVisible ? 'none' : 'block';
  this.textContent = isVisible ? 'Setup Manual Match' : 'Hide Manual Setup';
});

document.getElementById('addManualMatch').addEventListener('click', addManualMatch);
document.getElementById('clearManualSetup').addEventListener('click', clearManualSetup);

// Generate matches button
document.getElementById('generateMatches').addEventListener('click', () => {
  processMatchesWithManualSetup();
  // Scroll to results section after a brief delay
  setTimeout(() => {
    scrollToElement('matches');
  }, 500); // Slightly longer delay to allow for match generation
});

function processMatchesWithManualSetup() {
  // Remove manual match players from available pools
  const excludedPlayers = [];
  const excludedCourts = [];
  
  manualMatches.forEach(match => {
    match.team1.forEach(p => excludedPlayers.push(p.name));
    match.team2.forEach(p => excludedPlayers.push(p.name));
    excludedCourts.push(match.court);
  });
  
  // Filter out excluded players
  const adjustedData = {
    ...currentData,
    availableMen: currentData.availableMen.filter(p => !excludedPlayers.includes(p.name)),
    availableWomen: currentData.availableWomen.filter(p => !excludedPlayers.includes(p.name)),
    courts: currentData.courts.filter(c => !excludedCourts.includes(c.court))
  };
  
  console.log(`Excluded ${excludedPlayers.length} players and ${excludedCourts.length} courts for manual matches`);
  
  const totalRemainingPlayers = adjustedData.availableMen.length + adjustedData.availableWomen.length;
  const remainder = totalRemainingPlayers % 4;
  
  if (remainder === 0) {
  // Don't overwrite currentData - keep the original for Excel export
  const dataForMatching = adjustedData;
  processMatchesWithAdjustedData(dataForMatching);
} else {
  alert(`Cannot proceed: ${remainder} players remaining after manual matches. Need multiple of 4.`);
}
}

// Match generation functions (from original code)
// Original processMatches function (for when no manual matches)
function processMatches() {
  log("=== STARTING MATCH FORMATION ===");
  
  const sortedData = sortPlayers(currentData);
  const matches = formMatchesStrict(sortedData);
  const balancedMatches = matches.map(match => balanceTeamsIfNeeded(match));
  const finalMatches = processCourtPreferences(sortedData, balancedMatches);
 
// Auto-fix repeat partnerships before display
  const optimizedMatches = autoFixRepeatPartnerships(sortedData, finalMatches);

  // NEW: Final competitiveness optimization
  const competitiveMatches = fixUncompetitiveMatches(sortedData, optimizedMatches);

  // NEW: Final individual match balancing
  const finalBalancedMatches = balanceIndividualMatches(sortedData, competitiveMatches);

  currentData = sortedData;
  currentMatches = finalBalancedMatches;
  displayResults(sortedData, finalBalancedMatches);
}
// New function for processing with adjusted data (after manual matches)

function processMatchesWithAdjustedData(adjustedData) {
  log("=== STARTING MATCH FORMATION (ADJUSTED FOR MANUAL MATCHES) ===");
  
  const sortedData = sortPlayers(adjustedData);
  const matches = formMatchesStrict(sortedData);
  const balancedMatches = matches.map(match => balanceTeamsIfNeeded(match));
  const finalMatches = processCourtPreferences(sortedData, balancedMatches);
  const optimizedMatches = autoFixRepeatPartnerships(sortedData, finalMatches);

 // NEW: Final competitiveness optimization
  const competitiveMatches = fixUncompetitiveMatches(sortedData, optimizedMatches);

  // NEW: Final individual match balancing  
  const individuallyBalancedMatches = balanceIndividualMatches(sortedData, competitiveMatches);

  currentMatches = individuallyBalancedMatches;
  // Use original currentData for display/export, but show generated matches
  displayResults(currentData, individuallyBalancedMatches);
}
function sortPlayers(data) {
  const sortedMen = data.availableMen.sort((a, b) => b.grade - a.grade);
  const sortedWomen = data.availableWomen.sort((a, b) => b.grade - a.grade);
  
  // Rotate players within each grade based on set number for variety
  const setNumber = parseInt(document.getElementById('setNumberSelector').value);
  const setFormat = document.getElementById('formatSelector').value;

  // Skip rotation for Mixed Doubles sets - they naturally provide variety
  let rotateAmount = 0;
  if (setFormat === "Same-Sex") {
    // Count only the Same-Sex sets for rotation calculation
    let sameSexSetCount = 0;
    for (let i = 1; i <= setNumber; i++) {
      if (allSetsData[i] && allSetsData[i].data.setFormatPreference === "Same-Sex") {
        sameSexSetCount++;
      } else if (i === setNumber) {
        sameSexSetCount++; // Current set
      }
    }
    rotateAmount = (sameSexSetCount - 1) % 10;
  }
  
  // Rotate men within each grade
  for (let grade = 5; grade >= 1; grade--) {
    const gradeGroup = sortedMen.filter(p => p.grade === grade);
    if (gradeGroup.length > 1 && rotateAmount > 0) {
      const actualRotation = rotateAmount % gradeGroup.length;
      const rotated = [...gradeGroup.slice(actualRotation), ...gradeGroup.slice(0, actualRotation)];
      
      // Replace the original players with rotated ones
      let gradeIndex = 0;
      for (let i = 0; i < sortedMen.length; i++) {
        if (sortedMen[i].grade === grade) {
          sortedMen[i] = rotated[gradeIndex++];
        }
      }
    }
  }
  
  // Rotate women within each grade
  for (let grade = 5; grade >= 1; grade--) {
    const gradeGroup = sortedWomen.filter(p => p.grade === grade);
    if (gradeGroup.length > 1 && rotateAmount > 0) {
      const actualRotation = rotateAmount % gradeGroup.length;
      const rotated = [...gradeGroup.slice(actualRotation), ...gradeGroup.slice(0, actualRotation)];
      
      // Replace the original players with rotated ones
      let gradeIndex = 0;
      for (let i = 0; i < sortedWomen.length; i++) {
        if (sortedWomen[i].grade === grade) {
          sortedWomen[i] = rotated[gradeIndex++];
        }
      }
    }
  }
  
  log("Applied rotation amount: " + rotateAmount + " for Set " + setNumber);

  log("=== SORTED PLAYERS ===");
  for (let grade = 5; grade >= 1; grade--) {
    const menCount = sortedMen.filter(p => p.grade === grade).length;
    const womenCount = sortedWomen.filter(p => p.grade === grade).length;
    if (menCount > 0 || womenCount > 0) {
      log("Grade " + grade + ": " + menCount + " men, " + womenCount + " women");
    }
  }

  return { ...data, sortedMen, sortedWomen };
}

function formMatchesStrict(data) {
  log("=== STRICT MATCH FORMATION ===");
  
  if (data.setFormatPreference === "Mixed") {
    return formMixedDoublesMatches(data);
  } else {
    return formSameSexDoublesMatches(data);
  }
}

function formMixedDoublesMatches(data) {
  log("Using Mixed Doubles Logic");
  
  const matches = [];
  const assigned = new Set();
  let courtIndex = 0;

  const createMatch = (team1, team2, format, note) => {
    if (courtIndex >= data.courts.length) {
      log("ERROR: No more courts available");
      return null;
    }

    const t1Men = team1.filter(p => data.sortedMen.find(m => m.name === p.name)).length;
    const t1Women = team1.filter(p => data.sortedWomen.find(w => w.name === p.name)).length;
    const t2Men = team2.filter(p => data.sortedMen.find(m => m.name === p.name)).length;
    const t2Women = team2.filter(p => data.sortedWomen.find(w => w.name === p.name)).length;

    if ((t1Men === 2 && t1Women === 0 && t2Men === 0 && t2Women === 2) ||
        (t1Men === 0 && t1Women === 2 && t2Men === 2 && t2Women === 0)) {
      log("ERROR: Attempted prohibited 2M vs 2W match");
      return null;
    }

    const court = data.courts[courtIndex].court;
    courtIndex++;

    team1.forEach(p => assigned.add(p.name));
    team2.forEach(p => assigned.add(p.name));

    log("Created match on Court " + court + ": " + 
        team1.map(p => p.name + "(" + p.grade + ")").join(",") + " vs " +
        team2.map(p => p.name + "(" + p.grade + ")").join(",") + " - " + format);

    return { court, team1, team2, format, note };
  };

  for (let targetGrade = 5; targetGrade >= 1; targetGrade--) {
    log("=== PROCESSING GRADE " + targetGrade + " ===");
    
    // ENHANCED: Check for cross-grade balancing opportunity first
const unassignedMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
const unassignedWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
const lowerMen = data.sortedMen.filter(p => p.grade === (targetGrade - 1) && !assigned.has(p.name));
const lowerWomen = data.sortedWomen.filter(p => p.grade === (targetGrade - 1) && !assigned.has(p.name));

// If we have exactly 1M+1W of current grade and 1M+1W of lower grade, create balanced match
if (unassignedMen.length === 1 && unassignedWomen.length === 1 && 
    lowerMen.length >= 1 && lowerWomen.length >= 1) {
  const match = createMatch(
    [unassignedMen[0], lowerWomen[0]],
    [lowerMen[0], unassignedWomen[0]],
    "Mixed Doubles",
    "Cross-grade balanced"
  );
  if (match) {
    matches.push(match);
    continue; // Process next grade
  }
}

// Normal in-grade processing
while (true) {
  const currentMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
  const currentWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
  
  if (currentMen.length >= 2 && currentWomen.length >= 2) {
    const match = createMatch(
      [currentMen[0], currentWomen[0]],
      [currentMen[1], currentWomen[1]],
      "Mixed Doubles",
      "In-grade"
    );
    if (match) matches.push(match);
  } else {
    break;
  }
}

    log("MANDATORY COMPLETION: All Grade " + targetGrade + " players must be assigned");
    
    let attempts = 0;
    while (attempts < 100) {
      attempts++;
      
      const remainingMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      const remainingWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      
      if (remainingMen.length === 0 && remainingWomen.length === 0) {
        log("✓ SUCCESS: ALL Grade " + targetGrade + " players assigned");
        break;
      }

      const lowerMen = data.sortedMen.filter(p => p.grade < targetGrade && !assigned.has(p.name));
      const lowerWomen = data.sortedWomen.filter(p => p.grade < targetGrade && !assigned.has(p.name));

      log("Attempt " + attempts + ": Grade " + targetGrade + " remaining: " + 
          remainingMen.length + "M + " + remainingWomen.length + "W");
      log("Available lower: " + lowerMen.length + "M + " + lowerWomen.length + "W");

      let matchCreated = false;

      if (remainingMen.length >= 4) {
        const match = createMatch(
          [remainingMen[0], remainingMen[1]],
          [remainingMen[2], remainingMen[3]],
          "Same-Sex Doubles (Men)",
          "Mandatory completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 4) {
        const match = createMatch(
          [remainingWomen[0], remainingWomen[1]],
          [remainingWomen[2], remainingWomen[3]],
          "Same-Sex Doubles (Women)",
          "Mandatory completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length === 3 && remainingWomen.length >= 1) {
        const match = createMatch(
          [remainingMen[0], remainingWomen[0]],
          [remainingMen[1], remainingMen[2]],
          "Mixed Gender",
          "Mandatory completion 3M+1W"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length === 3 && remainingMen.length >= 1) {
        const match = createMatch(
          [remainingMen[0], remainingWomen[0]],
          [remainingWomen[1], remainingWomen[2]],
          "Mixed Gender",
          "Mandatory completion 1M+3W"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 2 && lowerWomen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerWomen[0]],
          [remainingMen[1], lowerWomen[1]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 2 && lowerMen.length >= 2) {
        const match = createMatch(
          [lowerMen[0], remainingWomen[0]],
          [lowerMen[1], remainingWomen[1]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 1 && lowerMen.length >= 3) {
        const match = createMatch(
          [remainingMen[0], lowerMen[0]],
          [lowerMen[1], lowerMen[2]],
          "Same-Sex Doubles (Men)",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 1 && lowerWomen.length >= 3) {
        const match = createMatch(
          [remainingWomen[0], lowerWomen[0]],
          [lowerWomen[1], lowerWomen[2]],
          "Same-Sex Doubles (Women)",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 1 && lowerMen.length >= 1 && lowerWomen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerWomen[0]],
          [lowerMen[0], lowerWomen[1]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 1 && lowerWomen.length >= 1 && lowerMen.length >= 2) {
        const match = createMatch(
          [lowerMen[0], remainingWomen[0]],
          [lowerMen[1], lowerWomen[0]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }

      if (!matchCreated) {
        log("❌ CRITICAL ERROR: Cannot complete Grade " + targetGrade);
        log("Remaining target players: " + 
            remainingMen.map(p => p.name).join(",") + " | " + 
            remainingWomen.map(p => p.name).join(","));
        log("Available lower players: " + lowerMen.length + "M + " + lowerWomen.length + "W");
        break;
      }
    }
  }

  log("=== FINAL CLEANUP PHASE ===");
  let cleanupAttempts = 0;
  while (cleanupAttempts < 20) {
    cleanupAttempts++;
    
    const allUnassignedMen = data.sortedMen.filter(p => !assigned.has(p.name));
    const allUnassignedWomen = data.sortedWomen.filter(p => !assigned.has(p.name));
    
    if (allUnassignedMen.length === 0 && allUnassignedWomen.length === 0) {
      log("✓ CLEANUP SUCCESS: All players assigned");
      break;
    }
    
    log("Cleanup attempt " + cleanupAttempts + ": " + allUnassignedMen.length + "M + " + allUnassignedWomen.length + "W remaining");
    
    let cleanupMatchCreated = false;
    
    if (allUnassignedMen.length >= 4) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedMen[1]],
        [allUnassignedMen[2], allUnassignedMen[3]],
        "Same-Sex Doubles (Men)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length >= 4) {
      const match = createMatch(
        [allUnassignedWomen[0], allUnassignedWomen[1]],
        [allUnassignedWomen[2], allUnassignedWomen[3]],
        "Same-Sex Doubles (Women)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length >= 2 && allUnassignedWomen.length >= 2) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedWomen[1]],
        "Mixed Doubles",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length === 3 && allUnassignedWomen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedMen[2]],
        "Mixed Gender",
        "Final cleanup 3M+1W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length === 3 && allUnassignedMen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedWomen[1], allUnassignedWomen[2]],
        "Mixed Gender",
        "Final cleanup 1M+3W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    
    if (!cleanupMatchCreated) {
      log("❌ CLEANUP FAILED: Cannot form matches from remaining players");
      break;
    }
  }

  const finalUnassignedMen = data.sortedMen.filter(p => !assigned.has(p.name));
  const finalUnassignedWomen = data.sortedWomen.filter(p => !assigned.has(p.name));
  
  log("=== FINAL STATUS ===");
  log("Total matches created: " + matches.length);
  log("Unassigned players: " + (finalUnassignedMen.length + finalUnassignedWomen.length));
  
  if (finalUnassignedMen.length > 0 || finalUnassignedWomen.length > 0) {
    log("❌ ERROR: Players remain unassigned!");
    log("Unassigned men: " + finalUnassignedMen.map(p => p.name + "(" + p.grade + ")").join(", "));
    log("Unassigned women: " + finalUnassignedWomen.map(p => p.name + "(" + p.grade + ")").join(", "));
  }

  return matches;
}

function formSameSexDoublesMatches(data) {
  log("Using Same-Sex Doubles Logic");
  
  const matches = [];
  const assigned = new Set();
  let courtIndex = 0;

  const createMatch = (team1, team2, format, note) => {
    if (courtIndex >= data.courts.length) return null;

    const court = data.courts[courtIndex].court;
    courtIndex++;

    team1.forEach(p => assigned.add(p.name));
    team2.forEach(p => assigned.add(p.name));

    log("Created match on Court " + court + ": " + 
        team1.map(p => p.name + "(" + p.grade + ")").join(",") + " vs " +
        team2.map(p => p.name + "(" + p.grade + ")").join(","));

    return { court, team1, team2, format, note };
  };

  for (let targetGrade = 5; targetGrade >= 1; targetGrade--) {
    log("=== PROCESSING GRADE " + targetGrade + " ===");
    
    while (true) {
      const menThisGrade = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      if (menThisGrade.length >= 4) {
        const match = createMatch(
          [menThisGrade[0], menThisGrade[1]],
          [menThisGrade[2], menThisGrade[3]],
          "Same-Sex Doubles (Men)", "In-grade"
        );
        if (match) matches.push(match);
      } else break;
    }
    
    while (true) {
      const womenThisGrade = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      if (womenThisGrade.length >= 4) {
        const match = createMatch(
          [womenThisGrade[0], womenThisGrade[1]],
          [womenThisGrade[2], womenThisGrade[3]],
          "Same-Sex Doubles (Women)", "In-grade"
        );
        if (match) matches.push(match);
      } else break;
    }
    
    let attempts = 0;
    while (attempts < 20) {
      attempts++;
      
      const remainingMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      const remainingWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      
      if (remainingMen.length === 0 && remainingWomen.length === 0) {
        log("✓ SUCCESS: ALL Grade " + targetGrade + " players assigned");
        break;
      }

      const lowerMen = data.sortedMen.filter(p => p.grade < targetGrade && !assigned.has(p.name));
      const lowerWomen = data.sortedWomen.filter(p => p.grade < targetGrade && !assigned.has(p.name));

      let matchCreated = false;

      if (remainingMen.length === 3 && remainingWomen.length === 1) {
        const match = createMatch(
          [remainingMen[0], remainingWomen[0]],
          [remainingMen[1], remainingMen[2]],
          "Mixed Gender", "3M+1W completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length === 3 && remainingMen.length === 1) {
        const match = createMatch(
          [remainingMen[0], remainingWomen[0]],
          [remainingWomen[1], remainingWomen[2]],
          "Mixed Gender", "1M+3W completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length === 2 && remainingWomen.length === 2) {
        const match = createMatch(
          [remainingMen[0], remainingWomen[0]],
          [remainingMen[1], remainingWomen[1]],
          "Mixed Doubles", "2M+2W completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 2 && lowerWomen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerWomen[0]],
          [remainingMen[1], lowerWomen[1]],
          "Mixed Doubles", "Cross-grade"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 2 && lowerMen.length >= 2) {
        const match = createMatch(
          [lowerMen[0], remainingWomen[0]],
          [lowerMen[1], remainingWomen[1]],
          "Mixed Doubles", "Cross-grade"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length === 1 && remainingWomen.length === 1 && lowerMen.length >= 1 && lowerWomen.length >= 1) {
        const match = createMatch(
          [remainingMen[0], lowerWomen[0]],
          [lowerMen[0], remainingWomen[0]],
          "Mixed Doubles", "1M+1W cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 1 && lowerMen.length >= 3) {
        const match = createMatch(
          [remainingMen[0], lowerMen[0]],
          [lowerMen[1], lowerMen[2]],
          "Same-Sex Doubles (Men)",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 1 && lowerWomen.length >= 3) {
        const match = createMatch(
          [remainingWomen[0], lowerWomen[0]],
          [lowerWomen[1], lowerWomen[2]],
          "Same-Sex Doubles (Women)",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 1 && lowerMen.length >= 1 && lowerWomen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerWomen[0]],
          [lowerMen[0], lowerWomen[1]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 1 && lowerWomen.length >= 1 && lowerMen.length >= 2) {
        const match = createMatch(
          [lowerMen[0], remainingWomen[0]],
          [lowerMen[1], lowerWomen[0]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
else if (remainingMen.length >= 2 && lowerMen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerMen[0]],
          [remainingMen[1], lowerMen[1]],
          "Same-Sex Doubles (Men)",
          "Cross-grade 2+2 completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 2 && lowerWomen.length >= 2) {
        const match = createMatch(
          [remainingWomen[0], lowerWomen[0]],
          [remainingWomen[1], lowerWomen[1]],
          "Same-Sex Doubles (Women)",
          "Cross-grade 2+2 completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      
      if (!matchCreated) {
        log("Cannot complete Grade " + targetGrade + " - remaining: " + 
            remainingMen.length + "M + " + remainingWomen.length + "W");
        break;
      }
    }
  }

  log("=== FINAL CLEANUP PHASE ===");
  let cleanupAttempts = 0;
  while (cleanupAttempts < 20) {
    cleanupAttempts++;
    
    const allUnassignedMen = data.sortedMen.filter(p => !assigned.has(p.name));
    const allUnassignedWomen = data.sortedWomen.filter(p => !assigned.has(p.name));
    
    if (allUnassignedMen.length === 0 && allUnassignedWomen.length === 0) {
      log("✓ CLEANUP SUCCESS: All players assigned");
      break;
    }
    
    log("Cleanup attempt " + cleanupAttempts + ": " + allUnassignedMen.length + "M + " + allUnassignedWomen.length + "W remaining");
    
    let cleanupMatchCreated = false;
    
    if (allUnassignedMen.length >= 4) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedMen[1]],
        [allUnassignedMen[2], allUnassignedMen[3]],
        "Same-Sex Doubles (Men)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length >= 4) {
      const match = createMatch(
        [allUnassignedWomen[0], allUnassignedWomen[1]],
        [allUnassignedWomen[2], allUnassignedWomen[3]],
        "Same-Sex Doubles (Women)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length >= 2 && allUnassignedWomen.length >= 2) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedWomen[1]],
        "Mixed Doubles",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length === 3 && allUnassignedWomen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedMen[2]],
        "Mixed Gender",
        "Final cleanup 3M+1W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length === 3 && allUnassignedMen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedWomen[1], allUnassignedWomen[2]],
        "Mixed Gender",
        "Final cleanup 1M+3W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    
    if (!cleanupMatchCreated) {
      log("❌ CLEANUP FAILED: Cannot form matches from remaining players");
      break;
    }
  }

  log("=== FINAL STATUS ===");
  log("Total matches created: " + matches.length);
  return matches;
}

function balanceTeamsIfNeeded(match) {
  // Only balance same-sex matches (the problematic ones)
  if (match.format !== "Same-Sex Doubles (Men)" && match.format !== "Same-Sex Doubles (Women)") {
    return match;
  }
  
  const team1Grades = match.team1.map(p => p.grade);
  const team2Grades = match.team2.map(p => p.grade);
  
  // Check for "2 strong vs 2 weak" pattern (grades 4-5 vs grades 1-3)
  const team1Strong = team1Grades.filter(g => g >= 4).length;
  const team2Strong = team2Grades.filter(g => g >= 4).length;
  
  // If one team has 2 strong and other has 0 strong, swap one player
  if (team1Strong === 2 && team2Strong === 0) {
    // Swap the weaker player from team1 with stronger player from team2
    const weakerInTeam1 = team1Grades[0] < team1Grades[1] ? 0 : 1;
    const strongerInTeam2 = team2Grades[0] > team2Grades[1] ? 0 : 1;
    
    const tempPlayer = match.team1[weakerInTeam1];
    match.team1[weakerInTeam1] = match.team2[strongerInTeam2];
    match.team2[strongerInTeam2] = tempPlayer;
    
    log("⚖️ Balanced teams: Swapped " + tempPlayer.name + " ↔ " + match.team1[weakerInTeam1].name);
  }
  else if (team1Strong === 0 && team2Strong === 2) {
    // Swap the weaker player from team2 with stronger player from team1
    const weakerInTeam2 = team2Grades[0] < team2Grades[1] ? 0 : 1;
    const strongerInTeam1 = team1Grades[0] > team1Grades[1] ? 0 : 1;
    
    const tempPlayer = match.team2[weakerInTeam2];
    match.team2[weakerInTeam2] = match.team1[strongerInTeam1];
    match.team1[strongerInTeam1] = tempPlayer;
    
    log("⚖️ Balanced teams: Swapped " + tempPlayer.name + " ↔ " + match.team2[weakerInTeam2].name);
  }
  
  return match;
}

function processCourtPreferences(data, matches) {
  log("=== COURT PREFERENCES ===");
  
  const isHardCourt = (court) => court && court.toString().toUpperCase().startsWith('H');
  const isGrassCourt = (court) => {
    const courtStr = court && court.toString().toUpperCase();
    return courtStr && (courtStr.startsWith('G') || (!courtStr.startsWith('H') && /^\d+$/.test(courtStr)));
  };
  
  const hasNHCPlayer = (match) => {
    const allPlayers = [...match.team1, ...match.team2];
    return allPlayers.some(player => {
      const menPlayer = data.sortedMen.find(p => p.name === player.name);
      const womenPlayer = data.sortedWomen.find(p => p.name === player.name);
      const foundPlayer = menPlayer || womenPlayer;
      return foundPlayer && foundPlayer.nhc;
    });
  };
  
  const nhcOnHard = [];
  const nonNhcOnGrass = [];
  
  matches.forEach((match, index) => {
    if (isHardCourt(match.court) && hasNHCPlayer(match)) {
      nhcOnHard.push({index, match});
    } else if (isGrassCourt(match.court) && !hasNHCPlayer(match)) {
      nonNhcOnGrass.push({index, match});
    }
  });
  
  const swaps = Math.min(nhcOnHard.length, nonNhcOnGrass.length);
  for (let i = 0; i < swaps; i++) {
    const tempCourt = nhcOnHard[i].match.court;
    matches[nhcOnHard[i].index].court = nonNhcOnGrass[i].match.court;
    matches[nonNhcOnGrass[i].index].court = tempCourt;
    log("Court swap: " + tempCourt + " ↔ " + nonNhcOnGrass[i].match.court);
  }
  
  return matches;
}

function checkForRepeatPartnerships(currentSetNumber, currentMatches) {
  if (currentSetNumber <= 1) return [];
  
  const repeatPartners = [];
  
  // Get all partnerships from current set
  const currentPartnerships = [];
  currentMatches.forEach((match, matchIndex) => {
    // Team 1 partnership
    if (match.team1.length === 2) {
      currentPartnerships.push({
        matchIndex: matchIndex,
        team: 1,
        players: [match.team1[0].name, match.team1[1].name].sort()
      });
    }
    // Team 2 partnership
    if (match.team2.length === 2) {
      currentPartnerships.push({
        matchIndex: matchIndex,
        team: 2,
        players: [match.team2[0].name, match.team2[1].name].sort()
      });
    }
  });
  
  // Check against all previous sets
  for (let setNum = 1; setNum < currentSetNumber; setNum++) {
    if (!allSetsData[setNum] || !allSetsData[setNum].matches) continue;
    
    const previousMatches = allSetsData[setNum].matches;
    const previousPartnerships = [];
    
    previousMatches.forEach(match => {
      if (match.team1.length === 2) {
        previousPartnerships.push([match.team1[0].name, match.team1[1].name].sort());
      }
      if (match.team2.length === 2) {
        previousPartnerships.push([match.team2[0].name, match.team2[1].name].sort());
      }
    });
    
    // Compare current partnerships with previous ones
    currentPartnerships.forEach(current => {
      previousPartnerships.forEach(previous => {
        if (current.players[0] === previous[0] && current.players[1] === previous[1]) {
          repeatPartners.push({
            matchIndex: current.matchIndex,
            team: current.team,
            players: current.players,
            previousSet: setNum
          });
          log("Repeat partnership found: " + current.players.join(" & ") + " (previously in Set " + setNum + ")");
        }
      });
    });
  }
  
  return repeatPartners;
}

function autoFixRepeatPartnerships(data, matches) {
  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  if (currentSetNum <= 1) return matches;
  
  log("=== AUTO-FIXING REPEAT PARTNERSHIPS ===");
  
  // Create a working copy of matches
  const workingMatches = JSON.parse(JSON.stringify(matches));
  
  // Get repeat partnerships
  let repeatPartners = checkForRepeatPartnerships(currentSetNum, workingMatches);
  
  if (repeatPartners.length === 0) {
    log("No repeat partnerships found - no auto-fixes needed");
    return workingMatches;
  }
  
  log("Found " + repeatPartners.length + " repeat partnerships to attempt fixing");
  
  // STRICT LIMIT: Only fix the first 10 repeat partnerships to prevent browser lockup
  const maxFixes = Math.min(10, repeatPartners.length);
  if (maxFixes < repeatPartners.length) {
    log("PERFORMANCE LIMIT: Only attempting to fix first " + maxFixes + " partnerships to prevent browser lockup");
    log("Remaining " + (repeatPartners.length - maxFixes) + " partnerships will be left for manual adjustment");
  }

  // PHASE 1: Try simple intra-match swaps first (especially for same-sex matches)
  log("=== PHASE 1: INTRA-MATCH FIXES ===");
  
  let fixedCount = 0;
  let attemptCount = 0;
  const maxAttempts = 50; // Hard limit to prevent infinite loops
  
  for (let i = 0; i < maxFixes && fixedCount < maxFixes && attemptCount < maxAttempts; i++) {
    attemptCount++;
    
    // Get fresh repeat partnerships (some may have been fixed)
    const currentRepeats = checkForRepeatPartnerships(currentSetNum, workingMatches);
    if (currentRepeats.length === 0 || i >= currentRepeats.length) break;
    
    const repeat = currentRepeats[i];
    const matchIndex = repeat.matchIndex;
    const teamNum = parseInt(repeat.team);
    const match = workingMatches[matchIndex];
    const currentTeam = teamNum === 1 ? match.team1 : match.team2;
    const opposingTeam = teamNum === 1 ? match.team2 : match.team1;
    
    log("Attempting intra-match fix " + (i + 1) + "/" + maxFixes + ": " + repeat.players.join(" & "));
    
    // Try simple intra-match swaps for both same-sex and mixed doubles matches
    if (match.format.includes("Same-Sex") || match.format.includes("Mixed Doubles")) {
      const beforeCount = currentRepeats.length;
      
      // Try swapping each player in the problematic team with each player in opposing team
      let fixedInMatch = false;
      for (let currentPlayerIndex = 0; currentPlayerIndex < currentTeam.length && !fixedInMatch; currentPlayerIndex++) {
        for (let opponentIndex = 0; opponentIndex < opposingTeam.length && !fixedInMatch; opponentIndex++) {
          
          const currentPlayer = currentTeam[currentPlayerIndex];
          const opponentPlayer = opposingTeam[opponentIndex];
          
          // For same-sex matches, ensure players are same gender
          if (match.format.includes("Same-Sex")) {
            if (getPlayerGender(currentPlayer.name, data) !== getPlayerGender(opponentPlayer.name, data)) {
              continue; // Skip if different genders
            }
          }
          
          // For mixed doubles, ensure the swap maintains the mixed format
          if (match.format.includes("Mixed Doubles")) {
            // Check if swapping would break the mixed doubles format
            const tempTeam1 = [...currentTeam];
            const tempTeam2 = [...opposingTeam];
            tempTeam1[currentPlayerIndex] = opponentPlayer;
            tempTeam2[opponentIndex] = currentPlayer;
            
            // Count genders in each team after swap
            const team1Men = tempTeam1.filter(p => getPlayerGender(p.name, data) === 'M').length;
            const team1Women = tempTeam1.filter(p => getPlayerGender(p.name, data) === 'W').length;
            const team2Men = tempTeam2.filter(p => getPlayerGender(p.name, data) === 'M').length;
            const team2Women = tempTeam2.filter(p => getPlayerGender(p.name, data) === 'W').length;
            
            // Only allow swap if both teams remain 1M+1W (mixed doubles format)
            if (!(team1Men === 1 && team1Women === 1 && team2Men === 1 && team2Women === 1)) {
              continue; // Skip swap that would break mixed doubles format
            }
          }
          
          // Perform the test swap
          currentTeam[currentPlayerIndex] = opponentPlayer;
          opposingTeam[opponentIndex] = currentPlayer;
          
          const afterCount = checkForRepeatPartnerships(currentSetNum, workingMatches).length;
          
          if (afterCount < beforeCount) {
            // Success! The swap reduced conflicts
            log("✓ Intra-match fix: Swapped " + currentPlayer.name + " ↔ " + opponentPlayer.name);
            log("  Repeat partnerships reduced from " + beforeCount + " to " + afterCount);
            fixedInMatch = true;
            fixedCount++;
            break;
          } else {
            // Revert the swap - it didn't help
            currentTeam[currentPlayerIndex] = currentPlayer;
            opposingTeam[opponentIndex] = opponentPlayer;
          }
        }
      }
      
      if (fixedInMatch) {
        continue; // Move to next repeat partnership
      }
    }
  }
  
  // Check if Phase 1 solved enough or we've hit our limits
  const remainingRepeats = checkForRepeatPartnerships(currentSetNum, workingMatches);
  if (remainingRepeats.length === 0 || fixedCount >= maxFixes || attemptCount >= maxAttempts) {
    if (remainingRepeats.length === 0) {
      log("🎉 Phase 1 resolved all repeat partnerships!");
    } else if (fixedCount >= maxFixes) {
      log("Phase 1 completed: Fixed maximum allowed (" + maxFixes + ") partnerships");
      log("Remaining " + remainingRepeats.length + " partnerships left for manual adjustment");
    } else {
      log("Phase 1 stopped at attempt limit (" + maxAttempts + ") to prevent browser lockup");
      log("Remaining " + remainingRepeats.length + " partnerships left for manual adjustment");
    }
    return workingMatches;
  }

  // PHASE 2: Complex inter-match swaps (much more limited)
  log("=== PHASE 2: INTER-MATCH FIXES ===");
  log("Remaining repeats after Phase 1: " + remainingRepeats.length);
  
  // Only attempt inter-match fixes if we haven't hit our limits yet
  if (fixedCount < maxFixes && attemptCount < maxAttempts) {
    const remainingFixAttempts = maxFixes - fixedCount;
    const remainingAttemptBudget = maxAttempts - attemptCount;
    
    log("Budget remaining: " + remainingFixAttempts + " fixes, " + remainingAttemptBudget + " attempts");
    
    // Get set format preference for prioritizing swap types
    const setFormatPreference = data.setFormatPreference;
    
    // Process remaining repeat partnerships with simplified logic
    for (let i = 0; i < Math.min(remainingFixAttempts, remainingRepeats.length) && attemptCount < maxAttempts; i++) {
      attemptCount++;
      
      const repeat = remainingRepeats[i];
      const matchIndex = repeat.matchIndex;
      const teamNum = parseInt(repeat.team);
      const match = workingMatches[matchIndex];
      const currentTeam = teamNum === 1 ? match.team1 : match.team2;
      
      log("Attempting inter-match fix " + (i + 1) + ": " + repeat.players.join(" & "));
      
      let fixedInMatch = false;
      
      // Simplified swap strategies - only try the most promising ones
      const swapStrategies = [
        { name: "Same grade, same gender", criteria: (p1, p2) => p1.grade === p2.grade && getPlayerGender(p1.name, data) === getPlayerGender(p2.name, data) },
        { name: "Adjacent grade, same gender", criteria: (p1, p2) => Math.abs(p1.grade - p2.grade) === 1 && getPlayerGender(p1.name, data) === getPlayerGender(p2.name, data) }
      ];
      
      // Try swaps with other matches (limited scope)
      for (let strategy of swapStrategies) {
        if (fixedInMatch || attemptCount >= maxAttempts) break;
        
        for (let otherMatchIndex = 0; otherMatchIndex < Math.min(10, workingMatches.length) && !fixedInMatch && attemptCount < maxAttempts; otherMatchIndex++) {
          if (otherMatchIndex === matchIndex) continue;
          
          const otherMatch = workingMatches[otherMatchIndex];
          
          // Try swapping with players from both teams of other matches
          for (let otherTeamNum = 1; otherTeamNum <= 2 && !fixedInMatch; otherTeamNum++) {
            const otherTeam = otherTeamNum === 1 ? otherMatch.team1 : otherMatch.team2;
            
            // Try swapping only the first player to reduce complexity
            for (let otherPlayerIndex = 0; otherPlayerIndex < Math.min(1, otherTeam.length) && !fixedInMatch; otherPlayerIndex++) {
              
              const currentPlayer = currentTeam[0]; // Only try first player
              const otherPlayer = otherTeam[otherPlayerIndex];
              
              // Check if this swap meets the current strategy criteria
              if (!strategy.criteria(currentPlayer, otherPlayer)) continue;
              
              // Test the swap
              const beforeCount = checkForRepeatPartnerships(currentSetNum, workingMatches).length;
              
              // Perform the test swap
              currentTeam[0] = otherPlayer;
              otherTeam[otherPlayerIndex] = currentPlayer;
              
              const afterCount = checkForRepeatPartnerships(currentSetNum, workingMatches).length;
              
              if (afterCount < beforeCount) {
                // Success! The swap reduced conflicts
                log("✓ Inter-match fix (" + strategy.name + "): Swapped " + currentPlayer.name + " ↔ " + otherPlayer.name);
                log("  Repeat partnerships reduced from " + beforeCount + " to " + afterCount);
                fixedInMatch = true;
                fixedCount++;
                break;
              } else {
                // Revert the swap - it didn't help
                currentTeam[0] = currentPlayer;
                otherTeam[otherPlayerIndex] = otherPlayer;
              }
            }
          }
        }
      }
      
      if (!fixedInMatch) {
        log("❌ Could not auto-fix: " + repeat.players.join(" & ") + " - leaving for manual adjustment");
      }
    }
  }
  
  const finalRepeats = checkForRepeatPartnerships(currentSetNum, workingMatches);
  if (finalRepeats.length > 0) {
    log("❌ Auto-fix completed with limits. Remaining: " + finalRepeats.length);
    log("Fixed: " + fixedCount + " partnerships in " + attemptCount + " attempts");
    log("Remaining partnerships require manual drag-and-drop adjustment");
  } else {
    log("🎉 Successfully resolved all repeat partnerships!");
  }
  
  return workingMatches;
}
function wouldCreateBalancedTeams(matches, match1Index, player1Index, team1Num, player2Index, team2Num, match2Index = null) {
  // If match2Index is null, we're swapping within the same match
  const match2Index_actual = match2Index !== null ? match2Index : match1Index;
  
  const match1 = matches[match1Index];
  const match2 = matches[match2Index_actual];
  
  const team1 = team1Num === 1 ? match1.team1 : match1.team2;
  const team2 = team2Num === 1 ? match2.team1 : match2.team2;
  
  const player1 = team1[player1Index];
  const player2 = team2[player2Index];
  
  // If swapping within same match, be more permissive (usually safe)
  if (match2Index === null) {
    return true;
  }
  
  // For inter-match swaps, check what the final team compositions would be
  const team1OtherPlayer = team1[1 - player1Index]; // The other player in team1
  const team2OtherPlayer = team2[1 - player2Index]; // The other player in team2
  
  // Calculate what the teams would look like after the swap
  const newTeam1 = [team1OtherPlayer, player2];
  const newTeam2 = [team2OtherPlayer, player1];
  
  // Get the opposing teams in each match
  const match1OpposingTeam = team1Num === 1 ? match1.team2 : match1.team1;
  const match2OpposingTeam = team2Num === 1 ? match2.team2 : match2.team1;
  
  // Check if both final matches would be balanced
  const match1Balanced = isMatchupBalanced(newTeam1, match1OpposingTeam);
  const match2Balanced = isMatchupBalanced(newTeam2, match2OpposingTeam);
  
  return match1Balanced && match2Balanced;
}

function fixUncompetitiveMatches(data, matches) {
  log("=== FINAL COMPETITIVENESS OPTIMIZATION ===");
  
  // Step 1: Identify uncompetitive matches
  const uncompetitiveMatches = [];
  matches.forEach((match, index) => {
    if (isUncompetitive(match)) {
      uncompetitiveMatches.push({index, match});
    }
  });
  
  log(`Found ${uncompetitiveMatches.length} uncompetitive matches`);
  
  if (uncompetitiveMatches.length <= 1) {
    log("≤1 uncompetitive match found - leaving for operator to handle");
    return matches;
  }
  
  // Step 2: Process pairs of uncompetitive matches
  const pairsToProcess = Math.floor(uncompetitiveMatches.length / 2);
  log(`Processing ${pairsToProcess} pairs of uncompetitive matches`);
  
  for (let pairIndex = 0; pairIndex < pairsToProcess; pairIndex++) {
    const matchA = uncompetitiveMatches[pairIndex * 2];
    const matchB = uncompetitiveMatches[pairIndex * 2 + 1];
    
    log(`\n--- Processing pair ${pairIndex + 1}: Match ${matchA.index} & Match ${matchB.index} ---`);
    
    // Try the swap
    if (attemptCompetitivenessSwap(data, matches, matchA.index, matchB.index)) {
      log(`✓ Successful competitiveness swap between matches ${matchA.index} & ${matchB.index}`);
    } else {
      log(`❌ No beneficial swap found between matches ${matchA.index} & ${matchB.index}`);
    }
  }
  
  // Report final status
  const finalUncompetitive = matches.filter(match => isUncompetitive(match)).length;
  log(`\n=== COMPETITIVENESS OPTIMIZATION COMPLETE ===`);
  log(`Uncompetitive matches reduced from ${uncompetitiveMatches.length} to ${finalUncompetitive}`);
  
  return matches;
}

function balanceIndividualMatches(data, matches) {
  log("=== FINAL INDIVIDUAL MATCH BALANCING ===");
  
  let totalImprovedMatches = 0;
  
  matches.forEach((match, matchIndex) => {
    // Check if match needs balancing (≥2 point gap)
    const team1Total = match.team1.reduce((sum, p) => sum + p.grade, 0);
    const team2Total = match.team2.reduce((sum, p) => sum + p.grade, 0);
    const currentGap = Math.abs(team1Total - team2Total);
    
    if (currentGap < 2) return; // Skip well-balanced matches
    
    log(`Match ${matchIndex} needs balancing: ${team1Total} vs ${team2Total} (gap=${currentGap})`);
    
    // Test all 3 possible swaps
    let bestSwap = null;
    let bestGap = currentGap;
    
    for (let t1Player = 0; t1Player < 2; t1Player++) {
      for (let t2Player = 0; t2Player < 2; t2Player++) {
        if (t1Player === 1 && t2Player === 1) continue; // Skip redundant swap
        
        // Test this swap
        const testMatch = JSON.parse(JSON.stringify(match));
        const tempPlayer = testMatch.team1[t1Player];
        testMatch.team1[t1Player] = testMatch.team2[t2Player];
        testMatch.team2[t2Player] = tempPlayer;
        
        // Check if creates 2M vs 2F
        if (creates2Mvs2F(testMatch, data)) continue;
        
        // Calculate new balance
        const newTeam1Total = testMatch.team1.reduce((sum, p) => sum + p.grade, 0);
        const newTeam2Total = testMatch.team2.reduce((sum, p) => sum + p.grade, 0);
        const newGap = Math.abs(newTeam1Total - newTeam2Total);
        
        // Keep if it's the best improvement so far
        if (newGap < bestGap) {
          bestGap = newGap;
          bestSwap = { t1Player, t2Player };
        }
      }
    }
    
    // Apply the best swap if found
    if (bestSwap) {
      const tempPlayer = match.team1[bestSwap.t1Player];
      match.team1[bestSwap.t1Player] = match.team2[bestSwap.t2Player];
      match.team2[bestSwap.t2Player] = tempPlayer;
      
      updateMatchFormat(match);
      log(`  ✓ Swapped players: Gap reduced from ${currentGap} to ${bestGap}`);
      totalImprovedMatches++;
    } else {
      log(`  No valid improvement found for match ${matchIndex}`);
    }
  });
  
  log(`=== INDIVIDUAL MATCH BALANCING COMPLETE: ${totalImprovedMatches} matches improved ===`);
  return matches;
}

function isUncompetitive(match) {
  const team1Grades = match.team1.map(p => p.grade).sort((a,b) => b-a); // [high, low]
  const team2Grades = match.team2.map(p => p.grade).sort((a,b) => b-a); // [high, low]
  
  // Calculate intra-team gaps
  const team1Gap = team1Grades[0] - team1Grades[1];
  const team2Gap = team2Grades[0] - team2Grades[1];
  
  // Uncompetitive if ANY partnership has 2+ grade gap
  const isUncomp = team1Gap >= 2 || team2Gap >= 2;
  
  if (isUncomp) {
    log(`Uncompetitive match: [${team1Grades.join(',')}] vs [${team2Grades.join(',')}] - gaps: ${team1Gap}, ${team2Gap}`);
  }
  
  return isUncomp;
}

function attemptCompetitivenessSwap(data, matches, matchAIndex, matchBIndex) {
  const matchA = matches[matchAIndex];
  const matchB = matches[matchBIndex];
  
  // Get all players from both matches with their current positions
  const playersA = [
    ...matchA.team1.map((p, i) => ({...p, match: matchAIndex, team: 1, position: i})),
    ...matchA.team2.map((p, i) => ({...p, match: matchAIndex, team: 2, position: i}))
  ];
  
  const playersB = [
    ...matchB.team1.map((p, i) => ({...p, match: matchBIndex, team: 1, position: i})),
    ...matchB.team2.map((p, i) => ({...p, match: matchBIndex, team: 2, position: i}))
  ];
  
  // Sort players by grade
  playersA.sort((a, b) => a.grade - b.grade); // weakest first
  playersB.sort((a, b) => b.grade - a.grade); // strongest first
  
  // Get the 2 weakest from A and 2 strongest from B
  const weakestFromA = playersA.slice(0, 2);
  const strongestFromB = playersB.slice(0, 2);
  
  log(`Swapping (no competitiveness check needed):`);
  log(`  Weakest from Match ${matchAIndex}: ${weakestFromA.map(p => `${p.name}(${p.grade})`).join(', ')}`);
  log(`  Strongest from Match ${matchBIndex}: ${strongestFromB.map(p => `${p.name}(${p.grade})`).join(', ')}`);
  
  // Create test versions of the matches
  const testMatchA = JSON.parse(JSON.stringify(matchA));
  const testMatchB = JSON.parse(JSON.stringify(matchB));
  
  // Perform direct 1-for-1 swaps
  // Swap weakest player 1 from A with strongest player 1 from B
  const weakPlayer1 = weakestFromA[0];
  const strongPlayer1 = strongestFromB[0];
  
  const weakTeam1 = weakPlayer1.team === 1 ? testMatchA.team1 : testMatchA.team2;
  const strongTeam1 = strongPlayer1.team === 1 ? testMatchB.team1 : testMatchB.team2;
  
  const temp1 = {...weakTeam1[weakPlayer1.position]};
  weakTeam1[weakPlayer1.position] = {...strongTeam1[strongPlayer1.position]};
  strongTeam1[strongPlayer1.position] = temp1;
  
  // Swap weakest player 2 from A with strongest player 2 from B
  const weakPlayer2 = weakestFromA[1];
  const strongPlayer2 = strongestFromB[1];
  
  const weakTeam2 = weakPlayer2.team === 1 ? testMatchA.team1 : testMatchA.team2;
  const strongTeam2 = strongPlayer2.team === 1 ? testMatchB.team1 : testMatchB.team2;
  
  const temp2 = {...weakTeam2[weakPlayer2.position]};
  weakTeam2[weakPlayer2.position] = {...strongTeam2[strongPlayer2.position]};
  strongTeam2[strongPlayer2.position] = temp2;
  
  // Only check if the swap creates the forbidden 2M vs 2F pattern
  if (creates2Mvs2F(testMatchA, data) || creates2Mvs2F(testMatchB, data)) {
    log(`  ❌ Swap would create 2M vs 2F - rejected`);
    return false;
  }
  
  // Accept the swap
  matches[matchAIndex] = testMatchA;
  matches[matchBIndex] = testMatchB;
  
  // Update match formats
  updateMatchFormat(matches[matchAIndex]);
  updateMatchFormat(matches[matchBIndex]);
  
  log(`  ✓ Swap completed`);
  return true;
}

function creates2Mvs2F(match, data) {
  const team1Men = match.team1.filter(p => getPlayerGender(p.name, data) === 'M').length;
  const team1Women = match.team1.filter(p => getPlayerGender(p.name, data) === 'F').length;
  const team2Men = match.team2.filter(p => getPlayerGender(p.name, data) === 'M').length;
  const team2Women = match.team2.filter(p => getPlayerGender(p.name, data) === 'F').length;
  
  // Check for 2M vs 2F pattern
  return (team1Men === 2 && team1Women === 0 && team2Men === 0 && team2Women === 2) ||
         (team1Men === 0 && team1Women === 2 && team2Men === 2 && team2Women === 0);
}

function isMatchupBalanced(team1, team2) {
  const team1Grades = team1.map(p => p.grade).sort((a, b) => b - a); // High to low
  const team2Grades = team2.map(p => p.grade).sort((a, b) => b - a); // High to low
  
  const team1High = team1Grades[0];
  const team1Low = team1Grades[1];
  const team2High = team2Grades[0];
  const team2Low = team2Grades[1];
  
  // Rule 1: Both teams should have similar highest grades (within 1 grade)
  if (Math.abs(team1High - team2High) > 1) {
    return false;
  }
  
  // Rule 2: Calculate total team strength
  const team1Total = team1High + team1Low;
  const team2Total = team2High + team2Low;
  
  // Rule 3: Special handling for Grade 5 players
  const team1HasGrade5 = team1Grades.includes(5);
  const team2HasGrade5 = team2Grades.includes(5);
  
  // If one team has Grade 5 and the other doesn't, be very strict
  if (team1HasGrade5 && !team2HasGrade5) {
    // Team 2 needs at least 4+4 to compete with a team that has a Grade 5
    return team2High === 4 && team2Low === 4;
  }
  if (team2HasGrade5 && !team1HasGrade5) {
    // Team 1 needs at least 4+4 to compete with a team that has a Grade 5
    return team1High === 4 && team1Low === 4;
  }
  
  // For teams without Grade 5, allow reasonable differences
  return Math.abs(team1Total - team2Total) <= 2;
}

function getPlayerGender(playerName, data) {
  // Check sorted arrays first
  let menPlayer = data.sortedMen ? data.sortedMen.find(p => p.name === playerName) : null;
  let womenPlayer = data.sortedWomen ? data.sortedWomen.find(p => p.name === playerName) : null;
  
  // If not found, check available arrays
  if (!menPlayer && data.availableMen) {
    menPlayer = data.availableMen.find(p => p.name === playerName);
  }
  if (!womenPlayer && data.availableWomen) {
    womenPlayer = data.availableWomen.find(p => p.name === playerName);
  }
  
  return menPlayer ? 'M' : (womenPlayer ? 'F' : null);
}

function testSwapReducesConflicts(matches, match1Index, team1Num, player1Index, match2Index, team2Num, player2Index, currentSetNum) {
  // Create a test copy of matches with the proposed swap
  const testMatches = JSON.parse(JSON.stringify(matches));
  
  const match1 = testMatches[match1Index];
  const match2 = testMatches[match2Index];
  const team1 = team1Num === 1 ? match1.team1 : match1.team2;
  const team2 = team2Num === 1 ? match2.team1 : match2.team2;
  
  // Get conflict count before swap
  const conflictsBefore = checkForRepeatPartnerships(currentSetNum, matches).length;
  
  // Perform the test swap
  const tempPlayer = team1[player1Index];
  team1[player1Index] = team2[player2Index];
  team2[player2Index] = tempPlayer;
  
  // Get conflict count after swap
  const conflictsAfter = checkForRepeatPartnerships(currentSetNum, testMatches).length;
  
  // The swap is beneficial if it reduces conflicts and doesn't create new ones in different partnerships
  return conflictsAfter < conflictsBefore;
}

function displayResults(data, matches) {
  // Save current set data immediately when matches are generated
  currentSetNumber = parseInt(document.getElementById('setNumberSelector').value);
  
  // Combine manual matches with generated matches
  const allMatches = [...manualMatches, ...matches];
  
  allSetsData[currentSetNumber] = {
    data: JSON.parse(JSON.stringify(data)),
    matches: JSON.parse(JSON.stringify(allMatches)),
    satOffPlayers: []
  };

  // Store sat off players (players marked as SO, not resting)
const satOffPlayers = playerRows.filter(p => p.name && p.so).map(p => p.name);
  if (satOffPlayers.length > 0) {
    allSetsData[currentSetNumber].satOffPlayers = [...satOffPlayers];
    log("Stored " + allSetsData[currentSetNumber].satOffPlayers.length + " sat-off players for Set " + currentSetNumber);
  } else {
    log("No players sat off for Set " + currentSetNumber + " (evenly divisible by 4)");
  }

  log("Set " + currentSetNumber + " data saved to memory");
  
  const matchesDiv = document.getElementById('matches');
  const matchResults = document.getElementById('matchResults');
  
  const repeatPartners = checkForRepeatPartnerships(currentSetNumber, allMatches);
  let matchHtml = '<div class="success">✓ ' + allMatches.length + ' Matches Generated';
  if (manualMatches.length > 0) {
    matchHtml += ' (' + manualMatches.length + ' manual + ' + matches.length + ' automatic)';
  }
  matchHtml += '</div>';
  matchHtml += '<p style="color: #666; font-style: italic;">Drag players or courts to swap them</p>';
  
 const isNHCPlayer = (playerName) => {
  // Check original data first (for manual match players)
  let menPlayer = data.availableMen ? data.availableMen.find(p => p.name === playerName) : null;
  let womenPlayer = data.availableWomen ? data.availableWomen.find(p => p.name === playerName) : null;
  
  // If not found in original lists, check sorted lists (for auto match players)
  if (!menPlayer && data.sortedMen) {
    menPlayer = data.sortedMen.find(p => p.name === playerName);
  }
  if (!womenPlayer && data.sortedWomen) {
    womenPlayer = data.sortedWomen.find(p => p.name === playerName);
  }
  
  const foundPlayer = menPlayer || womenPlayer;
  return foundPlayer && foundPlayer.nhc;
};
  
  allMatches.forEach((match, matchIndex) => {
    const isManual = match.isManual || false;
    const containerClass = isManual ? 'match-container manual-match' : 'match-container';
    
    matchHtml += '<div class="' + containerClass + '">';
    
    const courtClass = isManual ? 'court-box manual' : 'court-box';
    matchHtml += '<div class="compact-teams-row" style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">';

matchHtml += '<div class="' + courtClass + '" draggable="true" data-type="court" data-match="' + matchIndex + '" data-court="' + match.court + '">';
matchHtml += 'Court ' + match.court;
if (isManual) matchHtml += ' (Manual)';
matchHtml += '</div>';

// Team 1 players
match.team1.forEach((player, playerIndex) => {
  const nhcClass = isNHCPlayer(player.name) ? ' nhc' : '';
  const manualClass = isManual ? ' manual-match' : '';
  const isRepeatPartner = repeatPartners.some(rp => 
    rp.matchIndex === matchIndex && 
    rp.team === 1 && 
    rp.players.includes(player.name)
  );
  const repeatClass = isRepeatPartner ? ' repeat-partner' : '';
  matchHtml += '<div class="player-box-compact' + nhcClass + repeatClass + manualClass + '" draggable="true" ';
  matchHtml += 'data-type="player" data-match="' + matchIndex + '" data-team="1" data-player="' + playerIndex + '" ';
  matchHtml += 'data-name="' + player.name + '" data-grade="' + player.grade + '">';
  matchHtml += player.name + ' (' + translateGrade(player.grade) + ')</div>';
});

// VS divider
matchHtml += '<div class="vs-compact" style="font-weight: bold; color: #666; margin: 0 5px;">vs</div>';

// Team 2 players
match.team2.forEach((player, playerIndex) => {
  const nhcClass = isNHCPlayer(player.name) ? ' nhc' : '';
  const manualClass = isManual ? ' manual-match' : '';
  const isRepeatPartner = repeatPartners.some(rp => 
    rp.matchIndex === matchIndex && 
    rp.team === 2 && 
    rp.players.includes(player.name)
  );
  const repeatClass = isRepeatPartner ? ' repeat-partner' : '';
  matchHtml += '<div class="player-box-compact' + nhcClass + repeatClass + manualClass + '" draggable="true" ';
  matchHtml += 'data-type="player" data-match="' + matchIndex + '" data-team="2" data-player="' + playerIndex + '" ';
  matchHtml += 'data-name="' + player.name + '" data-grade="' + player.grade + '">';
  matchHtml += player.name + ' (' + translateGrade(player.grade) + ')</div>';
});

matchHtml += '</div>';
   // matchHtml += '<div class="format">' + match.format;
   // if (isManual) matchHtml += ' - Manual Setup';
   // matchHtml += '</div>';
    matchHtml += '</div>';
  });
  
  matchResults.innerHTML = matchHtml;
  matchesDiv.style.display = 'block';
  
  // Update current matches to include manual matches
  currentMatches = allMatches;
  
  setTimeout(() => initializeDragAndDrop(), 100);
}

function initializeDragAndDrop() {
  log("Initializing drag and drop");
  
  let draggedElement = null;
  let draggedData = null;
  
  const matchResults = document.getElementById('matchResults');
  if (!matchResults) return;
  
  const newMatchResults = matchResults.cloneNode(true);
  matchResults.parentNode.replaceChild(newMatchResults, matchResults);
  
  newMatchResults.addEventListener('dragstart', function(e) {
    if (e.target.getAttribute('draggable') === 'true') {
      draggedElement = e.target;
      draggedData = {
        type: e.target.dataset.type,
        match: parseInt(e.target.dataset.match),
        team: e.target.dataset.team,
        player: parseInt(e.target.dataset.player),
        court: e.target.dataset.court,
        name: e.target.dataset.name,
        grade: e.target.dataset.grade
      };
      e.target.classList.add('dragging');
      log("Dragging: " + (draggedData.name || draggedData.court));
    }
  });
  
  newMatchResults.addEventListener('dragend', function(e) {
    if (e.target.getAttribute('draggable') === 'true') {
      e.target.classList.remove('dragging');
      newMatchResults.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
    }
  });
  
  newMatchResults.addEventListener('dragover', function(e) {
    e.preventDefault();
  });
  
 newMatchResults.addEventListener('dragenter', function(e) {
  if (e.target.classList.contains('player-box') || e.target.classList.contains('player-box-compact') || e.target.classList.contains('court-box')) {
    e.target.classList.add('drag-over');
  }
});

newMatchResults.addEventListener('dragleave', function(e) {
  if (e.target.classList.contains('player-box') || e.target.classList.contains('player-box-compact') || e.target.classList.contains('court-box')) {
    e.target.classList.remove('drag-over');
  }
});
  
  newMatchResults.addEventListener('drop', function(e) {
    e.preventDefault();
    
    if (!draggedElement || !draggedData) return;
    
    const dropTarget = e.target;
    if (dropTarget === draggedElement) return;
    
    dropTarget.classList.remove('drag-over');
    
if (draggedData.type === 'player' && (dropTarget.classList.contains('player-box') || dropTarget.classList.contains('player-box-compact'))) {
      const targetData = {
        match: parseInt(dropTarget.dataset.match),
        team: dropTarget.dataset.team,
        player: parseInt(dropTarget.dataset.player),
        name: dropTarget.dataset.name
      };
      
      log("Swapping players: " + draggedData.name + " ↔ " + targetData.name);
      swapPlayers(draggedData, targetData);
      // Update stored data
      if (allSetsData[currentSetNumber]) {
        allSetsData[currentSetNumber].matches = JSON.parse(JSON.stringify(currentMatches));
      }
      refreshDisplay();
    }
    else if (draggedData.type === 'court' && dropTarget.classList.contains('court-box')) {
      const targetMatch = parseInt(dropTarget.dataset.match);
      const targetCourt = dropTarget.dataset.court;
      
      log("Swapping courts: " + draggedData.court + " ↔ " + targetCourt);
      swapCourts(draggedData.match, targetMatch);
      // Update stored data
      if (allSetsData[currentSetNumber]) {
        allSetsData[currentSetNumber].matches = JSON.parse(JSON.stringify(currentMatches));
      }
      refreshDisplay();
    }
    
    draggedElement = null;
    draggedData = null;
  });
}

function swapPlayers(player1, player2) {
  const match1 = currentMatches[player1.match];
  const match2 = currentMatches[player2.match];
  
  const team1 = player1.team === '1' ? match1.team1 : match1.team2;
  const team2 = player2.team === '1' ? match2.team1 : match2.team2;
  
  const tempPlayer = { ...team1[player1.player] };
  team1[player1.player] = { ...team2[player2.player] };
  team2[player2.player] = tempPlayer;

// Update match formats after swap
updateMatchFormat(currentMatches[player1.match]);
updateMatchFormat(currentMatches[player2.match]);
}

function updateMatchFormat(match) {
  if (!match || !match.team1 || !match.team2) return;
// Debug: Check what the data looks like
  console.log("currentData:", currentData);
  console.log("sortedMen:", currentData.sortedMen);
  console.log("sortedWomen:", currentData.sortedWomen);
  console.log("First player from team1:", match.team1[0]);
  
  // Count players by gender in each team
  const team1Men = match.team1.filter(p => getPlayerGender(p.name, currentData) === 'M').length;
  const team1Women = match.team1.filter(p => getPlayerGender(p.name, currentData) === 'F').length;
  const team2Men = match.team2.filter(p => getPlayerGender(p.name, currentData) === 'M').length;
  const team2Women = match.team2.filter(p => getPlayerGender(p.name, currentData) === 'F').length;
  
  // Determine correct format
  if (team1Men === 1 && team1Women === 1 && team2Men === 1 && team2Women === 1) {
    match.format = "Mixed Doubles";
  } else if (team1Men === 2 && team2Men === 2) {
    match.format = "Same-Sex Doubles (Men)";
  } else if (team1Women === 2 && team2Women === 2) {
    match.format = "Same-Sex Doubles (Women)";
  } else {
    match.format = "Mixed Gender";
  }
}

function getPlayerGender(playerName, data) {
  // Check sorted arrays first
  let menPlayer = data.sortedMen ? data.sortedMen.find(p => p.name === playerName) : null;
  let womenPlayer = data.sortedWomen ? data.sortedWomen.find(p => p.name === playerName) : null;
  
  // If not found, check available arrays
  if (!menPlayer && data.availableMen) {
    menPlayer = data.availableMen.find(p => p.name === playerName);
  }
  if (!womenPlayer && data.availableWomen) {
    womenPlayer = data.availableWomen.find(p => p.name === playerName);
  }
  
  return menPlayer ? 'M' : (womenPlayer ? 'F' : null);
}

function swapCourts(match1Index, match2Index) {
  const tempCourt = currentMatches[match1Index].court;
  currentMatches[match1Index].court = currentMatches[match2Index].court;
  currentMatches[match2Index].court = tempCourt;
}

function refreshDisplay() {
  displayResults(currentData, currentMatches.filter(m => !m.isManual));
}

// Print match sheet function
function printMatchSheet(data, matches) {
  try {
    const printWindow = window.open('', '_blank', 'width=800,height=600');
    
    const satOffPlayers = playerRows.filter(p => p.name && p.so).map(p => p.name);
    
    let printHTML = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Tennis Match Sheet - Set ${document.getElementById('setNumberSelector').value}</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 20px; 
      background: white; 
      color: black;
      line-height: 1.3;
    }
/* Step Header Styles */
.step-header {
  background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
  color: white;
  font-size: 24px;
  font-weight: bold;
  padding: 20px 30px;
  margin: -15px -15px 20px -15px;
  border-radius: 8px 8px 0 0;
  text-align: left;
  box-shadow: 0 2px 8px rgba(30, 64, 175, 0.3);
}
    .header { 
      text-align: center; 
      margin-bottom: 30px; 
      border-bottom: 2px solid black; 
      padding-bottom: 15px;
    }
    .header h1 { 
      margin: 0; 
      font-size: 24px; 
      font-weight: bold;
    }
    .header-info { 
      font-size: 16px; 
      margin: 8px 0;
    }
    .sat-off-section { 
      background: #f0f0f0; 
      border: 2px solid black; 
      padding: 15px; 
      margin: 20px 0; 
      border-radius: 5px;
    }
    .sat-off-title { 
      font-size: 18px; 
      font-weight: bold; 
      margin-bottom: 10px;
    }
    .sat-off-list { 
      font-size: 16px; 
      font-weight: bold;
    }
    .match { 
      border: 1px solid black; 
      margin: 15px 0; 
      padding: 15px; 
      page-break-inside: avoid;
      border-radius: 5px;
    }
    .match.manual { 
      background: #fff8dc; 
      border-left: 5px solid #ffc107;
    }
    .court-number { 
  font-size: 16px; 
  font-weight: bold; 
  background: black; 
  color: white; 
  padding: 4px 8px; 
  border-radius: 3px; 
  display: inline-block; 
  margin-right: 10px;
}
    .court-number.manual { 
      background: #ffc107; 
      color: #856404;
    }
    @media print {
  body { margin: 15px; }
  .match { page-break-inside: avoid; }
  .court-number { 
    background: none !important; 
    color: black !important; 
    border: 1px solid black;
    padding: 2px 6px;
    font-size: 16px;
  }
  .court-number.manual { 
    border-color: #ffc107 !important;
    background: #fff8dc !important;
  }
}
    .teams-container { 
      display: flex; 
      justify-content: space-between; 
      align-items: center;
    }
    .team { 
      font-size: 16px; 
      font-weight: bold; 
      flex: 1;
    }
    .vs { 
      font-size: 20px; 
      font-weight: bold; 
      margin: 0 20px; 
      text-align: center;
    }
    .match-format { 
      font-size: 14px; 
      font-style: italic; 
      color: #555; 
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Tennis Match Sheet</h1>
    <div class="header-info">Date: ${new Date().toLocaleDateString()}</div>
    <div class="header-info">Set Number: ${document.getElementById('setNumberSelector').value}</div>
    <div class="header-info">Format: ${data.setFormatPreference}</div>
  </div>
`;

    if (satOffPlayers.length > 0) {
      printHTML += `
  <div class="sat-off-section">
    <div class="sat-off-title">Players Sitting Off This Set:</div>
    <div class="sat-off-list">${satOffPlayers.join(', ')}</div>
  </div>
`;
    }

    matches.forEach((match, index) => {
      const team1Str = match.team1.map(p => `${p.name} (${translateGrade(p.grade)})`).join(', ');
const team2Str = match.team2.map(p => `${p.name} (${translateGrade(p.grade)})`).join(', ');
      const isManual = match.isManual || false;
      
      printHTML += `
  <div class="match${isManual ? ' manual' : ''}">
    <div class="teams-container">
      <div class="court-number${isManual ? ' manual' : ''}">Court ${match.court}${isManual ? ' (Manual)' : ''}</div>
      <div class="team">${team1Str}</div>
      <div class="vs">VS</div>
      <div class="team">${team2Str}</div>
    </div>
  </div>
`;
    });

    printHTML += `
</body>
</html>`;

    printWindow.document.write(printHTML);
    printWindow.document.close();
    
    setTimeout(() => {
      printWindow.focus();
      printWindow.print();
    }, 250);
    
    log("Print dialog opened for match sheet");
    
  } catch (error) {
    alert("Error creating print sheet: " + error.message);
    log("Error creating print sheet: " + error.message);
  }
}

function downloadResults(data, matches) {
  try {
    const wb = XLSX.utils.book_new();
    
    // Get all completed sets from storage
    const completedSets = Object.keys(allSetsData).sort((a, b) => parseInt(a) - parseInt(b));
    
    if (completedSets.length === 0) {
      // Fallback to current set if no stored data
      createSingleSetSheet(wb, data, matches, currentSetNumber);
    } else {
      // Create a sheet for each completed set
      completedSets.forEach(setNum => {
        const setData = allSetsData[setNum];
        createSingleSetSheet(wb, setData.data, setData.matches, setNum, setData.satOffPlayers);
      });
    }
    
    // Generate filename with timestamp
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const setCount = completedSets.length || 1;
    const filename = `Tennis_Matches_${setCount}_Sets_${timestamp}.xlsx`;
    
    // Download the file
    XLSX.writeFile(wb, filename);
    
    log("Excel file downloaded: " + filename + " with " + (completedSets.length || 1) + " sheets");
    
  } catch (error) {
    alert("Error creating Excel file: " + error.message);
    log("Error creating Excel file: " + error.message);
  }
}

function createSingleSetSheet(wb, data, matches, setNumber, satOffPlayers = []) {
  const wsData = [];
  
  // Add header information
  wsData.push(['Date', new Date().toISOString().split('T')[0]]);
  wsData.push(['Set Number', 'Set ' + setNumber]);
  wsData.push(['Set Format Preference', data.setFormatPreference]);
  wsData.push([]);
  
  // Add match headers AND player list headers on the same row (row 5)
  wsData.push(['Court', 'Team 1', 'Team 2', 'Match Format', 'Match Type', 'Sat Off Players', '', 'Total Men Players', 'Grade', 'NHC', 'Resting', 'PSO', '', 'Total Women Players', 'Grade', 'NHC', 'Resting', 'PSO']);
  
  // Determine how many rows we need (matches vs players)
  const maxRows = Math.max(matches.length, data.availableMen.length, data.availableWomen.length);
  
  // Add data rows
  for (let i = 0; i < maxRows; i++) {
    const row = ['', '', '', '', '', '', '']; // Columns A-G (matches + spacing)
    
    // Add match data if we have a match for this row
    if (i < matches.length) {
      const match = matches[i];
     // Check for repeat partnerships for this match
const repeatPartners = checkForRepeatPartnerships(setNumber, matches);

const team1Str = match.team1.map(p => {
  const isRepeatPartner = repeatPartners.some(rp => 
    rp.matchIndex === i && 
    rp.team === 1 && 
    rp.players.includes(p.name)
  );
  const prefix = isRepeatPartner ? 'R:' : '';
  return `${prefix}${p.name} (${translateGrade(p.grade)})`;
}).join(', ');

const team2Str = match.team2.map(p => {
  const isRepeatPartner = repeatPartners.some(rp => 
    rp.matchIndex === i && 
    rp.team === 2 && 
    rp.players.includes(p.name)
  );
  const prefix = isRepeatPartner ? 'R:' : '';
  return `${prefix}${p.name} (${translateGrade(p.grade)})`;
}).join(', ');
      const satOffPlayer = i < satOffPlayers.length ? satOffPlayers[i] : '';
      const matchType = match.isManual ? 'Manual' : 'Auto';
      
      row[0] = match.court;           // A: Court
      row[1] = team1Str;              // B: Team 1
      row[2] = team2Str;              // C: Team 2
      row[3] = match.format;          // D: Match Format
      row[4] = matchType;             // E: Match Type
      row[5] = satOffPlayer;          // F: Sat Off Players
      row[6] = '';                    // G: Spacing
    }
    
    // Add men's data if we have a man for this row (columns H-L)
    if (i < data.availableMen.length) {
      const player = data.availableMen[i];
      row[7] = player.name;           // H: Men's names
      row[8] = player.grade;          // I: Men's grade
      row[9] = player.nhc ? 'y' : ''; // J: Men's NHC
      row[10] = player.resting ? 'y' : ''; // K: Men's resting
      row[11] = player.pso ? 'y' : ''; // L: Men's PSO
    }
    
    // Column M: Spacing between men and women
    row[12] = '';
    
    // Add women's data if we have a woman for this row (columns N-R)
    if (i < data.availableWomen.length) {
      const player = data.availableWomen[i];
      row[13] = player.name;          // N: Women's names
      row[14] = player.grade;         // O: Women's grade
      row[15] = player.nhc ? 'y' : ''; // P: Women's NHC
      row[16] = player.resting ? 'y' : ''; // Q: Women's resting
      row[17] = player.pso ? 'y' : ''; // R: Women's PSO
    }
    
    wsData.push(row);
  }
  
  // Create worksheet
  const ws = XLSX.utils.aoa_to_sheet(wsData);
  
  // Set column widths - wider for names, narrower for single letters
  ws['!cols'] = [
    { wch: 20 }, // A: Court
    { wch: 50 }, // B: Team 1
    { wch: 50 }, // C: Team 2
    { wch: 25 }, // D: Match Format
    { wch: 10 }, // E: Match Type
    { wch: 20 }, // F: Sat Off Players
    { wch: 3 },  // G: Spacing
    { wch: 20 }, // H: Men's names
    { wch: 8 },  // I: Men's grade
    { wch: 6 },  // J: Men's NHC
    { wch: 8 },  // K: Men's resting
    { wch: 6 },  // L: Men's PSO
    { wch: 3 },  // M: Spacing
    { wch: 20 }, // N: Women's names
    { wch: 8 },  // O: Women's grade
    { wch: 6 },  // P: Women's NHC
    { wch: 8 },  // Q: Women's resting
    { wch: 6 }   // R: Women's PSO
  ];
  
  // Add worksheet to workbook
  XLSX.utils.book_append_sheet(wb, ws, 'Set ' + setNumber + ' Summary');
}

// Initialize the page
document.addEventListener('DOMContentLoaded', () => {
  initializeCourts();
});

// Download and print functions
document.getElementById('downloadBtn').onclick = function() {
  if (currentData && currentMatches) {
    downloadResults(currentData, currentMatches);
  } else {
    alert('No matches to download. Please generate matches first.');
  }
};

document.getElementById('printBtn').onclick = function() {
  if (currentData && currentMatches) {
    printMatchSheet(currentData, currentMatches);
  } else {
    alert('No matches to print. Please generate matches first.');
  }
};
</script>
</body>
</html>
        